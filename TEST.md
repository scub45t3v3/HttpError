# TOC
   - [BadGateway](#badgateway)
     - [#VERSION](#badgateway-version)
     - [#code](#badgateway-code)
     - [#status](#badgateway-status)
     - [#message](#badgateway-message)
     - [#getMessage](#badgateway-getmessage)
     - [#setMessage](#badgateway-setmessage)
     - [#getDebug](#badgateway-getdebug)
     - [#setDebug](#badgateway-setdebug)
     - [#getCause](#badgateway-getcause)
     - [#setCause](#badgateway-setcause)
     - [#set](#badgateway-set)
     - [#get](#badgateway-get)
     - [#toJSON](#badgateway-tojson)
     - [#toString](#badgateway-tostring)
     - [#[Symbol.toStringTag]](#badgateway-symboltostringtag)
   - [BadRequest](#badrequest)
     - [#VERSION](#badrequest-version)
     - [#code](#badrequest-code)
     - [#status](#badrequest-status)
     - [#message](#badrequest-message)
     - [#getMessage](#badrequest-getmessage)
     - [#setMessage](#badrequest-setmessage)
     - [#getDebug](#badrequest-getdebug)
     - [#setDebug](#badrequest-setdebug)
     - [#getCause](#badrequest-getcause)
     - [#setCause](#badrequest-setcause)
     - [#set](#badrequest-set)
     - [#get](#badrequest-get)
     - [#toJSON](#badrequest-tojson)
     - [#toString](#badrequest-tostring)
     - [#[Symbol.toStringTag]](#badrequest-symboltostringtag)
   - [ClientError](#clienterror)
   - [Conflict](#conflict)
     - [#VERSION](#conflict-version)
     - [#code](#conflict-code)
     - [#status](#conflict-status)
     - [#message](#conflict-message)
     - [#getMessage](#conflict-getmessage)
     - [#setMessage](#conflict-setmessage)
     - [#getDebug](#conflict-getdebug)
     - [#setDebug](#conflict-setdebug)
     - [#getCause](#conflict-getcause)
     - [#setCause](#conflict-setcause)
     - [#set](#conflict-set)
     - [#get](#conflict-get)
     - [#toJSON](#conflict-tojson)
     - [#toString](#conflict-tostring)
     - [#[Symbol.toStringTag]](#conflict-symboltostringtag)
   - [ExpectationFailed](#expectationfailed)
     - [#VERSION](#expectationfailed-version)
     - [#code](#expectationfailed-code)
     - [#status](#expectationfailed-status)
     - [#message](#expectationfailed-message)
     - [#getMessage](#expectationfailed-getmessage)
     - [#setMessage](#expectationfailed-setmessage)
     - [#getDebug](#expectationfailed-getdebug)
     - [#setDebug](#expectationfailed-setdebug)
     - [#getCause](#expectationfailed-getcause)
     - [#setCause](#expectationfailed-setcause)
     - [#set](#expectationfailed-set)
     - [#get](#expectationfailed-get)
     - [#toJSON](#expectationfailed-tojson)
     - [#toString](#expectationfailed-tostring)
     - [#[Symbol.toStringTag]](#expectationfailed-symboltostringtag)
   - [FailedDependency](#faileddependency)
     - [#VERSION](#faileddependency-version)
     - [#code](#faileddependency-code)
     - [#status](#faileddependency-status)
     - [#message](#faileddependency-message)
     - [#getMessage](#faileddependency-getmessage)
     - [#setMessage](#faileddependency-setmessage)
     - [#getDebug](#faileddependency-getdebug)
     - [#setDebug](#faileddependency-setdebug)
     - [#getCause](#faileddependency-getcause)
     - [#setCause](#faileddependency-setcause)
     - [#set](#faileddependency-set)
     - [#get](#faileddependency-get)
     - [#toJSON](#faileddependency-tojson)
     - [#toString](#faileddependency-tostring)
     - [#[Symbol.toStringTag]](#faileddependency-symboltostringtag)
   - [Forbidden](#forbidden)
     - [#VERSION](#forbidden-version)
     - [#code](#forbidden-code)
     - [#status](#forbidden-status)
     - [#message](#forbidden-message)
     - [#getMessage](#forbidden-getmessage)
     - [#setMessage](#forbidden-setmessage)
     - [#getDebug](#forbidden-getdebug)
     - [#setDebug](#forbidden-setdebug)
     - [#getCause](#forbidden-getcause)
     - [#setCause](#forbidden-setcause)
     - [#set](#forbidden-set)
     - [#get](#forbidden-get)
     - [#toJSON](#forbidden-tojson)
     - [#toString](#forbidden-tostring)
     - [#[Symbol.toStringTag]](#forbidden-symboltostringtag)
   - [GatewayTimeout](#gatewaytimeout)
     - [#VERSION](#gatewaytimeout-version)
     - [#code](#gatewaytimeout-code)
     - [#status](#gatewaytimeout-status)
     - [#message](#gatewaytimeout-message)
     - [#getMessage](#gatewaytimeout-getmessage)
     - [#setMessage](#gatewaytimeout-setmessage)
     - [#getDebug](#gatewaytimeout-getdebug)
     - [#setDebug](#gatewaytimeout-setdebug)
     - [#getCause](#gatewaytimeout-getcause)
     - [#setCause](#gatewaytimeout-setcause)
     - [#set](#gatewaytimeout-set)
     - [#get](#gatewaytimeout-get)
     - [#toJSON](#gatewaytimeout-tojson)
     - [#toString](#gatewaytimeout-tostring)
     - [#[Symbol.toStringTag]](#gatewaytimeout-symboltostringtag)
   - [Gone](#gone)
     - [#VERSION](#gone-version)
     - [#code](#gone-code)
     - [#status](#gone-status)
     - [#message](#gone-message)
     - [#getMessage](#gone-getmessage)
     - [#setMessage](#gone-setmessage)
     - [#getDebug](#gone-getdebug)
     - [#setDebug](#gone-setdebug)
     - [#getCause](#gone-getcause)
     - [#setCause](#gone-setcause)
     - [#set](#gone-set)
     - [#get](#gone-get)
     - [#toJSON](#gone-tojson)
     - [#toString](#gone-tostring)
     - [#[Symbol.toStringTag]](#gone-symboltostringtag)
   - [HTTPVersionNotSupported](#httpversionnotsupported)
     - [#VERSION](#httpversionnotsupported-version)
     - [#code](#httpversionnotsupported-code)
     - [#status](#httpversionnotsupported-status)
     - [#message](#httpversionnotsupported-message)
     - [#getMessage](#httpversionnotsupported-getmessage)
     - [#setMessage](#httpversionnotsupported-setmessage)
     - [#getDebug](#httpversionnotsupported-getdebug)
     - [#setDebug](#httpversionnotsupported-setdebug)
     - [#getCause](#httpversionnotsupported-getcause)
     - [#setCause](#httpversionnotsupported-setcause)
     - [#set](#httpversionnotsupported-set)
     - [#get](#httpversionnotsupported-get)
     - [#toJSON](#httpversionnotsupported-tojson)
     - [#toString](#httpversionnotsupported-tostring)
     - [#[Symbol.toStringTag]](#httpversionnotsupported-symboltostringtag)
   - [HttpError](#httperror)
   - [IMATeapot](#imateapot)
     - [#VERSION](#imateapot-version)
     - [#code](#imateapot-code)
     - [#status](#imateapot-status)
     - [#message](#imateapot-message)
     - [#getMessage](#imateapot-getmessage)
     - [#setMessage](#imateapot-setmessage)
     - [#getDebug](#imateapot-getdebug)
     - [#setDebug](#imateapot-setdebug)
     - [#getCause](#imateapot-getcause)
     - [#setCause](#imateapot-setcause)
     - [#set](#imateapot-set)
     - [#get](#imateapot-get)
     - [#toJSON](#imateapot-tojson)
     - [#toString](#imateapot-tostring)
     - [#[Symbol.toStringTag]](#imateapot-symboltostringtag)
   - [InsufficientStorage](#insufficientstorage)
     - [#VERSION](#insufficientstorage-version)
     - [#code](#insufficientstorage-code)
     - [#status](#insufficientstorage-status)
     - [#message](#insufficientstorage-message)
     - [#getMessage](#insufficientstorage-getmessage)
     - [#setMessage](#insufficientstorage-setmessage)
     - [#getDebug](#insufficientstorage-getdebug)
     - [#setDebug](#insufficientstorage-setdebug)
     - [#getCause](#insufficientstorage-getcause)
     - [#setCause](#insufficientstorage-setcause)
     - [#set](#insufficientstorage-set)
     - [#get](#insufficientstorage-get)
     - [#toJSON](#insufficientstorage-tojson)
     - [#toString](#insufficientstorage-tostring)
     - [#[Symbol.toStringTag]](#insufficientstorage-symboltostringtag)
   - [InternalServerError](#internalservererror)
     - [#VERSION](#internalservererror-version)
     - [#code](#internalservererror-code)
     - [#status](#internalservererror-status)
     - [#message](#internalservererror-message)
     - [#getMessage](#internalservererror-getmessage)
     - [#setMessage](#internalservererror-setmessage)
     - [#getDebug](#internalservererror-getdebug)
     - [#setDebug](#internalservererror-setdebug)
     - [#getCause](#internalservererror-getcause)
     - [#setCause](#internalservererror-setcause)
     - [#set](#internalservererror-set)
     - [#get](#internalservererror-get)
     - [#toJSON](#internalservererror-tojson)
     - [#toString](#internalservererror-tostring)
     - [#[Symbol.toStringTag]](#internalservererror-symboltostringtag)
   - [LengthRequired](#lengthrequired)
     - [#VERSION](#lengthrequired-version)
     - [#code](#lengthrequired-code)
     - [#status](#lengthrequired-status)
     - [#message](#lengthrequired-message)
     - [#getMessage](#lengthrequired-getmessage)
     - [#setMessage](#lengthrequired-setmessage)
     - [#getDebug](#lengthrequired-getdebug)
     - [#setDebug](#lengthrequired-setdebug)
     - [#getCause](#lengthrequired-getcause)
     - [#setCause](#lengthrequired-setcause)
     - [#set](#lengthrequired-set)
     - [#get](#lengthrequired-get)
     - [#toJSON](#lengthrequired-tojson)
     - [#toString](#lengthrequired-tostring)
     - [#[Symbol.toStringTag]](#lengthrequired-symboltostringtag)
   - [Locked](#locked)
     - [#VERSION](#locked-version)
     - [#code](#locked-code)
     - [#status](#locked-status)
     - [#message](#locked-message)
     - [#getMessage](#locked-getmessage)
     - [#setMessage](#locked-setmessage)
     - [#getDebug](#locked-getdebug)
     - [#setDebug](#locked-setdebug)
     - [#getCause](#locked-getcause)
     - [#setCause](#locked-setcause)
     - [#set](#locked-set)
     - [#get](#locked-get)
     - [#toJSON](#locked-tojson)
     - [#toString](#locked-tostring)
     - [#[Symbol.toStringTag]](#locked-symboltostringtag)
   - [LoopDetected](#loopdetected)
     - [#VERSION](#loopdetected-version)
     - [#code](#loopdetected-code)
     - [#status](#loopdetected-status)
     - [#message](#loopdetected-message)
     - [#getMessage](#loopdetected-getmessage)
     - [#setMessage](#loopdetected-setmessage)
     - [#getDebug](#loopdetected-getdebug)
     - [#setDebug](#loopdetected-setdebug)
     - [#getCause](#loopdetected-getcause)
     - [#setCause](#loopdetected-setcause)
     - [#set](#loopdetected-set)
     - [#get](#loopdetected-get)
     - [#toJSON](#loopdetected-tojson)
     - [#toString](#loopdetected-tostring)
     - [#[Symbol.toStringTag]](#loopdetected-symboltostringtag)
   - [MethodNotAllowed](#methodnotallowed)
     - [#VERSION](#methodnotallowed-version)
     - [#code](#methodnotallowed-code)
     - [#status](#methodnotallowed-status)
     - [#message](#methodnotallowed-message)
     - [#getMessage](#methodnotallowed-getmessage)
     - [#setMessage](#methodnotallowed-setmessage)
     - [#getDebug](#methodnotallowed-getdebug)
     - [#setDebug](#methodnotallowed-setdebug)
     - [#getCause](#methodnotallowed-getcause)
     - [#setCause](#methodnotallowed-setcause)
     - [#set](#methodnotallowed-set)
     - [#get](#methodnotallowed-get)
     - [#toJSON](#methodnotallowed-tojson)
     - [#toString](#methodnotallowed-tostring)
     - [#[Symbol.toStringTag]](#methodnotallowed-symboltostringtag)
   - [MisdirectedRequest](#misdirectedrequest)
     - [#VERSION](#misdirectedrequest-version)
     - [#code](#misdirectedrequest-code)
     - [#status](#misdirectedrequest-status)
     - [#message](#misdirectedrequest-message)
     - [#getMessage](#misdirectedrequest-getmessage)
     - [#setMessage](#misdirectedrequest-setmessage)
     - [#getDebug](#misdirectedrequest-getdebug)
     - [#setDebug](#misdirectedrequest-setdebug)
     - [#getCause](#misdirectedrequest-getcause)
     - [#setCause](#misdirectedrequest-setcause)
     - [#set](#misdirectedrequest-set)
     - [#get](#misdirectedrequest-get)
     - [#toJSON](#misdirectedrequest-tojson)
     - [#toString](#misdirectedrequest-tostring)
     - [#[Symbol.toStringTag]](#misdirectedrequest-symboltostringtag)
   - [NetworkAuthenticationRequired](#networkauthenticationrequired)
     - [#VERSION](#networkauthenticationrequired-version)
     - [#code](#networkauthenticationrequired-code)
     - [#status](#networkauthenticationrequired-status)
     - [#message](#networkauthenticationrequired-message)
     - [#getMessage](#networkauthenticationrequired-getmessage)
     - [#setMessage](#networkauthenticationrequired-setmessage)
     - [#getDebug](#networkauthenticationrequired-getdebug)
     - [#setDebug](#networkauthenticationrequired-setdebug)
     - [#getCause](#networkauthenticationrequired-getcause)
     - [#setCause](#networkauthenticationrequired-setcause)
     - [#set](#networkauthenticationrequired-set)
     - [#get](#networkauthenticationrequired-get)
     - [#toJSON](#networkauthenticationrequired-tojson)
     - [#toString](#networkauthenticationrequired-tostring)
     - [#[Symbol.toStringTag]](#networkauthenticationrequired-symboltostringtag)
   - [NotAcceptable](#notacceptable)
     - [#VERSION](#notacceptable-version)
     - [#code](#notacceptable-code)
     - [#status](#notacceptable-status)
     - [#message](#notacceptable-message)
     - [#getMessage](#notacceptable-getmessage)
     - [#setMessage](#notacceptable-setmessage)
     - [#getDebug](#notacceptable-getdebug)
     - [#setDebug](#notacceptable-setdebug)
     - [#getCause](#notacceptable-getcause)
     - [#setCause](#notacceptable-setcause)
     - [#set](#notacceptable-set)
     - [#get](#notacceptable-get)
     - [#toJSON](#notacceptable-tojson)
     - [#toString](#notacceptable-tostring)
     - [#[Symbol.toStringTag]](#notacceptable-symboltostringtag)
   - [NotExtended](#notextended)
     - [#VERSION](#notextended-version)
     - [#code](#notextended-code)
     - [#status](#notextended-status)
     - [#message](#notextended-message)
     - [#getMessage](#notextended-getmessage)
     - [#setMessage](#notextended-setmessage)
     - [#getDebug](#notextended-getdebug)
     - [#setDebug](#notextended-setdebug)
     - [#getCause](#notextended-getcause)
     - [#setCause](#notextended-setcause)
     - [#set](#notextended-set)
     - [#get](#notextended-get)
     - [#toJSON](#notextended-tojson)
     - [#toString](#notextended-tostring)
     - [#[Symbol.toStringTag]](#notextended-symboltostringtag)
   - [NotFound](#notfound)
     - [#VERSION](#notfound-version)
     - [#code](#notfound-code)
     - [#status](#notfound-status)
     - [#message](#notfound-message)
     - [#getMessage](#notfound-getmessage)
     - [#setMessage](#notfound-setmessage)
     - [#getDebug](#notfound-getdebug)
     - [#setDebug](#notfound-setdebug)
     - [#getCause](#notfound-getcause)
     - [#setCause](#notfound-setcause)
     - [#set](#notfound-set)
     - [#get](#notfound-get)
     - [#toJSON](#notfound-tojson)
     - [#toString](#notfound-tostring)
     - [#[Symbol.toStringTag]](#notfound-symboltostringtag)
   - [NotImplemented](#notimplemented)
     - [#VERSION](#notimplemented-version)
     - [#code](#notimplemented-code)
     - [#status](#notimplemented-status)
     - [#message](#notimplemented-message)
     - [#getMessage](#notimplemented-getmessage)
     - [#setMessage](#notimplemented-setmessage)
     - [#getDebug](#notimplemented-getdebug)
     - [#setDebug](#notimplemented-setdebug)
     - [#getCause](#notimplemented-getcause)
     - [#setCause](#notimplemented-setcause)
     - [#set](#notimplemented-set)
     - [#get](#notimplemented-get)
     - [#toJSON](#notimplemented-tojson)
     - [#toString](#notimplemented-tostring)
     - [#[Symbol.toStringTag]](#notimplemented-symboltostringtag)
   - [PayloadTooLarge](#payloadtoolarge)
     - [#VERSION](#payloadtoolarge-version)
     - [#code](#payloadtoolarge-code)
     - [#status](#payloadtoolarge-status)
     - [#message](#payloadtoolarge-message)
     - [#getMessage](#payloadtoolarge-getmessage)
     - [#setMessage](#payloadtoolarge-setmessage)
     - [#getDebug](#payloadtoolarge-getdebug)
     - [#setDebug](#payloadtoolarge-setdebug)
     - [#getCause](#payloadtoolarge-getcause)
     - [#setCause](#payloadtoolarge-setcause)
     - [#set](#payloadtoolarge-set)
     - [#get](#payloadtoolarge-get)
     - [#toJSON](#payloadtoolarge-tojson)
     - [#toString](#payloadtoolarge-tostring)
     - [#[Symbol.toStringTag]](#payloadtoolarge-symboltostringtag)
   - [PaymentRequired](#paymentrequired)
     - [#VERSION](#paymentrequired-version)
     - [#code](#paymentrequired-code)
     - [#status](#paymentrequired-status)
     - [#message](#paymentrequired-message)
     - [#getMessage](#paymentrequired-getmessage)
     - [#setMessage](#paymentrequired-setmessage)
     - [#getDebug](#paymentrequired-getdebug)
     - [#setDebug](#paymentrequired-setdebug)
     - [#getCause](#paymentrequired-getcause)
     - [#setCause](#paymentrequired-setcause)
     - [#set](#paymentrequired-set)
     - [#get](#paymentrequired-get)
     - [#toJSON](#paymentrequired-tojson)
     - [#toString](#paymentrequired-tostring)
     - [#[Symbol.toStringTag]](#paymentrequired-symboltostringtag)
   - [PreconditionFailed](#preconditionfailed)
     - [#VERSION](#preconditionfailed-version)
     - [#code](#preconditionfailed-code)
     - [#status](#preconditionfailed-status)
     - [#message](#preconditionfailed-message)
     - [#getMessage](#preconditionfailed-getmessage)
     - [#setMessage](#preconditionfailed-setmessage)
     - [#getDebug](#preconditionfailed-getdebug)
     - [#setDebug](#preconditionfailed-setdebug)
     - [#getCause](#preconditionfailed-getcause)
     - [#setCause](#preconditionfailed-setcause)
     - [#set](#preconditionfailed-set)
     - [#get](#preconditionfailed-get)
     - [#toJSON](#preconditionfailed-tojson)
     - [#toString](#preconditionfailed-tostring)
     - [#[Symbol.toStringTag]](#preconditionfailed-symboltostringtag)
   - [PreconditionRequired](#preconditionrequired)
     - [#VERSION](#preconditionrequired-version)
     - [#code](#preconditionrequired-code)
     - [#status](#preconditionrequired-status)
     - [#message](#preconditionrequired-message)
     - [#getMessage](#preconditionrequired-getmessage)
     - [#setMessage](#preconditionrequired-setmessage)
     - [#getDebug](#preconditionrequired-getdebug)
     - [#setDebug](#preconditionrequired-setdebug)
     - [#getCause](#preconditionrequired-getcause)
     - [#setCause](#preconditionrequired-setcause)
     - [#set](#preconditionrequired-set)
     - [#get](#preconditionrequired-get)
     - [#toJSON](#preconditionrequired-tojson)
     - [#toString](#preconditionrequired-tostring)
     - [#[Symbol.toStringTag]](#preconditionrequired-symboltostringtag)
   - [ProxyAuthenticationRequired](#proxyauthenticationrequired)
     - [#VERSION](#proxyauthenticationrequired-version)
     - [#code](#proxyauthenticationrequired-code)
     - [#status](#proxyauthenticationrequired-status)
     - [#message](#proxyauthenticationrequired-message)
     - [#getMessage](#proxyauthenticationrequired-getmessage)
     - [#setMessage](#proxyauthenticationrequired-setmessage)
     - [#getDebug](#proxyauthenticationrequired-getdebug)
     - [#setDebug](#proxyauthenticationrequired-setdebug)
     - [#getCause](#proxyauthenticationrequired-getcause)
     - [#setCause](#proxyauthenticationrequired-setcause)
     - [#set](#proxyauthenticationrequired-set)
     - [#get](#proxyauthenticationrequired-get)
     - [#toJSON](#proxyauthenticationrequired-tojson)
     - [#toString](#proxyauthenticationrequired-tostring)
     - [#[Symbol.toStringTag]](#proxyauthenticationrequired-symboltostringtag)
   - [RangeNotSatisfiable](#rangenotsatisfiable)
     - [#VERSION](#rangenotsatisfiable-version)
     - [#code](#rangenotsatisfiable-code)
     - [#status](#rangenotsatisfiable-status)
     - [#message](#rangenotsatisfiable-message)
     - [#getMessage](#rangenotsatisfiable-getmessage)
     - [#setMessage](#rangenotsatisfiable-setmessage)
     - [#getDebug](#rangenotsatisfiable-getdebug)
     - [#setDebug](#rangenotsatisfiable-setdebug)
     - [#getCause](#rangenotsatisfiable-getcause)
     - [#setCause](#rangenotsatisfiable-setcause)
     - [#set](#rangenotsatisfiable-set)
     - [#get](#rangenotsatisfiable-get)
     - [#toJSON](#rangenotsatisfiable-tojson)
     - [#toString](#rangenotsatisfiable-tostring)
     - [#[Symbol.toStringTag]](#rangenotsatisfiable-symboltostringtag)
   - [RequestHeaderFieldsTooLarge](#requestheaderfieldstoolarge)
     - [#VERSION](#requestheaderfieldstoolarge-version)
     - [#code](#requestheaderfieldstoolarge-code)
     - [#status](#requestheaderfieldstoolarge-status)
     - [#message](#requestheaderfieldstoolarge-message)
     - [#getMessage](#requestheaderfieldstoolarge-getmessage)
     - [#setMessage](#requestheaderfieldstoolarge-setmessage)
     - [#getDebug](#requestheaderfieldstoolarge-getdebug)
     - [#setDebug](#requestheaderfieldstoolarge-setdebug)
     - [#getCause](#requestheaderfieldstoolarge-getcause)
     - [#setCause](#requestheaderfieldstoolarge-setcause)
     - [#set](#requestheaderfieldstoolarge-set)
     - [#get](#requestheaderfieldstoolarge-get)
     - [#toJSON](#requestheaderfieldstoolarge-tojson)
     - [#toString](#requestheaderfieldstoolarge-tostring)
     - [#[Symbol.toStringTag]](#requestheaderfieldstoolarge-symboltostringtag)
   - [RequestTimeout](#requesttimeout)
     - [#VERSION](#requesttimeout-version)
     - [#code](#requesttimeout-code)
     - [#status](#requesttimeout-status)
     - [#message](#requesttimeout-message)
     - [#getMessage](#requesttimeout-getmessage)
     - [#setMessage](#requesttimeout-setmessage)
     - [#getDebug](#requesttimeout-getdebug)
     - [#setDebug](#requesttimeout-setdebug)
     - [#getCause](#requesttimeout-getcause)
     - [#setCause](#requesttimeout-setcause)
     - [#set](#requesttimeout-set)
     - [#get](#requesttimeout-get)
     - [#toJSON](#requesttimeout-tojson)
     - [#toString](#requesttimeout-tostring)
     - [#[Symbol.toStringTag]](#requesttimeout-symboltostringtag)
   - [ServerError](#servererror)
   - [ServiceUnavailable](#serviceunavailable)
     - [#VERSION](#serviceunavailable-version)
     - [#code](#serviceunavailable-code)
     - [#status](#serviceunavailable-status)
     - [#message](#serviceunavailable-message)
     - [#getMessage](#serviceunavailable-getmessage)
     - [#setMessage](#serviceunavailable-setmessage)
     - [#getDebug](#serviceunavailable-getdebug)
     - [#setDebug](#serviceunavailable-setdebug)
     - [#getCause](#serviceunavailable-getcause)
     - [#setCause](#serviceunavailable-setcause)
     - [#set](#serviceunavailable-set)
     - [#get](#serviceunavailable-get)
     - [#toJSON](#serviceunavailable-tojson)
     - [#toString](#serviceunavailable-tostring)
     - [#[Symbol.toStringTag]](#serviceunavailable-symboltostringtag)
   - [TooManyRequests](#toomanyrequests)
     - [#VERSION](#toomanyrequests-version)
     - [#code](#toomanyrequests-code)
     - [#status](#toomanyrequests-status)
     - [#message](#toomanyrequests-message)
     - [#getMessage](#toomanyrequests-getmessage)
     - [#setMessage](#toomanyrequests-setmessage)
     - [#getDebug](#toomanyrequests-getdebug)
     - [#setDebug](#toomanyrequests-setdebug)
     - [#getCause](#toomanyrequests-getcause)
     - [#setCause](#toomanyrequests-setcause)
     - [#set](#toomanyrequests-set)
     - [#get](#toomanyrequests-get)
     - [#toJSON](#toomanyrequests-tojson)
     - [#toString](#toomanyrequests-tostring)
     - [#[Symbol.toStringTag]](#toomanyrequests-symboltostringtag)
   - [URITooLong](#uritoolong)
     - [#VERSION](#uritoolong-version)
     - [#code](#uritoolong-code)
     - [#status](#uritoolong-status)
     - [#message](#uritoolong-message)
     - [#getMessage](#uritoolong-getmessage)
     - [#setMessage](#uritoolong-setmessage)
     - [#getDebug](#uritoolong-getdebug)
     - [#setDebug](#uritoolong-setdebug)
     - [#getCause](#uritoolong-getcause)
     - [#setCause](#uritoolong-setcause)
     - [#set](#uritoolong-set)
     - [#get](#uritoolong-get)
     - [#toJSON](#uritoolong-tojson)
     - [#toString](#uritoolong-tostring)
     - [#[Symbol.toStringTag]](#uritoolong-symboltostringtag)
   - [Unauthorized](#unauthorized)
     - [#VERSION](#unauthorized-version)
     - [#code](#unauthorized-code)
     - [#status](#unauthorized-status)
     - [#message](#unauthorized-message)
     - [#getMessage](#unauthorized-getmessage)
     - [#setMessage](#unauthorized-setmessage)
     - [#getDebug](#unauthorized-getdebug)
     - [#setDebug](#unauthorized-setdebug)
     - [#getCause](#unauthorized-getcause)
     - [#setCause](#unauthorized-setcause)
     - [#set](#unauthorized-set)
     - [#get](#unauthorized-get)
     - [#toJSON](#unauthorized-tojson)
     - [#toString](#unauthorized-tostring)
     - [#[Symbol.toStringTag]](#unauthorized-symboltostringtag)
   - [UnavailableForLegalReasons](#unavailableforlegalreasons)
     - [#VERSION](#unavailableforlegalreasons-version)
     - [#code](#unavailableforlegalreasons-code)
     - [#status](#unavailableforlegalreasons-status)
     - [#message](#unavailableforlegalreasons-message)
     - [#getMessage](#unavailableforlegalreasons-getmessage)
     - [#setMessage](#unavailableforlegalreasons-setmessage)
     - [#getDebug](#unavailableforlegalreasons-getdebug)
     - [#setDebug](#unavailableforlegalreasons-setdebug)
     - [#getCause](#unavailableforlegalreasons-getcause)
     - [#setCause](#unavailableforlegalreasons-setcause)
     - [#set](#unavailableforlegalreasons-set)
     - [#get](#unavailableforlegalreasons-get)
     - [#toJSON](#unavailableforlegalreasons-tojson)
     - [#toString](#unavailableforlegalreasons-tostring)
     - [#[Symbol.toStringTag]](#unavailableforlegalreasons-symboltostringtag)
   - [UnknownError](#unknownerror)
     - [#VERSION](#unknownerror-version)
     - [#code](#unknownerror-code)
     - [#status](#unknownerror-status)
     - [#message](#unknownerror-message)
     - [#getMessage](#unknownerror-getmessage)
     - [#setMessage](#unknownerror-setmessage)
     - [#getDebug](#unknownerror-getdebug)
     - [#setDebug](#unknownerror-setdebug)
     - [#getCause](#unknownerror-getcause)
     - [#setCause](#unknownerror-setcause)
     - [#set](#unknownerror-set)
     - [#get](#unknownerror-get)
     - [#toJSON](#unknownerror-tojson)
     - [#toString](#unknownerror-tostring)
     - [#[Symbol.toStringTag]](#unknownerror-symboltostringtag)
   - [UnprocessableEntity](#unprocessableentity)
     - [#VERSION](#unprocessableentity-version)
     - [#code](#unprocessableentity-code)
     - [#status](#unprocessableentity-status)
     - [#message](#unprocessableentity-message)
     - [#getMessage](#unprocessableentity-getmessage)
     - [#setMessage](#unprocessableentity-setmessage)
     - [#getDebug](#unprocessableentity-getdebug)
     - [#setDebug](#unprocessableentity-setdebug)
     - [#getCause](#unprocessableentity-getcause)
     - [#setCause](#unprocessableentity-setcause)
     - [#set](#unprocessableentity-set)
     - [#get](#unprocessableentity-get)
     - [#toJSON](#unprocessableentity-tojson)
     - [#toString](#unprocessableentity-tostring)
     - [#[Symbol.toStringTag]](#unprocessableentity-symboltostringtag)
   - [UnsupportedMediaType](#unsupportedmediatype)
     - [#VERSION](#unsupportedmediatype-version)
     - [#code](#unsupportedmediatype-code)
     - [#status](#unsupportedmediatype-status)
     - [#message](#unsupportedmediatype-message)
     - [#getMessage](#unsupportedmediatype-getmessage)
     - [#setMessage](#unsupportedmediatype-setmessage)
     - [#getDebug](#unsupportedmediatype-getdebug)
     - [#setDebug](#unsupportedmediatype-setdebug)
     - [#getCause](#unsupportedmediatype-getcause)
     - [#setCause](#unsupportedmediatype-setcause)
     - [#set](#unsupportedmediatype-set)
     - [#get](#unsupportedmediatype-get)
     - [#toJSON](#unsupportedmediatype-tojson)
     - [#toString](#unsupportedmediatype-tostring)
     - [#[Symbol.toStringTag]](#unsupportedmediatype-symboltostringtag)
   - [UpgradeRequired](#upgraderequired)
     - [#VERSION](#upgraderequired-version)
     - [#code](#upgraderequired-code)
     - [#status](#upgraderequired-status)
     - [#message](#upgraderequired-message)
     - [#getMessage](#upgraderequired-getmessage)
     - [#setMessage](#upgraderequired-setmessage)
     - [#getDebug](#upgraderequired-getdebug)
     - [#setDebug](#upgraderequired-setdebug)
     - [#getCause](#upgraderequired-getcause)
     - [#setCause](#upgraderequired-setcause)
     - [#set](#upgraderequired-set)
     - [#get](#upgraderequired-get)
     - [#toJSON](#upgraderequired-tojson)
     - [#toString](#upgraderequired-tostring)
     - [#[Symbol.toStringTag]](#upgraderequired-symboltostringtag)
   - [VariantAlsoNegotiates](#variantalsonegotiates)
     - [#VERSION](#variantalsonegotiates-version)
     - [#code](#variantalsonegotiates-code)
     - [#status](#variantalsonegotiates-status)
     - [#message](#variantalsonegotiates-message)
     - [#getMessage](#variantalsonegotiates-getmessage)
     - [#setMessage](#variantalsonegotiates-setmessage)
     - [#getDebug](#variantalsonegotiates-getdebug)
     - [#setDebug](#variantalsonegotiates-setdebug)
     - [#getCause](#variantalsonegotiates-getcause)
     - [#setCause](#variantalsonegotiates-setcause)
     - [#set](#variantalsonegotiates-set)
     - [#get](#variantalsonegotiates-get)
     - [#toJSON](#variantalsonegotiates-tojson)
     - [#toString](#variantalsonegotiates-tostring)
     - [#[Symbol.toStringTag]](#variantalsonegotiates-symboltostringtag)
   - [client](#client)
   - [index](#index)
   - [server](#server)
<a name=""></a>
 
<a name="badgateway"></a>
# BadGateway
should be a function.

```js
unit
  .function(BadGateway);
```

should return an instance of BadGateway.

```js
unit
  .object(new BadGateway())
  .isInstanceOf(BadGateway)
  .isEnumerable('code', 502)
  .isEnumerable('status', 'Bad Gateway')
  .isEnumerable('message', 'Sorry, It appears we received an error from another service that is needed to fulfill your request, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof BadGateway without the new operator.

```js
unit
  .object(BadGateway())
  .isInstanceOf(BadGateway)
  .isEnumerable('code', 502)
  .isEnumerable('status', 'Bad Gateway')
  .isEnumerable('message', 'Sorry, It appears we received an error from another service that is needed to fulfill your request, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="badgateway-version"></a>
## #VERSION
should be a constant property.

```js
const test = new BadGateway();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="badgateway-code"></a>
## #code
should be a constant property.

```js
const test = new BadGateway();
unit
  .number(test.code)
  .is(502);
```

<a name="badgateway-status"></a>
## #status
should be a constant property.

```js
const test = new BadGateway();
unit
  .string(test.status)
  .is('Bad Gateway');
```

<a name="badgateway-message"></a>
## #message
should have a default message.

```js
const test = new BadGateway();
unit
  .string(test.message)
  .is('Sorry, It appears we received an error from another service that is needed to fulfill your request, please try again later.');
```

should accept falsy as the default message.

```js
const test = new BadGateway();
unit
  .string(test.message)
  .is('Sorry, It appears we received an error from another service that is needed to fulfill your request, please try again later.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Sorry, It appears we received an error from another service that is needed to fulfill your request, please try again later.')
  .given(test.message = null)
  .string(test.message)
  .is('Sorry, It appears we received an error from another service that is needed to fulfill your request, please try again later.')
  .given(test.message = false)
  .string(test.message)
  .is('Sorry, It appears we received an error from another service that is needed to fulfill your request, please try again later.')
  .given(test.message = 0)
  .string(test.message)
  .is('Sorry, It appears we received an error from another service that is needed to fulfill your request, please try again later.')
  .given(test.message = '')
  .string(test.message)
  .is('Sorry, It appears we received an error from another service that is needed to fulfill your request, please try again later.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Sorry, It appears we received an error from another service that is needed to fulfill your request, please try again later.');
```

should accept a string.

```js
const test = new BadGateway();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Bad Gateway')
  .string(test.message)
  .is('Bad Gateway');
```

should accept stringifiable arrays.

```js
const test = new BadGateway();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new BadGateway();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new BadGateway();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="badgateway-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new BadGateway();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new BadGateway({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="badgateway-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new BadGateway();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new BadGateway();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(BadGateway)
  .hasProperty('message', 'Bad things.');
```

<a name="badgateway-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new BadGateway();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new BadGateway({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="badgateway-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new BadGateway();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new BadGateway();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(BadGateway)
  .hasProperty('debug', 'Something happened.');
```

<a name="badgateway-getcause"></a>
## #getCause
should be a function.

```js
const test = new BadGateway();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new BadGateway({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="badgateway-setcause"></a>
## #setCause
should be a function.

```js
const test = new BadGateway();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new BadGateway();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(BadGateway)
  .hasProperty('cause', cause);
```

<a name="badgateway-set"></a>
## #set
should be a function.

```js
const test = new BadGateway();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new BadGateway();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(BadGateway)
  .isEnumerable('code', 502)
  .isEnumerable('status', 'Bad Gateway')
  .isEnumerable('message', 'Sorry, It appears we received an error from another service that is needed to fulfill your request, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(BadGateway)
  .isEnumerable('code', 502)
  .isEnumerable('status', 'Bad Gateway')
  .isEnumerable('message', 'Sorry, It appears we received an error from another service that is needed to fulfill your request, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(BadGateway)
  .isEnumerable('code', 502)
  .isEnumerable('status', 'Bad Gateway')
  .isEnumerable('message', 'Sorry, It appears we received an error from another service that is needed to fulfill your request, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(BadGateway)
  .isEnumerable('code', 502)
  .isEnumerable('status', 'Bad Gateway')
  .isEnumerable('message', 'Sorry, It appears we received an error from another service that is needed to fulfill your request, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new BadGateway();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new BadGateway();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="badgateway-get"></a>
## #get
should be a function.

```js
const test = new BadGateway();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new BadGateway();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 502)
  .hasProperty('status', 'Bad Gateway')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 502)
  .hasProperty('status', 'Bad Gateway')
  .hasProperty('message', 'Sorry, It appears we received an error from another service that is needed to fulfill your request, please try again later.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new BadGateway();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 502)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 502)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="badgateway-tojson"></a>
## #toJSON
should be a function.

```js
const test = new BadGateway();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new BadGateway();
unit
  .object(test.toJSON())
  .hasProperty('code', 502)
  .hasProperty('status', 'Bad Gateway')
  .hasProperty('message', 'Sorry, It appears we received an error from another service that is needed to fulfill your request, please try again later.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 502)
  .hasProperty('status', 'Bad Gateway')
  .hasProperty('message', 'Sorry, It appears we received an error from another service that is needed to fulfill your request, please try again later.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="badgateway-tostring"></a>
## #toString
should be a function.

```js
const test = new BadGateway();
unit
  .function(test.toString);
```

should return BadGateway: 502 Bad Gateway.

```js
const test = new BadGateway();
unit
  .string(test.toString())
  .is('BadGateway: 502 Bad Gateway');
```

<a name="badgateway-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/badgateway".

```js
const test = new BadGateway();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/badgateway');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new BadGateway();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/badgateway]');
```

<a name="badrequest"></a>
# BadRequest
should be a function.

```js
unit
  .function(BadRequest);
```

should return an instance of BadRequest.

```js
unit
  .object(new BadRequest())
  .isInstanceOf(BadRequest)
  .isEnumerable('code', 400)
  .isEnumerable('status', 'Bad Request')
  .isEnumerable('message', 'Please, correct your request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof BadRequest without the new operator.

```js
unit
  .object(BadRequest())
  .isInstanceOf(BadRequest)
  .isEnumerable('code', 400)
  .isEnumerable('status', 'Bad Request')
  .isEnumerable('message', 'Please, correct your request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="badrequest-version"></a>
## #VERSION
should be a constant property.

```js
const test = new BadRequest();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="badrequest-code"></a>
## #code
should be a constant property.

```js
const test = new BadRequest();
unit
  .number(test.code)
  .is(400);
```

<a name="badrequest-status"></a>
## #status
should be a constant property.

```js
const test = new BadRequest();
unit
  .string(test.status)
  .is('Bad Request');
```

<a name="badrequest-message"></a>
## #message
should have a default message.

```js
const test = new BadRequest();
unit
  .string(test.message)
  .is('Please, correct your request and try again.');
```

should accept falsy as the default message.

```js
const test = new BadRequest();
unit
  .string(test.message)
  .is('Please, correct your request and try again.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Please, correct your request and try again.')
  .given(test.message = null)
  .string(test.message)
  .is('Please, correct your request and try again.')
  .given(test.message = false)
  .string(test.message)
  .is('Please, correct your request and try again.')
  .given(test.message = 0)
  .string(test.message)
  .is('Please, correct your request and try again.')
  .given(test.message = '')
  .string(test.message)
  .is('Please, correct your request and try again.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Please, correct your request and try again.');
```

should accept a string.

```js
const test = new BadRequest();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Bad Request')
  .string(test.message)
  .is('Bad Request');
```

should accept stringifiable arrays.

```js
const test = new BadRequest();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new BadRequest();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new BadRequest();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="badrequest-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new BadRequest();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new BadRequest({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="badrequest-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new BadRequest();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new BadRequest();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(BadRequest)
  .hasProperty('message', 'Bad things.');
```

<a name="badrequest-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new BadRequest();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new BadRequest({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="badrequest-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new BadRequest();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new BadRequest();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(BadRequest)
  .hasProperty('debug', 'Something happened.');
```

<a name="badrequest-getcause"></a>
## #getCause
should be a function.

```js
const test = new BadRequest();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new BadRequest({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="badrequest-setcause"></a>
## #setCause
should be a function.

```js
const test = new BadRequest();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new BadRequest();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(BadRequest)
  .hasProperty('cause', cause);
```

<a name="badrequest-set"></a>
## #set
should be a function.

```js
const test = new BadRequest();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new BadRequest();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(BadRequest)
  .isEnumerable('code', 400)
  .isEnumerable('status', 'Bad Request')
  .isEnumerable('message', 'Please, correct your request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(BadRequest)
  .isEnumerable('code', 400)
  .isEnumerable('status', 'Bad Request')
  .isEnumerable('message', 'Please, correct your request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(BadRequest)
  .isEnumerable('code', 400)
  .isEnumerable('status', 'Bad Request')
  .isEnumerable('message', 'Please, correct your request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(BadRequest)
  .isEnumerable('code', 400)
  .isEnumerable('status', 'Bad Request')
  .isEnumerable('message', 'Please, correct your request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new BadRequest();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new BadRequest();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="badrequest-get"></a>
## #get
should be a function.

```js
const test = new BadRequest();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new BadRequest();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 400)
  .hasProperty('status', 'Bad Request')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 400)
  .hasProperty('status', 'Bad Request')
  .hasProperty('message', 'Please, correct your request and try again.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new BadRequest();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 400)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 400)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="badrequest-tojson"></a>
## #toJSON
should be a function.

```js
const test = new BadRequest();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new BadRequest();
unit
  .object(test.toJSON())
  .hasProperty('code', 400)
  .hasProperty('status', 'Bad Request')
  .hasProperty('message', 'Please, correct your request and try again.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 400)
  .hasProperty('status', 'Bad Request')
  .hasProperty('message', 'Please, correct your request and try again.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="badrequest-tostring"></a>
## #toString
should be a function.

```js
const test = new BadRequest();
unit
  .function(test.toString);
```

should return BadRequest: 400 Bad Request.

```js
const test = new BadRequest();
unit
  .string(test.toString())
  .is('BadRequest: 400 Bad Request');
```

<a name="badrequest-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/badrequest".

```js
const test = new BadRequest();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/badrequest');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new BadRequest();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/badrequest]');
```

<a name="clienterror"></a>
# ClientError
should be a function.

```js
unit
  .function(ClientError);
```

should return a new BadRequest when given 400.

```js
unit
  .object(ClientError(400))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(BadRequest)
  .isEnumerable('code', 400)
  .isEnumerable('status', 'Bad Request')
  .isEnumerable('message', 'Please, correct your request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new BadRequest when given "Bad Request".

```js
unit
  .object(ClientError('Bad Request'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(BadRequest)
  .isEnumerable('code', 400)
  .isEnumerable('status', 'Bad Request')
  .isEnumerable('message', 'Please, correct your request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new BadRequest when given "BadRequest".

```js
unit
  .object(ClientError('BadRequest'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(BadRequest)
  .isEnumerable('code', 400)
  .isEnumerable('status', 'Bad Request')
  .isEnumerable('message', 'Please, correct your request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Unauthorized when given 401.

```js
unit
  .object(ClientError(401))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(Unauthorized)
  .isEnumerable('code', 401)
  .isEnumerable('status', 'Unauthorized')
  .isEnumerable('message', 'Please, authenticate and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Unauthorized when given "Unauthorized".

```js
unit
  .object(ClientError('Unauthorized'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(Unauthorized)
  .isEnumerable('code', 401)
  .isEnumerable('status', 'Unauthorized')
  .isEnumerable('message', 'Please, authenticate and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Unauthorized when given "Unauthorized".

```js
unit
  .object(ClientError('Unauthorized'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(Unauthorized)
  .isEnumerable('code', 401)
  .isEnumerable('status', 'Unauthorized')
  .isEnumerable('message', 'Please, authenticate and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new PaymentRequired when given 402.

```js
unit
  .object(ClientError(402))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(PaymentRequired)
  .isEnumerable('code', 402)
  .isEnumerable('status', 'Payment Required')
  .isEnumerable('message', 'Payment is required to use this service.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new PaymentRequired when given "Payment Required".

```js
unit
  .object(ClientError('Payment Required'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(PaymentRequired)
  .isEnumerable('code', 402)
  .isEnumerable('status', 'Payment Required')
  .isEnumerable('message', 'Payment is required to use this service.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new PaymentRequired when given "PaymentRequired".

```js
unit
  .object(ClientError('PaymentRequired'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(PaymentRequired)
  .isEnumerable('code', 402)
  .isEnumerable('status', 'Payment Required')
  .isEnumerable('message', 'Payment is required to use this service.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Forbidden when given 403.

```js
unit
  .object(ClientError(403))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(Forbidden)
  .isEnumerable('code', 403)
  .isEnumerable('status', 'Forbidden')
  .isEnumerable('message', 'You lack permission to preform this action.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Forbidden when given "Forbidden".

```js
unit
  .object(ClientError('Forbidden'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(Forbidden)
  .isEnumerable('code', 403)
  .isEnumerable('status', 'Forbidden')
  .isEnumerable('message', 'You lack permission to preform this action.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Forbidden when given "Forbidden".

```js
unit
  .object(ClientError('Forbidden'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(Forbidden)
  .isEnumerable('code', 403)
  .isEnumerable('status', 'Forbidden')
  .isEnumerable('message', 'You lack permission to preform this action.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NotFound when given 404.

```js
unit
  .object(ClientError(404))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(NotFound)
  .isEnumerable('code', 404)
  .isEnumerable('status', 'Not Found')
  .isEnumerable('message', 'The requested document was not found.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NotFound when given "Not Found".

```js
unit
  .object(ClientError('Not Found'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(NotFound)
  .isEnumerable('code', 404)
  .isEnumerable('status', 'Not Found')
  .isEnumerable('message', 'The requested document was not found.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NotFound when given "NotFound".

```js
unit
  .object(ClientError('NotFound'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(NotFound)
  .isEnumerable('code', 404)
  .isEnumerable('status', 'Not Found')
  .isEnumerable('message', 'The requested document was not found.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new MethodNotAllowed when given 405.

```js
unit
  .object(ClientError(405))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(MethodNotAllowed)
  .isEnumerable('code', 405)
  .isEnumerable('status', 'Method Not Allowed')
  .isEnumerable('message', 'Please, check your request method and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new MethodNotAllowed when given "Method Not Allowed".

```js
unit
  .object(ClientError('Method Not Allowed'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(MethodNotAllowed)
  .isEnumerable('code', 405)
  .isEnumerable('status', 'Method Not Allowed')
  .isEnumerable('message', 'Please, check your request method and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new MethodNotAllowed when given "MethodNotAllowed".

```js
unit
  .object(ClientError('MethodNotAllowed'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(MethodNotAllowed)
  .isEnumerable('code', 405)
  .isEnumerable('status', 'Method Not Allowed')
  .isEnumerable('message', 'Please, check your request method and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NotAcceptable when given 406.

```js
unit
  .object(ClientError(406))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(NotAcceptable)
  .isEnumerable('code', 406)
  .isEnumerable('status', 'Not Acceptable')
  .isEnumerable('message', 'The requested document format is not supported.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NotAcceptable when given "Not Acceptable".

```js
unit
  .object(ClientError('Not Acceptable'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(NotAcceptable)
  .isEnumerable('code', 406)
  .isEnumerable('status', 'Not Acceptable')
  .isEnumerable('message', 'The requested document format is not supported.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NotAcceptable when given "NotAcceptable".

```js
unit
  .object(ClientError('NotAcceptable'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(NotAcceptable)
  .isEnumerable('code', 406)
  .isEnumerable('status', 'Not Acceptable')
  .isEnumerable('message', 'The requested document format is not supported.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new ProxyAuthenticationRequired when given 407.

```js
unit
  .object(ClientError(407))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(ProxyAuthenticationRequired)
  .isEnumerable('code', 407)
  .isEnumerable('status', 'Proxy Authentication Required')
  .isEnumerable('message', 'Please, authenticate with the proxy server and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new ProxyAuthenticationRequired when given "Proxy Authentication Required".

```js
unit
  .object(ClientError('Proxy Authentication Required'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(ProxyAuthenticationRequired)
  .isEnumerable('code', 407)
  .isEnumerable('status', 'Proxy Authentication Required')
  .isEnumerable('message', 'Please, authenticate with the proxy server and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new ProxyAuthenticationRequired when given "ProxyAuthenticationRequired".

```js
unit
  .object(ClientError('ProxyAuthenticationRequired'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(ProxyAuthenticationRequired)
  .isEnumerable('code', 407)
  .isEnumerable('status', 'Proxy Authentication Required')
  .isEnumerable('message', 'Please, authenticate with the proxy server and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new RequestTimeout when given 408.

```js
unit
  .object(ClientError(408))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(RequestTimeout)
  .isEnumerable('code', 408)
  .isEnumerable('status', 'Request Timeout')
  .isEnumerable('message', 'Sorry, it appears we are on break, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new RequestTimeout when given "Request Timeout".

```js
unit
  .object(ClientError('Request Timeout'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(RequestTimeout)
  .isEnumerable('code', 408)
  .isEnumerable('status', 'Request Timeout')
  .isEnumerable('message', 'Sorry, it appears we are on break, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new RequestTimeout when given "RequestTimeout".

```js
unit
  .object(ClientError('RequestTimeout'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(RequestTimeout)
  .isEnumerable('code', 408)
  .isEnumerable('status', 'Request Timeout')
  .isEnumerable('message', 'Sorry, it appears we are on break, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Conflict when given 409.

```js
unit
  .object(ClientError(409))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(Conflict)
  .isEnumerable('code', 409)
  .isEnumerable('status', 'Conflict')
  .isEnumerable('message', 'Houston, we have a conflict, please reload the resource and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Conflict when given "Conflict".

```js
unit
  .object(ClientError('Conflict'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(Conflict)
  .isEnumerable('code', 409)
  .isEnumerable('status', 'Conflict')
  .isEnumerable('message', 'Houston, we have a conflict, please reload the resource and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Conflict when given "Conflict".

```js
unit
  .object(ClientError('Conflict'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(Conflict)
  .isEnumerable('code', 409)
  .isEnumerable('status', 'Conflict')
  .isEnumerable('message', 'Houston, we have a conflict, please reload the resource and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Gone when given 410.

```js
unit
  .object(ClientError(410))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(Gone)
  .isEnumerable('code', 410)
  .isEnumerable('status', 'Gone')
  .isEnumerable('message', 'Sorry, but that resource has been removed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Gone when given "Gone".

```js
unit
  .object(ClientError('Gone'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(Gone)
  .isEnumerable('code', 410)
  .isEnumerable('status', 'Gone')
  .isEnumerable('message', 'Sorry, but that resource has been removed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Gone when given "Gone".

```js
unit
  .object(ClientError('Gone'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(Gone)
  .isEnumerable('code', 410)
  .isEnumerable('status', 'Gone')
  .isEnumerable('message', 'Sorry, but that resource has been removed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new LengthRequired when given 411.

```js
unit
  .object(ClientError(411))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(LengthRequired)
  .isEnumerable('code', 411)
  .isEnumerable('status', 'Length Required')
  .isEnumerable('message', 'Please, correct the Length header and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new LengthRequired when given "Length Required".

```js
unit
  .object(ClientError('Length Required'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(LengthRequired)
  .isEnumerable('code', 411)
  .isEnumerable('status', 'Length Required')
  .isEnumerable('message', 'Please, correct the Length header and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new LengthRequired when given "LengthRequired".

```js
unit
  .object(ClientError('LengthRequired'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(LengthRequired)
  .isEnumerable('code', 411)
  .isEnumerable('status', 'Length Required')
  .isEnumerable('message', 'Please, correct the Length header and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new PreconditionFailed when given 412.

```js
unit
  .object(ClientError(412))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(PreconditionFailed)
  .isEnumerable('code', 412)
  .isEnumerable('status', 'Precondition Failed')
  .isEnumerable('message', 'Sorry, it appears 1 or more preconditions on the request have changed, please correct and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new PreconditionFailed when given "Precondition Failed".

```js
unit
  .object(ClientError('Precondition Failed'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(PreconditionFailed)
  .isEnumerable('code', 412)
  .isEnumerable('status', 'Precondition Failed')
  .isEnumerable('message', 'Sorry, it appears 1 or more preconditions on the request have changed, please correct and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new PreconditionFailed when given "PreconditionFailed".

```js
unit
  .object(ClientError('PreconditionFailed'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(PreconditionFailed)
  .isEnumerable('code', 412)
  .isEnumerable('status', 'Precondition Failed')
  .isEnumerable('message', 'Sorry, it appears 1 or more preconditions on the request have changed, please correct and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new PayloadTooLarge when given 413.

```js
unit
  .object(ClientError(413))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(PayloadTooLarge)
  .isEnumerable('code', 413)
  .isEnumerable('status', 'Payload Too Large')
  .isEnumerable('message', 'Request payload is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new PayloadTooLarge when given "Payload Too Large".

```js
unit
  .object(ClientError('Payload Too Large'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(PayloadTooLarge)
  .isEnumerable('code', 413)
  .isEnumerable('status', 'Payload Too Large')
  .isEnumerable('message', 'Request payload is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new PayloadTooLarge when given "PayloadTooLarge".

```js
unit
  .object(ClientError('PayloadTooLarge'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(PayloadTooLarge)
  .isEnumerable('code', 413)
  .isEnumerable('status', 'Payload Too Large')
  .isEnumerable('message', 'Request payload is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new URITooLong when given 414.

```js
unit
  .object(ClientError(414))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(URITooLong)
  .isEnumerable('code', 414)
  .isEnumerable('status', 'URI Too Long')
  .isEnumerable('message', 'Request uri is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new URITooLong when given "URI Too Long".

```js
unit
  .object(ClientError('URI Too Long'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(URITooLong)
  .isEnumerable('code', 414)
  .isEnumerable('status', 'URI Too Long')
  .isEnumerable('message', 'Request uri is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new URITooLong when given "URITooLong".

```js
unit
  .object(ClientError('URITooLong'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(URITooLong)
  .isEnumerable('code', 414)
  .isEnumerable('status', 'URI Too Long')
  .isEnumerable('message', 'Request uri is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UnsupportedMediaType when given 415.

```js
unit
  .object(ClientError(415))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(UnsupportedMediaType)
  .isEnumerable('code', 415)
  .isEnumerable('status', 'Unsupported Media Type')
  .isEnumerable('message', 'Please, try again with a different media format.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UnsupportedMediaType when given "Unsupported Media Type".

```js
unit
  .object(ClientError('Unsupported Media Type'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(UnsupportedMediaType)
  .isEnumerable('code', 415)
  .isEnumerable('status', 'Unsupported Media Type')
  .isEnumerable('message', 'Please, try again with a different media format.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UnsupportedMediaType when given "UnsupportedMediaType".

```js
unit
  .object(ClientError('UnsupportedMediaType'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(UnsupportedMediaType)
  .isEnumerable('code', 415)
  .isEnumerable('status', 'Unsupported Media Type')
  .isEnumerable('message', 'Please, try again with a different media format.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new RangeNotSatisfiable when given 416.

```js
unit
  .object(ClientError(416))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(RangeNotSatisfiable)
  .isEnumerable('code', 416)
  .isEnumerable('status', 'Range Not Satisfiable')
  .isEnumerable('message', 'Requested range is not satisfiable, please check Range and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new RangeNotSatisfiable when given "Range Not Satisfiable".

```js
unit
  .object(ClientError('Range Not Satisfiable'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(RangeNotSatisfiable)
  .isEnumerable('code', 416)
  .isEnumerable('status', 'Range Not Satisfiable')
  .isEnumerable('message', 'Requested range is not satisfiable, please check Range and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new RangeNotSatisfiable when given "RangeNotSatisfiable".

```js
unit
  .object(ClientError('RangeNotSatisfiable'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(RangeNotSatisfiable)
  .isEnumerable('code', 416)
  .isEnumerable('status', 'Range Not Satisfiable')
  .isEnumerable('message', 'Requested range is not satisfiable, please check Range and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new ExpectationFailed when given 417.

```js
unit
  .object(ClientError(417))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(ExpectationFailed)
  .isEnumerable('code', 417)
  .isEnumerable('status', 'Expectation Failed')
  .isEnumerable('message', 'Sorry, your expectation can not be meet, please check Expect and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new ExpectationFailed when given "Expectation Failed".

```js
unit
  .object(ClientError('Expectation Failed'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(ExpectationFailed)
  .isEnumerable('code', 417)
  .isEnumerable('status', 'Expectation Failed')
  .isEnumerable('message', 'Sorry, your expectation can not be meet, please check Expect and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new ExpectationFailed when given "ExpectationFailed".

```js
unit
  .object(ClientError('ExpectationFailed'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(ExpectationFailed)
  .isEnumerable('code', 417)
  .isEnumerable('status', 'Expectation Failed')
  .isEnumerable('message', 'Sorry, your expectation can not be meet, please check Expect and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new IMATeapot when given 418.

```js
unit
  .object(ClientError(418))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(IMATeapot)
  .isEnumerable('code', 418)
  .isEnumerable('status', 'I\'m a teapot')
  .isEnumerable('message', 'Tip me over, and pour me out.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new IMATeapot when given "I'm a teapot".

```js
unit
  .object(ClientError('I\'m a teapot'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(IMATeapot)
  .isEnumerable('code', 418)
  .isEnumerable('status', 'I\'m a teapot')
  .isEnumerable('message', 'Tip me over, and pour me out.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new IMATeapot when given "IMATeapot".

```js
unit
  .object(ClientError('IMATeapot'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(IMATeapot)
  .isEnumerable('code', 418)
  .isEnumerable('status', 'I\'m a teapot')
  .isEnumerable('message', 'Tip me over, and pour me out.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new MisdirectedRequest when given 421.

```js
unit
  .object(ClientError(421))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(MisdirectedRequest)
  .isEnumerable('code', 421)
  .isEnumerable('status', 'Misdirected Request')
  .isEnumerable('message', 'Sorry, we got misdirected, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new MisdirectedRequest when given "Misdirected Request".

```js
unit
  .object(ClientError('Misdirected Request'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(MisdirectedRequest)
  .isEnumerable('code', 421)
  .isEnumerable('status', 'Misdirected Request')
  .isEnumerable('message', 'Sorry, we got misdirected, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new MisdirectedRequest when given "MisdirectedRequest".

```js
unit
  .object(ClientError('MisdirectedRequest'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(MisdirectedRequest)
  .isEnumerable('code', 421)
  .isEnumerable('status', 'Misdirected Request')
  .isEnumerable('message', 'Sorry, we got misdirected, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UnprocessableEntity when given 422.

```js
unit
  .object(ClientError(422))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(UnprocessableEntity)
  .isEnumerable('code', 422)
  .isEnumerable('status', 'Unprocessable Entity')
  .isEnumerable('message', 'Sorry, it appears your document instructions are semantically erroneous.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UnprocessableEntity when given "Unprocessable Entity".

```js
unit
  .object(ClientError('Unprocessable Entity'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(UnprocessableEntity)
  .isEnumerable('code', 422)
  .isEnumerable('status', 'Unprocessable Entity')
  .isEnumerable('message', 'Sorry, it appears your document instructions are semantically erroneous.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UnprocessableEntity when given "UnprocessableEntity".

```js
unit
  .object(ClientError('UnprocessableEntity'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(UnprocessableEntity)
  .isEnumerable('code', 422)
  .isEnumerable('status', 'Unprocessable Entity')
  .isEnumerable('message', 'Sorry, it appears your document instructions are semantically erroneous.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Locked when given 423.

```js
unit
  .object(ClientError(423))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(Locked)
  .isEnumerable('code', 423)
  .isEnumerable('status', 'Locked')
  .isEnumerable('message', 'Document is currently locked, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Locked when given "Locked".

```js
unit
  .object(ClientError('Locked'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(Locked)
  .isEnumerable('code', 423)
  .isEnumerable('status', 'Locked')
  .isEnumerable('message', 'Document is currently locked, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Locked when given "Locked".

```js
unit
  .object(ClientError('Locked'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(Locked)
  .isEnumerable('code', 423)
  .isEnumerable('status', 'Locked')
  .isEnumerable('message', 'Document is currently locked, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new FailedDependency when given 424.

```js
unit
  .object(ClientError(424))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(FailedDependency)
  .isEnumerable('code', 424)
  .isEnumerable('status', 'Failed Dependency')
  .isEnumerable('message', 'Sorry, it appears a dependent request has failed please retry previous dependent request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new FailedDependency when given "Failed Dependency".

```js
unit
  .object(ClientError('Failed Dependency'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(FailedDependency)
  .isEnumerable('code', 424)
  .isEnumerable('status', 'Failed Dependency')
  .isEnumerable('message', 'Sorry, it appears a dependent request has failed please retry previous dependent request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new FailedDependency when given "FailedDependency".

```js
unit
  .object(ClientError('FailedDependency'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(FailedDependency)
  .isEnumerable('code', 424)
  .isEnumerable('status', 'Failed Dependency')
  .isEnumerable('message', 'Sorry, it appears a dependent request has failed please retry previous dependent request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UpgradeRequired when given 426.

```js
unit
  .object(ClientError(426))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(UpgradeRequired)
  .isEnumerable('code', 426)
  .isEnumerable('status', 'Upgrade Required')
  .isEnumerable('message', 'Please, upgrade and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UpgradeRequired when given "Upgrade Required".

```js
unit
  .object(ClientError('Upgrade Required'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(UpgradeRequired)
  .isEnumerable('code', 426)
  .isEnumerable('status', 'Upgrade Required')
  .isEnumerable('message', 'Please, upgrade and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UpgradeRequired when given "UpgradeRequired".

```js
unit
  .object(ClientError('UpgradeRequired'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(UpgradeRequired)
  .isEnumerable('code', 426)
  .isEnumerable('status', 'Upgrade Required')
  .isEnumerable('message', 'Please, upgrade and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new PreconditionRequired when given 428.

```js
unit
  .object(ClientError(428))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(PreconditionRequired)
  .isEnumerable('code', 428)
  .isEnumerable('status', 'Precondition Required')
  .isEnumerable('message', 'Please, add preconditions to your request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new PreconditionRequired when given "Precondition Required".

```js
unit
  .object(ClientError('Precondition Required'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(PreconditionRequired)
  .isEnumerable('code', 428)
  .isEnumerable('status', 'Precondition Required')
  .isEnumerable('message', 'Please, add preconditions to your request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new PreconditionRequired when given "PreconditionRequired".

```js
unit
  .object(ClientError('PreconditionRequired'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(PreconditionRequired)
  .isEnumerable('code', 428)
  .isEnumerable('status', 'Precondition Required')
  .isEnumerable('message', 'Please, add preconditions to your request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new TooManyRequests when given 429.

```js
unit
  .object(ClientError(429))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(TooManyRequests)
  .isEnumerable('code', 429)
  .isEnumerable('status', 'Too Many Requests')
  .isEnumerable('message', 'Sorry, you have exceeded your rate limit, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new TooManyRequests when given "Too Many Requests".

```js
unit
  .object(ClientError('Too Many Requests'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(TooManyRequests)
  .isEnumerable('code', 429)
  .isEnumerable('status', 'Too Many Requests')
  .isEnumerable('message', 'Sorry, you have exceeded your rate limit, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new TooManyRequests when given "TooManyRequests".

```js
unit
  .object(ClientError('TooManyRequests'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(TooManyRequests)
  .isEnumerable('code', 429)
  .isEnumerable('status', 'Too Many Requests')
  .isEnumerable('message', 'Sorry, you have exceeded your rate limit, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new RequestHeaderFieldsTooLarge when given 431.

```js
unit
  .object(ClientError(431))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(RequestHeaderFieldsTooLarge)
  .isEnumerable('code', 431)
  .isEnumerable('status', 'Request Header Fields Too Large')
  .isEnumerable('message', 'Request header is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new RequestHeaderFieldsTooLarge when given "Request Header Fields Too Large".

```js
unit
  .object(ClientError('Request Header Fields Too Large'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(RequestHeaderFieldsTooLarge)
  .isEnumerable('code', 431)
  .isEnumerable('status', 'Request Header Fields Too Large')
  .isEnumerable('message', 'Request header is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new RequestHeaderFieldsTooLarge when given "RequestHeaderFieldsTooLarge".

```js
unit
  .object(ClientError('RequestHeaderFieldsTooLarge'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(RequestHeaderFieldsTooLarge)
  .isEnumerable('code', 431)
  .isEnumerable('status', 'Request Header Fields Too Large')
  .isEnumerable('message', 'Request header is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UnavailableForLegalReasons when given 451.

```js
unit
  .object(ClientError(451))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(UnavailableForLegalReasons)
  .isEnumerable('code', 451)
  .isEnumerable('status', 'Unavailable For Legal Reasons')
  .isEnumerable('message', 'Due to legal reasons this resource has been removed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UnavailableForLegalReasons when given "Unavailable For Legal Reasons".

```js
unit
  .object(ClientError('Unavailable For Legal Reasons'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(UnavailableForLegalReasons)
  .isEnumerable('code', 451)
  .isEnumerable('status', 'Unavailable For Legal Reasons')
  .isEnumerable('message', 'Due to legal reasons this resource has been removed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UnavailableForLegalReasons when given "UnavailableForLegalReasons".

```js
unit
  .object(ClientError('UnavailableForLegalReasons'))
  .isInstanceOf(Error)
  .isInstanceOf(ClientError)
  .isInstanceOf(UnavailableForLegalReasons)
  .isEnumerable('code', 451)
  .isEnumerable('status', 'Unavailable For Legal Reasons')
  .isEnumerable('message', 'Due to legal reasons this resource has been removed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

<a name="conflict"></a>
# Conflict
should be a function.

```js
unit
  .function(Conflict);
```

should return an instance of Conflict.

```js
unit
  .object(new Conflict())
  .isInstanceOf(Conflict)
  .isEnumerable('code', 409)
  .isEnumerable('status', 'Conflict')
  .isEnumerable('message', 'Houston, we have a conflict, please reload the resource and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof Conflict without the new operator.

```js
unit
  .object(Conflict())
  .isInstanceOf(Conflict)
  .isEnumerable('code', 409)
  .isEnumerable('status', 'Conflict')
  .isEnumerable('message', 'Houston, we have a conflict, please reload the resource and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="conflict-version"></a>
## #VERSION
should be a constant property.

```js
const test = new Conflict();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="conflict-code"></a>
## #code
should be a constant property.

```js
const test = new Conflict();
unit
  .number(test.code)
  .is(409);
```

<a name="conflict-status"></a>
## #status
should be a constant property.

```js
const test = new Conflict();
unit
  .string(test.status)
  .is('Conflict');
```

<a name="conflict-message"></a>
## #message
should have a default message.

```js
const test = new Conflict();
unit
  .string(test.message)
  .is('Houston, we have a conflict, please reload the resource and try again.');
```

should accept falsy as the default message.

```js
const test = new Conflict();
unit
  .string(test.message)
  .is('Houston, we have a conflict, please reload the resource and try again.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Houston, we have a conflict, please reload the resource and try again.')
  .given(test.message = null)
  .string(test.message)
  .is('Houston, we have a conflict, please reload the resource and try again.')
  .given(test.message = false)
  .string(test.message)
  .is('Houston, we have a conflict, please reload the resource and try again.')
  .given(test.message = 0)
  .string(test.message)
  .is('Houston, we have a conflict, please reload the resource and try again.')
  .given(test.message = '')
  .string(test.message)
  .is('Houston, we have a conflict, please reload the resource and try again.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Houston, we have a conflict, please reload the resource and try again.');
```

should accept a string.

```js
const test = new Conflict();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Conflict')
  .string(test.message)
  .is('Conflict');
```

should accept stringifiable arrays.

```js
const test = new Conflict();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new Conflict();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new Conflict();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="conflict-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new Conflict();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new Conflict({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="conflict-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new Conflict();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new Conflict();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(Conflict)
  .hasProperty('message', 'Bad things.');
```

<a name="conflict-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new Conflict();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new Conflict({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="conflict-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new Conflict();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new Conflict();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(Conflict)
  .hasProperty('debug', 'Something happened.');
```

<a name="conflict-getcause"></a>
## #getCause
should be a function.

```js
const test = new Conflict();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new Conflict({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="conflict-setcause"></a>
## #setCause
should be a function.

```js
const test = new Conflict();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new Conflict();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(Conflict)
  .hasProperty('cause', cause);
```

<a name="conflict-set"></a>
## #set
should be a function.

```js
const test = new Conflict();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new Conflict();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(Conflict)
  .isEnumerable('code', 409)
  .isEnumerable('status', 'Conflict')
  .isEnumerable('message', 'Houston, we have a conflict, please reload the resource and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(Conflict)
  .isEnumerable('code', 409)
  .isEnumerable('status', 'Conflict')
  .isEnumerable('message', 'Houston, we have a conflict, please reload the resource and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(Conflict)
  .isEnumerable('code', 409)
  .isEnumerable('status', 'Conflict')
  .isEnumerable('message', 'Houston, we have a conflict, please reload the resource and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(Conflict)
  .isEnumerable('code', 409)
  .isEnumerable('status', 'Conflict')
  .isEnumerable('message', 'Houston, we have a conflict, please reload the resource and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new Conflict();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new Conflict();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="conflict-get"></a>
## #get
should be a function.

```js
const test = new Conflict();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new Conflict();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 409)
  .hasProperty('status', 'Conflict')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 409)
  .hasProperty('status', 'Conflict')
  .hasProperty('message', 'Houston, we have a conflict, please reload the resource and try again.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new Conflict();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 409)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 409)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="conflict-tojson"></a>
## #toJSON
should be a function.

```js
const test = new Conflict();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new Conflict();
unit
  .object(test.toJSON())
  .hasProperty('code', 409)
  .hasProperty('status', 'Conflict')
  .hasProperty('message', 'Houston, we have a conflict, please reload the resource and try again.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 409)
  .hasProperty('status', 'Conflict')
  .hasProperty('message', 'Houston, we have a conflict, please reload the resource and try again.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="conflict-tostring"></a>
## #toString
should be a function.

```js
const test = new Conflict();
unit
  .function(test.toString);
```

should return Conflict: 409 Conflict.

```js
const test = new Conflict();
unit
  .string(test.toString())
  .is('Conflict: 409 Conflict');
```

<a name="conflict-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/conflict".

```js
const test = new Conflict();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/conflict');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new Conflict();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/conflict]');
```

<a name="expectationfailed"></a>
# ExpectationFailed
should be a function.

```js
unit
  .function(ExpectationFailed);
```

should return an instance of ExpectationFailed.

```js
unit
  .object(new ExpectationFailed())
  .isInstanceOf(ExpectationFailed)
  .isEnumerable('code', 417)
  .isEnumerable('status', 'Expectation Failed')
  .isEnumerable('message', 'Sorry, your expectation can not be meet, please check Expect and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof ExpectationFailed without the new operator.

```js
unit
  .object(ExpectationFailed())
  .isInstanceOf(ExpectationFailed)
  .isEnumerable('code', 417)
  .isEnumerable('status', 'Expectation Failed')
  .isEnumerable('message', 'Sorry, your expectation can not be meet, please check Expect and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="expectationfailed-version"></a>
## #VERSION
should be a constant property.

```js
const test = new ExpectationFailed();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="expectationfailed-code"></a>
## #code
should be a constant property.

```js
const test = new ExpectationFailed();
unit
  .number(test.code)
  .is(417);
```

<a name="expectationfailed-status"></a>
## #status
should be a constant property.

```js
const test = new ExpectationFailed();
unit
  .string(test.status)
  .is('Expectation Failed');
```

<a name="expectationfailed-message"></a>
## #message
should have a default message.

```js
const test = new ExpectationFailed();
unit
  .string(test.message)
  .is('Sorry, your expectation can not be meet, please check Expect and try again.');
```

should accept falsy as the default message.

```js
const test = new ExpectationFailed();
unit
  .string(test.message)
  .is('Sorry, your expectation can not be meet, please check Expect and try again.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Sorry, your expectation can not be meet, please check Expect and try again.')
  .given(test.message = null)
  .string(test.message)
  .is('Sorry, your expectation can not be meet, please check Expect and try again.')
  .given(test.message = false)
  .string(test.message)
  .is('Sorry, your expectation can not be meet, please check Expect and try again.')
  .given(test.message = 0)
  .string(test.message)
  .is('Sorry, your expectation can not be meet, please check Expect and try again.')
  .given(test.message = '')
  .string(test.message)
  .is('Sorry, your expectation can not be meet, please check Expect and try again.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Sorry, your expectation can not be meet, please check Expect and try again.');
```

should accept a string.

```js
const test = new ExpectationFailed();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Expectation Failed')
  .string(test.message)
  .is('Expectation Failed');
```

should accept stringifiable arrays.

```js
const test = new ExpectationFailed();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new ExpectationFailed();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new ExpectationFailed();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="expectationfailed-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new ExpectationFailed();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new ExpectationFailed({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="expectationfailed-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new ExpectationFailed();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new ExpectationFailed();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(ExpectationFailed)
  .hasProperty('message', 'Bad things.');
```

<a name="expectationfailed-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new ExpectationFailed();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new ExpectationFailed({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="expectationfailed-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new ExpectationFailed();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new ExpectationFailed();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(ExpectationFailed)
  .hasProperty('debug', 'Something happened.');
```

<a name="expectationfailed-getcause"></a>
## #getCause
should be a function.

```js
const test = new ExpectationFailed();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new ExpectationFailed({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="expectationfailed-setcause"></a>
## #setCause
should be a function.

```js
const test = new ExpectationFailed();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new ExpectationFailed();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(ExpectationFailed)
  .hasProperty('cause', cause);
```

<a name="expectationfailed-set"></a>
## #set
should be a function.

```js
const test = new ExpectationFailed();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new ExpectationFailed();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(ExpectationFailed)
  .isEnumerable('code', 417)
  .isEnumerable('status', 'Expectation Failed')
  .isEnumerable('message', 'Sorry, your expectation can not be meet, please check Expect and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(ExpectationFailed)
  .isEnumerable('code', 417)
  .isEnumerable('status', 'Expectation Failed')
  .isEnumerable('message', 'Sorry, your expectation can not be meet, please check Expect and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(ExpectationFailed)
  .isEnumerable('code', 417)
  .isEnumerable('status', 'Expectation Failed')
  .isEnumerable('message', 'Sorry, your expectation can not be meet, please check Expect and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(ExpectationFailed)
  .isEnumerable('code', 417)
  .isEnumerable('status', 'Expectation Failed')
  .isEnumerable('message', 'Sorry, your expectation can not be meet, please check Expect and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new ExpectationFailed();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new ExpectationFailed();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="expectationfailed-get"></a>
## #get
should be a function.

```js
const test = new ExpectationFailed();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new ExpectationFailed();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 417)
  .hasProperty('status', 'Expectation Failed')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 417)
  .hasProperty('status', 'Expectation Failed')
  .hasProperty('message', 'Sorry, your expectation can not be meet, please check Expect and try again.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new ExpectationFailed();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 417)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 417)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="expectationfailed-tojson"></a>
## #toJSON
should be a function.

```js
const test = new ExpectationFailed();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new ExpectationFailed();
unit
  .object(test.toJSON())
  .hasProperty('code', 417)
  .hasProperty('status', 'Expectation Failed')
  .hasProperty('message', 'Sorry, your expectation can not be meet, please check Expect and try again.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 417)
  .hasProperty('status', 'Expectation Failed')
  .hasProperty('message', 'Sorry, your expectation can not be meet, please check Expect and try again.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="expectationfailed-tostring"></a>
## #toString
should be a function.

```js
const test = new ExpectationFailed();
unit
  .function(test.toString);
```

should return ExpectationFailed: 417 Expectation Failed.

```js
const test = new ExpectationFailed();
unit
  .string(test.toString())
  .is('ExpectationFailed: 417 Expectation Failed');
```

<a name="expectationfailed-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/expectationfailed".

```js
const test = new ExpectationFailed();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/expectationfailed');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new ExpectationFailed();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/expectationfailed]');
```

<a name="faileddependency"></a>
# FailedDependency
should be a function.

```js
unit
  .function(FailedDependency);
```

should return an instance of FailedDependency.

```js
unit
  .object(new FailedDependency())
  .isInstanceOf(FailedDependency)
  .isEnumerable('code', 424)
  .isEnumerable('status', 'Failed Dependency')
  .isEnumerable('message', 'Sorry, it appears a dependent request has failed please retry previous dependent request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof FailedDependency without the new operator.

```js
unit
  .object(FailedDependency())
  .isInstanceOf(FailedDependency)
  .isEnumerable('code', 424)
  .isEnumerable('status', 'Failed Dependency')
  .isEnumerable('message', 'Sorry, it appears a dependent request has failed please retry previous dependent request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="faileddependency-version"></a>
## #VERSION
should be a constant property.

```js
const test = new FailedDependency();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="faileddependency-code"></a>
## #code
should be a constant property.

```js
const test = new FailedDependency();
unit
  .number(test.code)
  .is(424);
```

<a name="faileddependency-status"></a>
## #status
should be a constant property.

```js
const test = new FailedDependency();
unit
  .string(test.status)
  .is('Failed Dependency');
```

<a name="faileddependency-message"></a>
## #message
should have a default message.

```js
const test = new FailedDependency();
unit
  .string(test.message)
  .is('Sorry, it appears a dependent request has failed please retry previous dependent request and try again.');
```

should accept falsy as the default message.

```js
const test = new FailedDependency();
unit
  .string(test.message)
  .is('Sorry, it appears a dependent request has failed please retry previous dependent request and try again.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Sorry, it appears a dependent request has failed please retry previous dependent request and try again.')
  .given(test.message = null)
  .string(test.message)
  .is('Sorry, it appears a dependent request has failed please retry previous dependent request and try again.')
  .given(test.message = false)
  .string(test.message)
  .is('Sorry, it appears a dependent request has failed please retry previous dependent request and try again.')
  .given(test.message = 0)
  .string(test.message)
  .is('Sorry, it appears a dependent request has failed please retry previous dependent request and try again.')
  .given(test.message = '')
  .string(test.message)
  .is('Sorry, it appears a dependent request has failed please retry previous dependent request and try again.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Sorry, it appears a dependent request has failed please retry previous dependent request and try again.');
```

should accept a string.

```js
const test = new FailedDependency();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Failed Dependency')
  .string(test.message)
  .is('Failed Dependency');
```

should accept stringifiable arrays.

```js
const test = new FailedDependency();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new FailedDependency();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new FailedDependency();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="faileddependency-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new FailedDependency();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new FailedDependency({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="faileddependency-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new FailedDependency();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new FailedDependency();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(FailedDependency)
  .hasProperty('message', 'Bad things.');
```

<a name="faileddependency-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new FailedDependency();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new FailedDependency({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="faileddependency-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new FailedDependency();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new FailedDependency();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(FailedDependency)
  .hasProperty('debug', 'Something happened.');
```

<a name="faileddependency-getcause"></a>
## #getCause
should be a function.

```js
const test = new FailedDependency();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new FailedDependency({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="faileddependency-setcause"></a>
## #setCause
should be a function.

```js
const test = new FailedDependency();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new FailedDependency();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(FailedDependency)
  .hasProperty('cause', cause);
```

<a name="faileddependency-set"></a>
## #set
should be a function.

```js
const test = new FailedDependency();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new FailedDependency();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(FailedDependency)
  .isEnumerable('code', 424)
  .isEnumerable('status', 'Failed Dependency')
  .isEnumerable('message', 'Sorry, it appears a dependent request has failed please retry previous dependent request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(FailedDependency)
  .isEnumerable('code', 424)
  .isEnumerable('status', 'Failed Dependency')
  .isEnumerable('message', 'Sorry, it appears a dependent request has failed please retry previous dependent request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(FailedDependency)
  .isEnumerable('code', 424)
  .isEnumerable('status', 'Failed Dependency')
  .isEnumerable('message', 'Sorry, it appears a dependent request has failed please retry previous dependent request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(FailedDependency)
  .isEnumerable('code', 424)
  .isEnumerable('status', 'Failed Dependency')
  .isEnumerable('message', 'Sorry, it appears a dependent request has failed please retry previous dependent request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new FailedDependency();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new FailedDependency();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="faileddependency-get"></a>
## #get
should be a function.

```js
const test = new FailedDependency();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new FailedDependency();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 424)
  .hasProperty('status', 'Failed Dependency')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 424)
  .hasProperty('status', 'Failed Dependency')
  .hasProperty('message', 'Sorry, it appears a dependent request has failed please retry previous dependent request and try again.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new FailedDependency();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 424)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 424)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="faileddependency-tojson"></a>
## #toJSON
should be a function.

```js
const test = new FailedDependency();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new FailedDependency();
unit
  .object(test.toJSON())
  .hasProperty('code', 424)
  .hasProperty('status', 'Failed Dependency')
  .hasProperty('message', 'Sorry, it appears a dependent request has failed please retry previous dependent request and try again.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 424)
  .hasProperty('status', 'Failed Dependency')
  .hasProperty('message', 'Sorry, it appears a dependent request has failed please retry previous dependent request and try again.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="faileddependency-tostring"></a>
## #toString
should be a function.

```js
const test = new FailedDependency();
unit
  .function(test.toString);
```

should return FailedDependency: 424 Failed Dependency.

```js
const test = new FailedDependency();
unit
  .string(test.toString())
  .is('FailedDependency: 424 Failed Dependency');
```

<a name="faileddependency-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/faileddependency".

```js
const test = new FailedDependency();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/faileddependency');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new FailedDependency();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/faileddependency]');
```

<a name="forbidden"></a>
# Forbidden
should be a function.

```js
unit
  .function(Forbidden);
```

should return an instance of Forbidden.

```js
unit
  .object(new Forbidden())
  .isInstanceOf(Forbidden)
  .isEnumerable('code', 403)
  .isEnumerable('status', 'Forbidden')
  .isEnumerable('message', 'You lack permission to preform this action.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof Forbidden without the new operator.

```js
unit
  .object(Forbidden())
  .isInstanceOf(Forbidden)
  .isEnumerable('code', 403)
  .isEnumerable('status', 'Forbidden')
  .isEnumerable('message', 'You lack permission to preform this action.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="forbidden-version"></a>
## #VERSION
should be a constant property.

```js
const test = new Forbidden();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="forbidden-code"></a>
## #code
should be a constant property.

```js
const test = new Forbidden();
unit
  .number(test.code)
  .is(403);
```

<a name="forbidden-status"></a>
## #status
should be a constant property.

```js
const test = new Forbidden();
unit
  .string(test.status)
  .is('Forbidden');
```

<a name="forbidden-message"></a>
## #message
should have a default message.

```js
const test = new Forbidden();
unit
  .string(test.message)
  .is('You lack permission to preform this action.');
```

should accept falsy as the default message.

```js
const test = new Forbidden();
unit
  .string(test.message)
  .is('You lack permission to preform this action.')
  .given(test.message = undefined)
  .string(test.message)
  .is('You lack permission to preform this action.')
  .given(test.message = null)
  .string(test.message)
  .is('You lack permission to preform this action.')
  .given(test.message = false)
  .string(test.message)
  .is('You lack permission to preform this action.')
  .given(test.message = 0)
  .string(test.message)
  .is('You lack permission to preform this action.')
  .given(test.message = '')
  .string(test.message)
  .is('You lack permission to preform this action.')
  .given(test.message = '     ')
  .string(test.message)
  .is('You lack permission to preform this action.');
```

should accept a string.

```js
const test = new Forbidden();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Forbidden')
  .string(test.message)
  .is('Forbidden');
```

should accept stringifiable arrays.

```js
const test = new Forbidden();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new Forbidden();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new Forbidden();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="forbidden-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new Forbidden();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new Forbidden({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="forbidden-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new Forbidden();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new Forbidden();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(Forbidden)
  .hasProperty('message', 'Bad things.');
```

<a name="forbidden-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new Forbidden();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new Forbidden({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="forbidden-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new Forbidden();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new Forbidden();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(Forbidden)
  .hasProperty('debug', 'Something happened.');
```

<a name="forbidden-getcause"></a>
## #getCause
should be a function.

```js
const test = new Forbidden();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new Forbidden({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="forbidden-setcause"></a>
## #setCause
should be a function.

```js
const test = new Forbidden();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new Forbidden();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(Forbidden)
  .hasProperty('cause', cause);
```

<a name="forbidden-set"></a>
## #set
should be a function.

```js
const test = new Forbidden();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new Forbidden();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(Forbidden)
  .isEnumerable('code', 403)
  .isEnumerable('status', 'Forbidden')
  .isEnumerable('message', 'You lack permission to preform this action.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(Forbidden)
  .isEnumerable('code', 403)
  .isEnumerable('status', 'Forbidden')
  .isEnumerable('message', 'You lack permission to preform this action.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(Forbidden)
  .isEnumerable('code', 403)
  .isEnumerable('status', 'Forbidden')
  .isEnumerable('message', 'You lack permission to preform this action.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(Forbidden)
  .isEnumerable('code', 403)
  .isEnumerable('status', 'Forbidden')
  .isEnumerable('message', 'You lack permission to preform this action.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new Forbidden();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new Forbidden();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="forbidden-get"></a>
## #get
should be a function.

```js
const test = new Forbidden();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new Forbidden();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 403)
  .hasProperty('status', 'Forbidden')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 403)
  .hasProperty('status', 'Forbidden')
  .hasProperty('message', 'You lack permission to preform this action.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new Forbidden();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 403)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 403)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="forbidden-tojson"></a>
## #toJSON
should be a function.

```js
const test = new Forbidden();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new Forbidden();
unit
  .object(test.toJSON())
  .hasProperty('code', 403)
  .hasProperty('status', 'Forbidden')
  .hasProperty('message', 'You lack permission to preform this action.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 403)
  .hasProperty('status', 'Forbidden')
  .hasProperty('message', 'You lack permission to preform this action.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="forbidden-tostring"></a>
## #toString
should be a function.

```js
const test = new Forbidden();
unit
  .function(test.toString);
```

should return Forbidden: 403 Forbidden.

```js
const test = new Forbidden();
unit
  .string(test.toString())
  .is('Forbidden: 403 Forbidden');
```

<a name="forbidden-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/forbidden".

```js
const test = new Forbidden();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/forbidden');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new Forbidden();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/forbidden]');
```

<a name="gatewaytimeout"></a>
# GatewayTimeout
should be a function.

```js
unit
  .function(GatewayTimeout);
```

should return an instance of GatewayTimeout.

```js
unit
  .object(new GatewayTimeout())
  .isInstanceOf(GatewayTimeout)
  .isEnumerable('code', 504)
  .isEnumerable('status', 'Gateway Timeout')
  .isEnumerable('message', 'Sorry, it appears another service is taking to long and we cannot wait any longer.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof GatewayTimeout without the new operator.

```js
unit
  .object(GatewayTimeout())
  .isInstanceOf(GatewayTimeout)
  .isEnumerable('code', 504)
  .isEnumerable('status', 'Gateway Timeout')
  .isEnumerable('message', 'Sorry, it appears another service is taking to long and we cannot wait any longer.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="gatewaytimeout-version"></a>
## #VERSION
should be a constant property.

```js
const test = new GatewayTimeout();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="gatewaytimeout-code"></a>
## #code
should be a constant property.

```js
const test = new GatewayTimeout();
unit
  .number(test.code)
  .is(504);
```

<a name="gatewaytimeout-status"></a>
## #status
should be a constant property.

```js
const test = new GatewayTimeout();
unit
  .string(test.status)
  .is('Gateway Timeout');
```

<a name="gatewaytimeout-message"></a>
## #message
should have a default message.

```js
const test = new GatewayTimeout();
unit
  .string(test.message)
  .is('Sorry, it appears another service is taking to long and we cannot wait any longer.');
```

should accept falsy as the default message.

```js
const test = new GatewayTimeout();
unit
  .string(test.message)
  .is('Sorry, it appears another service is taking to long and we cannot wait any longer.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Sorry, it appears another service is taking to long and we cannot wait any longer.')
  .given(test.message = null)
  .string(test.message)
  .is('Sorry, it appears another service is taking to long and we cannot wait any longer.')
  .given(test.message = false)
  .string(test.message)
  .is('Sorry, it appears another service is taking to long and we cannot wait any longer.')
  .given(test.message = 0)
  .string(test.message)
  .is('Sorry, it appears another service is taking to long and we cannot wait any longer.')
  .given(test.message = '')
  .string(test.message)
  .is('Sorry, it appears another service is taking to long and we cannot wait any longer.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Sorry, it appears another service is taking to long and we cannot wait any longer.');
```

should accept a string.

```js
const test = new GatewayTimeout();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Gateway Timeout')
  .string(test.message)
  .is('Gateway Timeout');
```

should accept stringifiable arrays.

```js
const test = new GatewayTimeout();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new GatewayTimeout();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new GatewayTimeout();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="gatewaytimeout-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new GatewayTimeout();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new GatewayTimeout({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="gatewaytimeout-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new GatewayTimeout();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new GatewayTimeout();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(GatewayTimeout)
  .hasProperty('message', 'Bad things.');
```

<a name="gatewaytimeout-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new GatewayTimeout();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new GatewayTimeout({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="gatewaytimeout-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new GatewayTimeout();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new GatewayTimeout();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(GatewayTimeout)
  .hasProperty('debug', 'Something happened.');
```

<a name="gatewaytimeout-getcause"></a>
## #getCause
should be a function.

```js
const test = new GatewayTimeout();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new GatewayTimeout({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="gatewaytimeout-setcause"></a>
## #setCause
should be a function.

```js
const test = new GatewayTimeout();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new GatewayTimeout();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(GatewayTimeout)
  .hasProperty('cause', cause);
```

<a name="gatewaytimeout-set"></a>
## #set
should be a function.

```js
const test = new GatewayTimeout();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new GatewayTimeout();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(GatewayTimeout)
  .isEnumerable('code', 504)
  .isEnumerable('status', 'Gateway Timeout')
  .isEnumerable('message', 'Sorry, it appears another service is taking to long and we cannot wait any longer.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(GatewayTimeout)
  .isEnumerable('code', 504)
  .isEnumerable('status', 'Gateway Timeout')
  .isEnumerable('message', 'Sorry, it appears another service is taking to long and we cannot wait any longer.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(GatewayTimeout)
  .isEnumerable('code', 504)
  .isEnumerable('status', 'Gateway Timeout')
  .isEnumerable('message', 'Sorry, it appears another service is taking to long and we cannot wait any longer.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(GatewayTimeout)
  .isEnumerable('code', 504)
  .isEnumerable('status', 'Gateway Timeout')
  .isEnumerable('message', 'Sorry, it appears another service is taking to long and we cannot wait any longer.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new GatewayTimeout();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new GatewayTimeout();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="gatewaytimeout-get"></a>
## #get
should be a function.

```js
const test = new GatewayTimeout();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new GatewayTimeout();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 504)
  .hasProperty('status', 'Gateway Timeout')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 504)
  .hasProperty('status', 'Gateway Timeout')
  .hasProperty('message', 'Sorry, it appears another service is taking to long and we cannot wait any longer.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new GatewayTimeout();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 504)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 504)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="gatewaytimeout-tojson"></a>
## #toJSON
should be a function.

```js
const test = new GatewayTimeout();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new GatewayTimeout();
unit
  .object(test.toJSON())
  .hasProperty('code', 504)
  .hasProperty('status', 'Gateway Timeout')
  .hasProperty('message', 'Sorry, it appears another service is taking to long and we cannot wait any longer.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 504)
  .hasProperty('status', 'Gateway Timeout')
  .hasProperty('message', 'Sorry, it appears another service is taking to long and we cannot wait any longer.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="gatewaytimeout-tostring"></a>
## #toString
should be a function.

```js
const test = new GatewayTimeout();
unit
  .function(test.toString);
```

should return GatewayTimeout: 504 Gateway Timeout.

```js
const test = new GatewayTimeout();
unit
  .string(test.toString())
  .is('GatewayTimeout: 504 Gateway Timeout');
```

<a name="gatewaytimeout-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/gatewaytimeout".

```js
const test = new GatewayTimeout();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/gatewaytimeout');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new GatewayTimeout();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/gatewaytimeout]');
```

<a name="gone"></a>
# Gone
should be a function.

```js
unit
  .function(Gone);
```

should return an instance of Gone.

```js
unit
  .object(new Gone())
  .isInstanceOf(Gone)
  .isEnumerable('code', 410)
  .isEnumerable('status', 'Gone')
  .isEnumerable('message', 'Sorry, but that resource has been removed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof Gone without the new operator.

```js
unit
  .object(Gone())
  .isInstanceOf(Gone)
  .isEnumerable('code', 410)
  .isEnumerable('status', 'Gone')
  .isEnumerable('message', 'Sorry, but that resource has been removed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="gone-version"></a>
## #VERSION
should be a constant property.

```js
const test = new Gone();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="gone-code"></a>
## #code
should be a constant property.

```js
const test = new Gone();
unit
  .number(test.code)
  .is(410);
```

<a name="gone-status"></a>
## #status
should be a constant property.

```js
const test = new Gone();
unit
  .string(test.status)
  .is('Gone');
```

<a name="gone-message"></a>
## #message
should have a default message.

```js
const test = new Gone();
unit
  .string(test.message)
  .is('Sorry, but that resource has been removed.');
```

should accept falsy as the default message.

```js
const test = new Gone();
unit
  .string(test.message)
  .is('Sorry, but that resource has been removed.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Sorry, but that resource has been removed.')
  .given(test.message = null)
  .string(test.message)
  .is('Sorry, but that resource has been removed.')
  .given(test.message = false)
  .string(test.message)
  .is('Sorry, but that resource has been removed.')
  .given(test.message = 0)
  .string(test.message)
  .is('Sorry, but that resource has been removed.')
  .given(test.message = '')
  .string(test.message)
  .is('Sorry, but that resource has been removed.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Sorry, but that resource has been removed.');
```

should accept a string.

```js
const test = new Gone();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Gone')
  .string(test.message)
  .is('Gone');
```

should accept stringifiable arrays.

```js
const test = new Gone();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new Gone();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new Gone();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="gone-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new Gone();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new Gone({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="gone-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new Gone();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new Gone();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(Gone)
  .hasProperty('message', 'Bad things.');
```

<a name="gone-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new Gone();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new Gone({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="gone-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new Gone();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new Gone();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(Gone)
  .hasProperty('debug', 'Something happened.');
```

<a name="gone-getcause"></a>
## #getCause
should be a function.

```js
const test = new Gone();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new Gone({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="gone-setcause"></a>
## #setCause
should be a function.

```js
const test = new Gone();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new Gone();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(Gone)
  .hasProperty('cause', cause);
```

<a name="gone-set"></a>
## #set
should be a function.

```js
const test = new Gone();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new Gone();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(Gone)
  .isEnumerable('code', 410)
  .isEnumerable('status', 'Gone')
  .isEnumerable('message', 'Sorry, but that resource has been removed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(Gone)
  .isEnumerable('code', 410)
  .isEnumerable('status', 'Gone')
  .isEnumerable('message', 'Sorry, but that resource has been removed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(Gone)
  .isEnumerable('code', 410)
  .isEnumerable('status', 'Gone')
  .isEnumerable('message', 'Sorry, but that resource has been removed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(Gone)
  .isEnumerable('code', 410)
  .isEnumerable('status', 'Gone')
  .isEnumerable('message', 'Sorry, but that resource has been removed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new Gone();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new Gone();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="gone-get"></a>
## #get
should be a function.

```js
const test = new Gone();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new Gone();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 410)
  .hasProperty('status', 'Gone')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 410)
  .hasProperty('status', 'Gone')
  .hasProperty('message', 'Sorry, but that resource has been removed.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new Gone();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 410)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 410)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="gone-tojson"></a>
## #toJSON
should be a function.

```js
const test = new Gone();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new Gone();
unit
  .object(test.toJSON())
  .hasProperty('code', 410)
  .hasProperty('status', 'Gone')
  .hasProperty('message', 'Sorry, but that resource has been removed.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 410)
  .hasProperty('status', 'Gone')
  .hasProperty('message', 'Sorry, but that resource has been removed.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="gone-tostring"></a>
## #toString
should be a function.

```js
const test = new Gone();
unit
  .function(test.toString);
```

should return Gone: 410 Gone.

```js
const test = new Gone();
unit
  .string(test.toString())
  .is('Gone: 410 Gone');
```

<a name="gone-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/gone".

```js
const test = new Gone();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/gone');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new Gone();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/gone]');
```

<a name="httpversionnotsupported"></a>
# HTTPVersionNotSupported
should be a function.

```js
unit
  .function(HTTPVersionNotSupported);
```

should return an instance of HTTPVersionNotSupported.

```js
unit
  .object(new HTTPVersionNotSupported())
  .isInstanceOf(HTTPVersionNotSupported)
  .isEnumerable('code', 505)
  .isEnumerable('status', 'HTTP Version Not Supported')
  .isEnumerable('message', 'Please, try a diffrent protocol version and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof HTTPVersionNotSupported without the new operator.

```js
unit
  .object(HTTPVersionNotSupported())
  .isInstanceOf(HTTPVersionNotSupported)
  .isEnumerable('code', 505)
  .isEnumerable('status', 'HTTP Version Not Supported')
  .isEnumerable('message', 'Please, try a diffrent protocol version and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="httpversionnotsupported-version"></a>
## #VERSION
should be a constant property.

```js
const test = new HTTPVersionNotSupported();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="httpversionnotsupported-code"></a>
## #code
should be a constant property.

```js
const test = new HTTPVersionNotSupported();
unit
  .number(test.code)
  .is(505);
```

<a name="httpversionnotsupported-status"></a>
## #status
should be a constant property.

```js
const test = new HTTPVersionNotSupported();
unit
  .string(test.status)
  .is('HTTP Version Not Supported');
```

<a name="httpversionnotsupported-message"></a>
## #message
should have a default message.

```js
const test = new HTTPVersionNotSupported();
unit
  .string(test.message)
  .is('Please, try a diffrent protocol version and try again.');
```

should accept falsy as the default message.

```js
const test = new HTTPVersionNotSupported();
unit
  .string(test.message)
  .is('Please, try a diffrent protocol version and try again.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Please, try a diffrent protocol version and try again.')
  .given(test.message = null)
  .string(test.message)
  .is('Please, try a diffrent protocol version and try again.')
  .given(test.message = false)
  .string(test.message)
  .is('Please, try a diffrent protocol version and try again.')
  .given(test.message = 0)
  .string(test.message)
  .is('Please, try a diffrent protocol version and try again.')
  .given(test.message = '')
  .string(test.message)
  .is('Please, try a diffrent protocol version and try again.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Please, try a diffrent protocol version and try again.');
```

should accept a string.

```js
const test = new HTTPVersionNotSupported();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'HTTP Version Not Supported')
  .string(test.message)
  .is('HTTP Version Not Supported');
```

should accept stringifiable arrays.

```js
const test = new HTTPVersionNotSupported();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new HTTPVersionNotSupported();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new HTTPVersionNotSupported();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="httpversionnotsupported-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new HTTPVersionNotSupported();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new HTTPVersionNotSupported({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="httpversionnotsupported-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new HTTPVersionNotSupported();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new HTTPVersionNotSupported();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(HTTPVersionNotSupported)
  .hasProperty('message', 'Bad things.');
```

<a name="httpversionnotsupported-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new HTTPVersionNotSupported();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new HTTPVersionNotSupported({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="httpversionnotsupported-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new HTTPVersionNotSupported();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new HTTPVersionNotSupported();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(HTTPVersionNotSupported)
  .hasProperty('debug', 'Something happened.');
```

<a name="httpversionnotsupported-getcause"></a>
## #getCause
should be a function.

```js
const test = new HTTPVersionNotSupported();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new HTTPVersionNotSupported({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="httpversionnotsupported-setcause"></a>
## #setCause
should be a function.

```js
const test = new HTTPVersionNotSupported();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new HTTPVersionNotSupported();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(HTTPVersionNotSupported)
  .hasProperty('cause', cause);
```

<a name="httpversionnotsupported-set"></a>
## #set
should be a function.

```js
const test = new HTTPVersionNotSupported();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new HTTPVersionNotSupported();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(HTTPVersionNotSupported)
  .isEnumerable('code', 505)
  .isEnumerable('status', 'HTTP Version Not Supported')
  .isEnumerable('message', 'Please, try a diffrent protocol version and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(HTTPVersionNotSupported)
  .isEnumerable('code', 505)
  .isEnumerable('status', 'HTTP Version Not Supported')
  .isEnumerable('message', 'Please, try a diffrent protocol version and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(HTTPVersionNotSupported)
  .isEnumerable('code', 505)
  .isEnumerable('status', 'HTTP Version Not Supported')
  .isEnumerable('message', 'Please, try a diffrent protocol version and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(HTTPVersionNotSupported)
  .isEnumerable('code', 505)
  .isEnumerable('status', 'HTTP Version Not Supported')
  .isEnumerable('message', 'Please, try a diffrent protocol version and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new HTTPVersionNotSupported();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new HTTPVersionNotSupported();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="httpversionnotsupported-get"></a>
## #get
should be a function.

```js
const test = new HTTPVersionNotSupported();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new HTTPVersionNotSupported();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 505)
  .hasProperty('status', 'HTTP Version Not Supported')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 505)
  .hasProperty('status', 'HTTP Version Not Supported')
  .hasProperty('message', 'Please, try a diffrent protocol version and try again.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new HTTPVersionNotSupported();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 505)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 505)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="httpversionnotsupported-tojson"></a>
## #toJSON
should be a function.

```js
const test = new HTTPVersionNotSupported();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new HTTPVersionNotSupported();
unit
  .object(test.toJSON())
  .hasProperty('code', 505)
  .hasProperty('status', 'HTTP Version Not Supported')
  .hasProperty('message', 'Please, try a diffrent protocol version and try again.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 505)
  .hasProperty('status', 'HTTP Version Not Supported')
  .hasProperty('message', 'Please, try a diffrent protocol version and try again.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="httpversionnotsupported-tostring"></a>
## #toString
should be a function.

```js
const test = new HTTPVersionNotSupported();
unit
  .function(test.toString);
```

should return HTTPVersionNotSupported: 505 HTTP Version Not Supported.

```js
const test = new HTTPVersionNotSupported();
unit
  .string(test.toString())
  .is('HTTPVersionNotSupported: 505 HTTP Version Not Supported');
```

<a name="httpversionnotsupported-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/httpversionnotsupported".

```js
const test = new HTTPVersionNotSupported();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/httpversionnotsupported');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new HTTPVersionNotSupported();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/httpversionnotsupported]');
```

<a name="httperror"></a>
# HttpError
should be a function.

```js
unit
  .function(HttpError);
```

should return a new BadRequest when given 400.

```js
unit
  .object(HttpError(400))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(BadRequest)
  .isEnumerable('code', 400)
  .isEnumerable('status', 'Bad Request')
  .isEnumerable('message', 'Please, correct your request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new BadRequest when given "Bad Request".

```js
unit
  .object(HttpError('Bad Request'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(BadRequest)
  .isEnumerable('code', 400)
  .isEnumerable('status', 'Bad Request')
  .isEnumerable('message', 'Please, correct your request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new BadRequest when given "BadRequest".

```js
unit
  .object(HttpError('BadRequest'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(BadRequest)
  .isEnumerable('code', 400)
  .isEnumerable('status', 'Bad Request')
  .isEnumerable('message', 'Please, correct your request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Unauthorized when given 401.

```js
unit
  .object(HttpError(401))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(Unauthorized)
  .isEnumerable('code', 401)
  .isEnumerable('status', 'Unauthorized')
  .isEnumerable('message', 'Please, authenticate and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Unauthorized when given "Unauthorized".

```js
unit
  .object(HttpError('Unauthorized'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(Unauthorized)
  .isEnumerable('code', 401)
  .isEnumerable('status', 'Unauthorized')
  .isEnumerable('message', 'Please, authenticate and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Unauthorized when given "Unauthorized".

```js
unit
  .object(HttpError('Unauthorized'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(Unauthorized)
  .isEnumerable('code', 401)
  .isEnumerable('status', 'Unauthorized')
  .isEnumerable('message', 'Please, authenticate and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new PaymentRequired when given 402.

```js
unit
  .object(HttpError(402))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(PaymentRequired)
  .isEnumerable('code', 402)
  .isEnumerable('status', 'Payment Required')
  .isEnumerable('message', 'Payment is required to use this service.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new PaymentRequired when given "Payment Required".

```js
unit
  .object(HttpError('Payment Required'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(PaymentRequired)
  .isEnumerable('code', 402)
  .isEnumerable('status', 'Payment Required')
  .isEnumerable('message', 'Payment is required to use this service.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new PaymentRequired when given "PaymentRequired".

```js
unit
  .object(HttpError('PaymentRequired'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(PaymentRequired)
  .isEnumerable('code', 402)
  .isEnumerable('status', 'Payment Required')
  .isEnumerable('message', 'Payment is required to use this service.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Forbidden when given 403.

```js
unit
  .object(HttpError(403))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(Forbidden)
  .isEnumerable('code', 403)
  .isEnumerable('status', 'Forbidden')
  .isEnumerable('message', 'You lack permission to preform this action.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Forbidden when given "Forbidden".

```js
unit
  .object(HttpError('Forbidden'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(Forbidden)
  .isEnumerable('code', 403)
  .isEnumerable('status', 'Forbidden')
  .isEnumerable('message', 'You lack permission to preform this action.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Forbidden when given "Forbidden".

```js
unit
  .object(HttpError('Forbidden'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(Forbidden)
  .isEnumerable('code', 403)
  .isEnumerable('status', 'Forbidden')
  .isEnumerable('message', 'You lack permission to preform this action.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NotFound when given 404.

```js
unit
  .object(HttpError(404))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(NotFound)
  .isEnumerable('code', 404)
  .isEnumerable('status', 'Not Found')
  .isEnumerable('message', 'The requested document was not found.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NotFound when given "Not Found".

```js
unit
  .object(HttpError('Not Found'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(NotFound)
  .isEnumerable('code', 404)
  .isEnumerable('status', 'Not Found')
  .isEnumerable('message', 'The requested document was not found.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NotFound when given "NotFound".

```js
unit
  .object(HttpError('NotFound'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(NotFound)
  .isEnumerable('code', 404)
  .isEnumerable('status', 'Not Found')
  .isEnumerable('message', 'The requested document was not found.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new MethodNotAllowed when given 405.

```js
unit
  .object(HttpError(405))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(MethodNotAllowed)
  .isEnumerable('code', 405)
  .isEnumerable('status', 'Method Not Allowed')
  .isEnumerable('message', 'Please, check your request method and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new MethodNotAllowed when given "Method Not Allowed".

```js
unit
  .object(HttpError('Method Not Allowed'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(MethodNotAllowed)
  .isEnumerable('code', 405)
  .isEnumerable('status', 'Method Not Allowed')
  .isEnumerable('message', 'Please, check your request method and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new MethodNotAllowed when given "MethodNotAllowed".

```js
unit
  .object(HttpError('MethodNotAllowed'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(MethodNotAllowed)
  .isEnumerable('code', 405)
  .isEnumerable('status', 'Method Not Allowed')
  .isEnumerable('message', 'Please, check your request method and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NotAcceptable when given 406.

```js
unit
  .object(HttpError(406))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(NotAcceptable)
  .isEnumerable('code', 406)
  .isEnumerable('status', 'Not Acceptable')
  .isEnumerable('message', 'The requested document format is not supported.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NotAcceptable when given "Not Acceptable".

```js
unit
  .object(HttpError('Not Acceptable'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(NotAcceptable)
  .isEnumerable('code', 406)
  .isEnumerable('status', 'Not Acceptable')
  .isEnumerable('message', 'The requested document format is not supported.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NotAcceptable when given "NotAcceptable".

```js
unit
  .object(HttpError('NotAcceptable'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(NotAcceptable)
  .isEnumerable('code', 406)
  .isEnumerable('status', 'Not Acceptable')
  .isEnumerable('message', 'The requested document format is not supported.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new ProxyAuthenticationRequired when given 407.

```js
unit
  .object(HttpError(407))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(ProxyAuthenticationRequired)
  .isEnumerable('code', 407)
  .isEnumerable('status', 'Proxy Authentication Required')
  .isEnumerable('message', 'Please, authenticate with the proxy server and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new ProxyAuthenticationRequired when given "Proxy Authentication Required".

```js
unit
  .object(HttpError('Proxy Authentication Required'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(ProxyAuthenticationRequired)
  .isEnumerable('code', 407)
  .isEnumerable('status', 'Proxy Authentication Required')
  .isEnumerable('message', 'Please, authenticate with the proxy server and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new ProxyAuthenticationRequired when given "ProxyAuthenticationRequired".

```js
unit
  .object(HttpError('ProxyAuthenticationRequired'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(ProxyAuthenticationRequired)
  .isEnumerable('code', 407)
  .isEnumerable('status', 'Proxy Authentication Required')
  .isEnumerable('message', 'Please, authenticate with the proxy server and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new RequestTimeout when given 408.

```js
unit
  .object(HttpError(408))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(RequestTimeout)
  .isEnumerable('code', 408)
  .isEnumerable('status', 'Request Timeout')
  .isEnumerable('message', 'Sorry, it appears we are on break, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new RequestTimeout when given "Request Timeout".

```js
unit
  .object(HttpError('Request Timeout'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(RequestTimeout)
  .isEnumerable('code', 408)
  .isEnumerable('status', 'Request Timeout')
  .isEnumerable('message', 'Sorry, it appears we are on break, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new RequestTimeout when given "RequestTimeout".

```js
unit
  .object(HttpError('RequestTimeout'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(RequestTimeout)
  .isEnumerable('code', 408)
  .isEnumerable('status', 'Request Timeout')
  .isEnumerable('message', 'Sorry, it appears we are on break, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Conflict when given 409.

```js
unit
  .object(HttpError(409))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(Conflict)
  .isEnumerable('code', 409)
  .isEnumerable('status', 'Conflict')
  .isEnumerable('message', 'Houston, we have a conflict, please reload the resource and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Conflict when given "Conflict".

```js
unit
  .object(HttpError('Conflict'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(Conflict)
  .isEnumerable('code', 409)
  .isEnumerable('status', 'Conflict')
  .isEnumerable('message', 'Houston, we have a conflict, please reload the resource and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Conflict when given "Conflict".

```js
unit
  .object(HttpError('Conflict'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(Conflict)
  .isEnumerable('code', 409)
  .isEnumerable('status', 'Conflict')
  .isEnumerable('message', 'Houston, we have a conflict, please reload the resource and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Gone when given 410.

```js
unit
  .object(HttpError(410))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(Gone)
  .isEnumerable('code', 410)
  .isEnumerable('status', 'Gone')
  .isEnumerable('message', 'Sorry, but that resource has been removed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Gone when given "Gone".

```js
unit
  .object(HttpError('Gone'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(Gone)
  .isEnumerable('code', 410)
  .isEnumerable('status', 'Gone')
  .isEnumerable('message', 'Sorry, but that resource has been removed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Gone when given "Gone".

```js
unit
  .object(HttpError('Gone'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(Gone)
  .isEnumerable('code', 410)
  .isEnumerable('status', 'Gone')
  .isEnumerable('message', 'Sorry, but that resource has been removed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new LengthRequired when given 411.

```js
unit
  .object(HttpError(411))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(LengthRequired)
  .isEnumerable('code', 411)
  .isEnumerable('status', 'Length Required')
  .isEnumerable('message', 'Please, correct the Length header and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new LengthRequired when given "Length Required".

```js
unit
  .object(HttpError('Length Required'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(LengthRequired)
  .isEnumerable('code', 411)
  .isEnumerable('status', 'Length Required')
  .isEnumerable('message', 'Please, correct the Length header and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new LengthRequired when given "LengthRequired".

```js
unit
  .object(HttpError('LengthRequired'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(LengthRequired)
  .isEnumerable('code', 411)
  .isEnumerable('status', 'Length Required')
  .isEnumerable('message', 'Please, correct the Length header and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new PreconditionFailed when given 412.

```js
unit
  .object(HttpError(412))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(PreconditionFailed)
  .isEnumerable('code', 412)
  .isEnumerable('status', 'Precondition Failed')
  .isEnumerable('message', 'Sorry, it appears 1 or more preconditions on the request have changed, please correct and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new PreconditionFailed when given "Precondition Failed".

```js
unit
  .object(HttpError('Precondition Failed'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(PreconditionFailed)
  .isEnumerable('code', 412)
  .isEnumerable('status', 'Precondition Failed')
  .isEnumerable('message', 'Sorry, it appears 1 or more preconditions on the request have changed, please correct and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new PreconditionFailed when given "PreconditionFailed".

```js
unit
  .object(HttpError('PreconditionFailed'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(PreconditionFailed)
  .isEnumerable('code', 412)
  .isEnumerable('status', 'Precondition Failed')
  .isEnumerable('message', 'Sorry, it appears 1 or more preconditions on the request have changed, please correct and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new PayloadTooLarge when given 413.

```js
unit
  .object(HttpError(413))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(PayloadTooLarge)
  .isEnumerable('code', 413)
  .isEnumerable('status', 'Payload Too Large')
  .isEnumerable('message', 'Request payload is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new PayloadTooLarge when given "Payload Too Large".

```js
unit
  .object(HttpError('Payload Too Large'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(PayloadTooLarge)
  .isEnumerable('code', 413)
  .isEnumerable('status', 'Payload Too Large')
  .isEnumerable('message', 'Request payload is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new PayloadTooLarge when given "PayloadTooLarge".

```js
unit
  .object(HttpError('PayloadTooLarge'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(PayloadTooLarge)
  .isEnumerable('code', 413)
  .isEnumerable('status', 'Payload Too Large')
  .isEnumerable('message', 'Request payload is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new URITooLong when given 414.

```js
unit
  .object(HttpError(414))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(URITooLong)
  .isEnumerable('code', 414)
  .isEnumerable('status', 'URI Too Long')
  .isEnumerable('message', 'Request uri is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new URITooLong when given "URI Too Long".

```js
unit
  .object(HttpError('URI Too Long'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(URITooLong)
  .isEnumerable('code', 414)
  .isEnumerable('status', 'URI Too Long')
  .isEnumerable('message', 'Request uri is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new URITooLong when given "URITooLong".

```js
unit
  .object(HttpError('URITooLong'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(URITooLong)
  .isEnumerable('code', 414)
  .isEnumerable('status', 'URI Too Long')
  .isEnumerable('message', 'Request uri is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UnsupportedMediaType when given 415.

```js
unit
  .object(HttpError(415))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(UnsupportedMediaType)
  .isEnumerable('code', 415)
  .isEnumerable('status', 'Unsupported Media Type')
  .isEnumerable('message', 'Please, try again with a different media format.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UnsupportedMediaType when given "Unsupported Media Type".

```js
unit
  .object(HttpError('Unsupported Media Type'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(UnsupportedMediaType)
  .isEnumerable('code', 415)
  .isEnumerable('status', 'Unsupported Media Type')
  .isEnumerable('message', 'Please, try again with a different media format.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UnsupportedMediaType when given "UnsupportedMediaType".

```js
unit
  .object(HttpError('UnsupportedMediaType'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(UnsupportedMediaType)
  .isEnumerable('code', 415)
  .isEnumerable('status', 'Unsupported Media Type')
  .isEnumerable('message', 'Please, try again with a different media format.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new RangeNotSatisfiable when given 416.

```js
unit
  .object(HttpError(416))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(RangeNotSatisfiable)
  .isEnumerable('code', 416)
  .isEnumerable('status', 'Range Not Satisfiable')
  .isEnumerable('message', 'Requested range is not satisfiable, please check Range and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new RangeNotSatisfiable when given "Range Not Satisfiable".

```js
unit
  .object(HttpError('Range Not Satisfiable'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(RangeNotSatisfiable)
  .isEnumerable('code', 416)
  .isEnumerable('status', 'Range Not Satisfiable')
  .isEnumerable('message', 'Requested range is not satisfiable, please check Range and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new RangeNotSatisfiable when given "RangeNotSatisfiable".

```js
unit
  .object(HttpError('RangeNotSatisfiable'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(RangeNotSatisfiable)
  .isEnumerable('code', 416)
  .isEnumerable('status', 'Range Not Satisfiable')
  .isEnumerable('message', 'Requested range is not satisfiable, please check Range and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new ExpectationFailed when given 417.

```js
unit
  .object(HttpError(417))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(ExpectationFailed)
  .isEnumerable('code', 417)
  .isEnumerable('status', 'Expectation Failed')
  .isEnumerable('message', 'Sorry, your expectation can not be meet, please check Expect and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new ExpectationFailed when given "Expectation Failed".

```js
unit
  .object(HttpError('Expectation Failed'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(ExpectationFailed)
  .isEnumerable('code', 417)
  .isEnumerable('status', 'Expectation Failed')
  .isEnumerable('message', 'Sorry, your expectation can not be meet, please check Expect and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new ExpectationFailed when given "ExpectationFailed".

```js
unit
  .object(HttpError('ExpectationFailed'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(ExpectationFailed)
  .isEnumerable('code', 417)
  .isEnumerable('status', 'Expectation Failed')
  .isEnumerable('message', 'Sorry, your expectation can not be meet, please check Expect and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new IMATeapot when given 418.

```js
unit
  .object(HttpError(418))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(IMATeapot)
  .isEnumerable('code', 418)
  .isEnumerable('status', 'I\'m a teapot')
  .isEnumerable('message', 'Tip me over, and pour me out.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new IMATeapot when given "I'm a teapot".

```js
unit
  .object(HttpError('I\'m a teapot'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(IMATeapot)
  .isEnumerable('code', 418)
  .isEnumerable('status', 'I\'m a teapot')
  .isEnumerable('message', 'Tip me over, and pour me out.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new IMATeapot when given "IMATeapot".

```js
unit
  .object(HttpError('IMATeapot'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(IMATeapot)
  .isEnumerable('code', 418)
  .isEnumerable('status', 'I\'m a teapot')
  .isEnumerable('message', 'Tip me over, and pour me out.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new MisdirectedRequest when given 421.

```js
unit
  .object(HttpError(421))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(MisdirectedRequest)
  .isEnumerable('code', 421)
  .isEnumerable('status', 'Misdirected Request')
  .isEnumerable('message', 'Sorry, we got misdirected, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new MisdirectedRequest when given "Misdirected Request".

```js
unit
  .object(HttpError('Misdirected Request'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(MisdirectedRequest)
  .isEnumerable('code', 421)
  .isEnumerable('status', 'Misdirected Request')
  .isEnumerable('message', 'Sorry, we got misdirected, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new MisdirectedRequest when given "MisdirectedRequest".

```js
unit
  .object(HttpError('MisdirectedRequest'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(MisdirectedRequest)
  .isEnumerable('code', 421)
  .isEnumerable('status', 'Misdirected Request')
  .isEnumerable('message', 'Sorry, we got misdirected, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UnprocessableEntity when given 422.

```js
unit
  .object(HttpError(422))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(UnprocessableEntity)
  .isEnumerable('code', 422)
  .isEnumerable('status', 'Unprocessable Entity')
  .isEnumerable('message', 'Sorry, it appears your document instructions are semantically erroneous.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UnprocessableEntity when given "Unprocessable Entity".

```js
unit
  .object(HttpError('Unprocessable Entity'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(UnprocessableEntity)
  .isEnumerable('code', 422)
  .isEnumerable('status', 'Unprocessable Entity')
  .isEnumerable('message', 'Sorry, it appears your document instructions are semantically erroneous.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UnprocessableEntity when given "UnprocessableEntity".

```js
unit
  .object(HttpError('UnprocessableEntity'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(UnprocessableEntity)
  .isEnumerable('code', 422)
  .isEnumerable('status', 'Unprocessable Entity')
  .isEnumerable('message', 'Sorry, it appears your document instructions are semantically erroneous.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Locked when given 423.

```js
unit
  .object(HttpError(423))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(Locked)
  .isEnumerable('code', 423)
  .isEnumerable('status', 'Locked')
  .isEnumerable('message', 'Document is currently locked, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Locked when given "Locked".

```js
unit
  .object(HttpError('Locked'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(Locked)
  .isEnumerable('code', 423)
  .isEnumerable('status', 'Locked')
  .isEnumerable('message', 'Document is currently locked, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new Locked when given "Locked".

```js
unit
  .object(HttpError('Locked'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(Locked)
  .isEnumerable('code', 423)
  .isEnumerable('status', 'Locked')
  .isEnumerable('message', 'Document is currently locked, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new FailedDependency when given 424.

```js
unit
  .object(HttpError(424))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(FailedDependency)
  .isEnumerable('code', 424)
  .isEnumerable('status', 'Failed Dependency')
  .isEnumerable('message', 'Sorry, it appears a dependent request has failed please retry previous dependent request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new FailedDependency when given "Failed Dependency".

```js
unit
  .object(HttpError('Failed Dependency'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(FailedDependency)
  .isEnumerable('code', 424)
  .isEnumerable('status', 'Failed Dependency')
  .isEnumerable('message', 'Sorry, it appears a dependent request has failed please retry previous dependent request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new FailedDependency when given "FailedDependency".

```js
unit
  .object(HttpError('FailedDependency'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(FailedDependency)
  .isEnumerable('code', 424)
  .isEnumerable('status', 'Failed Dependency')
  .isEnumerable('message', 'Sorry, it appears a dependent request has failed please retry previous dependent request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UpgradeRequired when given 426.

```js
unit
  .object(HttpError(426))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(UpgradeRequired)
  .isEnumerable('code', 426)
  .isEnumerable('status', 'Upgrade Required')
  .isEnumerable('message', 'Please, upgrade and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UpgradeRequired when given "Upgrade Required".

```js
unit
  .object(HttpError('Upgrade Required'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(UpgradeRequired)
  .isEnumerable('code', 426)
  .isEnumerable('status', 'Upgrade Required')
  .isEnumerable('message', 'Please, upgrade and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UpgradeRequired when given "UpgradeRequired".

```js
unit
  .object(HttpError('UpgradeRequired'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(UpgradeRequired)
  .isEnumerable('code', 426)
  .isEnumerable('status', 'Upgrade Required')
  .isEnumerable('message', 'Please, upgrade and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new PreconditionRequired when given 428.

```js
unit
  .object(HttpError(428))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(PreconditionRequired)
  .isEnumerable('code', 428)
  .isEnumerable('status', 'Precondition Required')
  .isEnumerable('message', 'Please, add preconditions to your request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new PreconditionRequired when given "Precondition Required".

```js
unit
  .object(HttpError('Precondition Required'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(PreconditionRequired)
  .isEnumerable('code', 428)
  .isEnumerable('status', 'Precondition Required')
  .isEnumerable('message', 'Please, add preconditions to your request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new PreconditionRequired when given "PreconditionRequired".

```js
unit
  .object(HttpError('PreconditionRequired'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(PreconditionRequired)
  .isEnumerable('code', 428)
  .isEnumerable('status', 'Precondition Required')
  .isEnumerable('message', 'Please, add preconditions to your request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new TooManyRequests when given 429.

```js
unit
  .object(HttpError(429))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(TooManyRequests)
  .isEnumerable('code', 429)
  .isEnumerable('status', 'Too Many Requests')
  .isEnumerable('message', 'Sorry, you have exceeded your rate limit, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new TooManyRequests when given "Too Many Requests".

```js
unit
  .object(HttpError('Too Many Requests'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(TooManyRequests)
  .isEnumerable('code', 429)
  .isEnumerable('status', 'Too Many Requests')
  .isEnumerable('message', 'Sorry, you have exceeded your rate limit, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new TooManyRequests when given "TooManyRequests".

```js
unit
  .object(HttpError('TooManyRequests'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(TooManyRequests)
  .isEnumerable('code', 429)
  .isEnumerable('status', 'Too Many Requests')
  .isEnumerable('message', 'Sorry, you have exceeded your rate limit, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new RequestHeaderFieldsTooLarge when given 431.

```js
unit
  .object(HttpError(431))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(RequestHeaderFieldsTooLarge)
  .isEnumerable('code', 431)
  .isEnumerable('status', 'Request Header Fields Too Large')
  .isEnumerable('message', 'Request header is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new RequestHeaderFieldsTooLarge when given "Request Header Fields Too Large".

```js
unit
  .object(HttpError('Request Header Fields Too Large'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(RequestHeaderFieldsTooLarge)
  .isEnumerable('code', 431)
  .isEnumerable('status', 'Request Header Fields Too Large')
  .isEnumerable('message', 'Request header is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new RequestHeaderFieldsTooLarge when given "RequestHeaderFieldsTooLarge".

```js
unit
  .object(HttpError('RequestHeaderFieldsTooLarge'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(RequestHeaderFieldsTooLarge)
  .isEnumerable('code', 431)
  .isEnumerable('status', 'Request Header Fields Too Large')
  .isEnumerable('message', 'Request header is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UnavailableForLegalReasons when given 451.

```js
unit
  .object(HttpError(451))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(UnavailableForLegalReasons)
  .isEnumerable('code', 451)
  .isEnumerable('status', 'Unavailable For Legal Reasons')
  .isEnumerable('message', 'Due to legal reasons this resource has been removed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UnavailableForLegalReasons when given "Unavailable For Legal Reasons".

```js
unit
  .object(HttpError('Unavailable For Legal Reasons'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(UnavailableForLegalReasons)
  .isEnumerable('code', 451)
  .isEnumerable('status', 'Unavailable For Legal Reasons')
  .isEnumerable('message', 'Due to legal reasons this resource has been removed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UnavailableForLegalReasons when given "UnavailableForLegalReasons".

```js
unit
  .object(HttpError('UnavailableForLegalReasons'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ClientError)
  .isInstanceOf(UnavailableForLegalReasons)
  .isEnumerable('code', 451)
  .isEnumerable('status', 'Unavailable For Legal Reasons')
  .isEnumerable('message', 'Due to legal reasons this resource has been removed.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new InternalServerError when given 500.

```js
unit
  .object(HttpError(500))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(InternalServerError)
  .isEnumerable('code', 500)
  .isEnumerable('status', 'Internal Server Error')
  .isEnumerable('message', 'Sorry, it appears we had an unexpected error, please try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new InternalServerError when given "Internal Server Error".

```js
unit
  .object(HttpError('Internal Server Error'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(InternalServerError)
  .isEnumerable('code', 500)
  .isEnumerable('status', 'Internal Server Error')
  .isEnumerable('message', 'Sorry, it appears we had an unexpected error, please try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new InternalServerError when given "InternalServerError".

```js
unit
  .object(HttpError('InternalServerError'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(InternalServerError)
  .isEnumerable('code', 500)
  .isEnumerable('status', 'Internal Server Error')
  .isEnumerable('message', 'Sorry, it appears we had an unexpected error, please try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NotImplemented when given 501.

```js
unit
  .object(HttpError(501))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(NotImplemented)
  .isEnumerable('code', 501)
  .isEnumerable('status', 'Not Implemented')
  .isEnumerable('message', 'Sorry, this is not fully implemented, please try later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NotImplemented when given "Not Implemented".

```js
unit
  .object(HttpError('Not Implemented'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(NotImplemented)
  .isEnumerable('code', 501)
  .isEnumerable('status', 'Not Implemented')
  .isEnumerable('message', 'Sorry, this is not fully implemented, please try later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NotImplemented when given "NotImplemented".

```js
unit
  .object(HttpError('NotImplemented'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(NotImplemented)
  .isEnumerable('code', 501)
  .isEnumerable('status', 'Not Implemented')
  .isEnumerable('message', 'Sorry, this is not fully implemented, please try later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new BadGateway when given 502.

```js
unit
  .object(HttpError(502))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(BadGateway)
  .isEnumerable('code', 502)
  .isEnumerable('status', 'Bad Gateway')
  .isEnumerable('message', 'Sorry, It appears we received an error from another service that is needed to fulfill your request, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new BadGateway when given "Bad Gateway".

```js
unit
  .object(HttpError('Bad Gateway'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(BadGateway)
  .isEnumerable('code', 502)
  .isEnumerable('status', 'Bad Gateway')
  .isEnumerable('message', 'Sorry, It appears we received an error from another service that is needed to fulfill your request, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new BadGateway when given "BadGateway".

```js
unit
  .object(HttpError('BadGateway'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(BadGateway)
  .isEnumerable('code', 502)
  .isEnumerable('status', 'Bad Gateway')
  .isEnumerable('message', 'Sorry, It appears we received an error from another service that is needed to fulfill your request, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new ServiceUnavailable when given 503.

```js
unit
  .object(HttpError(503))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(ServiceUnavailable)
  .isEnumerable('code', 503)
  .isEnumerable('status', 'Service Unavailable')
  .isEnumerable('message', 'Sorry, this service is currently unavailable, please try later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new ServiceUnavailable when given "Service Unavailable".

```js
unit
  .object(HttpError('Service Unavailable'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(ServiceUnavailable)
  .isEnumerable('code', 503)
  .isEnumerable('status', 'Service Unavailable')
  .isEnumerable('message', 'Sorry, this service is currently unavailable, please try later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new ServiceUnavailable when given "ServiceUnavailable".

```js
unit
  .object(HttpError('ServiceUnavailable'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(ServiceUnavailable)
  .isEnumerable('code', 503)
  .isEnumerable('status', 'Service Unavailable')
  .isEnumerable('message', 'Sorry, this service is currently unavailable, please try later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new GatewayTimeout when given 504.

```js
unit
  .object(HttpError(504))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(GatewayTimeout)
  .isEnumerable('code', 504)
  .isEnumerable('status', 'Gateway Timeout')
  .isEnumerable('message', 'Sorry, it appears another service is taking to long and we cannot wait any longer.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new GatewayTimeout when given "Gateway Timeout".

```js
unit
  .object(HttpError('Gateway Timeout'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(GatewayTimeout)
  .isEnumerable('code', 504)
  .isEnumerable('status', 'Gateway Timeout')
  .isEnumerable('message', 'Sorry, it appears another service is taking to long and we cannot wait any longer.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new GatewayTimeout when given "GatewayTimeout".

```js
unit
  .object(HttpError('GatewayTimeout'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(GatewayTimeout)
  .isEnumerable('code', 504)
  .isEnumerable('status', 'Gateway Timeout')
  .isEnumerable('message', 'Sorry, it appears another service is taking to long and we cannot wait any longer.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new HTTPVersionNotSupported when given 505.

```js
unit
  .object(HttpError(505))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(HTTPVersionNotSupported)
  .isEnumerable('code', 505)
  .isEnumerable('status', 'HTTP Version Not Supported')
  .isEnumerable('message', 'Please, try a diffrent protocol version and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new HTTPVersionNotSupported when given "HTTP Version Not Supported".

```js
unit
  .object(HttpError('HTTP Version Not Supported'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(HTTPVersionNotSupported)
  .isEnumerable('code', 505)
  .isEnumerable('status', 'HTTP Version Not Supported')
  .isEnumerable('message', 'Please, try a diffrent protocol version and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new HTTPVersionNotSupported when given "HTTPVersionNotSupported".

```js
unit
  .object(HttpError('HTTPVersionNotSupported'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(HTTPVersionNotSupported)
  .isEnumerable('code', 505)
  .isEnumerable('status', 'HTTP Version Not Supported')
  .isEnumerable('message', 'Please, try a diffrent protocol version and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new VariantAlsoNegotiates when given 506.

```js
unit
  .object(HttpError(506))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(VariantAlsoNegotiates)
  .isEnumerable('code', 506)
  .isEnumerable('status', 'Variant Also Negotiates')
  .isEnumerable('message', 'Sorry, it appears there is a misconfiguration on our end.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new VariantAlsoNegotiates when given "Variant Also Negotiates".

```js
unit
  .object(HttpError('Variant Also Negotiates'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(VariantAlsoNegotiates)
  .isEnumerable('code', 506)
  .isEnumerable('status', 'Variant Also Negotiates')
  .isEnumerable('message', 'Sorry, it appears there is a misconfiguration on our end.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new VariantAlsoNegotiates when given "VariantAlsoNegotiates".

```js
unit
  .object(HttpError('VariantAlsoNegotiates'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(VariantAlsoNegotiates)
  .isEnumerable('code', 506)
  .isEnumerable('status', 'Variant Also Negotiates')
  .isEnumerable('message', 'Sorry, it appears there is a misconfiguration on our end.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new InsufficientStorage when given 507.

```js
unit
  .object(HttpError(507))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(InsufficientStorage)
  .isEnumerable('code', 507)
  .isEnumerable('status', 'Insufficient Storage')
  .isEnumerable('message', 'Sorry, it appears we have no more room for storage.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new InsufficientStorage when given "Insufficient Storage".

```js
unit
  .object(HttpError('Insufficient Storage'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(InsufficientStorage)
  .isEnumerable('code', 507)
  .isEnumerable('status', 'Insufficient Storage')
  .isEnumerable('message', 'Sorry, it appears we have no more room for storage.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new InsufficientStorage when given "InsufficientStorage".

```js
unit
  .object(HttpError('InsufficientStorage'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(InsufficientStorage)
  .isEnumerable('code', 507)
  .isEnumerable('status', 'Insufficient Storage')
  .isEnumerable('message', 'Sorry, it appears we have no more room for storage.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new LoopDetected when given 508.

```js
unit
  .object(HttpError(508))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(LoopDetected)
  .isEnumerable('code', 508)
  .isEnumerable('status', 'Loop Detected')
  .isEnumerable('message', 'Sorry, We have detected an infintie loop and had to stop the request, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new LoopDetected when given "Loop Detected".

```js
unit
  .object(HttpError('Loop Detected'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(LoopDetected)
  .isEnumerable('code', 508)
  .isEnumerable('status', 'Loop Detected')
  .isEnumerable('message', 'Sorry, We have detected an infintie loop and had to stop the request, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new LoopDetected when given "LoopDetected".

```js
unit
  .object(HttpError('LoopDetected'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(LoopDetected)
  .isEnumerable('code', 508)
  .isEnumerable('status', 'Loop Detected')
  .isEnumerable('message', 'Sorry, We have detected an infintie loop and had to stop the request, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NotExtended when given 510.

```js
unit
  .object(HttpError(510))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(NotExtended)
  .isEnumerable('code', 510)
  .isEnumerable('status', 'Not Extended')
  .isEnumerable('message', 'The policy for accessing this resource has not been met by this request.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NotExtended when given "Not Extended".

```js
unit
  .object(HttpError('Not Extended'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(NotExtended)
  .isEnumerable('code', 510)
  .isEnumerable('status', 'Not Extended')
  .isEnumerable('message', 'The policy for accessing this resource has not been met by this request.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NotExtended when given "NotExtended".

```js
unit
  .object(HttpError('NotExtended'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(NotExtended)
  .isEnumerable('code', 510)
  .isEnumerable('status', 'Not Extended')
  .isEnumerable('message', 'The policy for accessing this resource has not been met by this request.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NetworkAuthenticationRequired when given 511.

```js
unit
  .object(HttpError(511))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(NetworkAuthenticationRequired)
  .isEnumerable('code', 511)
  .isEnumerable('status', 'Network Authentication Required')
  .isEnumerable('message', 'Please, authenticate with the network and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NetworkAuthenticationRequired when given "Network Authentication Required".

```js
unit
  .object(HttpError('Network Authentication Required'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(NetworkAuthenticationRequired)
  .isEnumerable('code', 511)
  .isEnumerable('status', 'Network Authentication Required')
  .isEnumerable('message', 'Please, authenticate with the network and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NetworkAuthenticationRequired when given "NetworkAuthenticationRequired".

```js
unit
  .object(HttpError('NetworkAuthenticationRequired'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(NetworkAuthenticationRequired)
  .isEnumerable('code', 511)
  .isEnumerable('status', 'Network Authentication Required')
  .isEnumerable('message', 'Please, authenticate with the network and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UnknownError when given 520.

```js
unit
  .object(HttpError(520))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(UnknownError)
  .isEnumerable('code', 520)
  .isEnumerable('status', 'Unknown Error')
  .isEnumerable('message', 'Sorry, an unexpected error has occured, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UnknownError when given "Unknown Error".

```js
unit
  .object(HttpError('Unknown Error'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(UnknownError)
  .isEnumerable('code', 520)
  .isEnumerable('status', 'Unknown Error')
  .isEnumerable('message', 'Sorry, an unexpected error has occured, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UnknownError when given "UnknownError".

```js
unit
  .object(HttpError('UnknownError'))
  .isInstanceOf(Error)
  .isInstanceOf(HttpError)
  .isInstanceOf(ServerError)
  .isInstanceOf(UnknownError)
  .isEnumerable('code', 520)
  .isEnumerable('status', 'Unknown Error')
  .isEnumerable('message', 'Sorry, an unexpected error has occured, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

<a name="imateapot"></a>
# IMATeapot
should be a function.

```js
unit
  .function(IMATeapot);
```

should return an instance of IMATeapot.

```js
unit
  .object(new IMATeapot())
  .isInstanceOf(IMATeapot)
  .isEnumerable('code', 418)
  .isEnumerable('status', 'I\'m a teapot')
  .isEnumerable('message', 'Tip me over, and pour me out.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof IMATeapot without the new operator.

```js
unit
  .object(IMATeapot())
  .isInstanceOf(IMATeapot)
  .isEnumerable('code', 418)
  .isEnumerable('status', 'I\'m a teapot')
  .isEnumerable('message', 'Tip me over, and pour me out.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="imateapot-version"></a>
## #VERSION
should be a constant property.

```js
const test = new IMATeapot();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="imateapot-code"></a>
## #code
should be a constant property.

```js
const test = new IMATeapot();
unit
  .number(test.code)
  .is(418);
```

<a name="imateapot-status"></a>
## #status
should be a constant property.

```js
const test = new IMATeapot();
unit
  .string(test.status)
  .is('I\'m a teapot');
```

<a name="imateapot-message"></a>
## #message
should have a default message.

```js
const test = new IMATeapot();
unit
  .string(test.message)
  .is('Tip me over, and pour me out.');
```

should accept falsy as the default message.

```js
const test = new IMATeapot();
unit
  .string(test.message)
  .is('Tip me over, and pour me out.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Tip me over, and pour me out.')
  .given(test.message = null)
  .string(test.message)
  .is('Tip me over, and pour me out.')
  .given(test.message = false)
  .string(test.message)
  .is('Tip me over, and pour me out.')
  .given(test.message = 0)
  .string(test.message)
  .is('Tip me over, and pour me out.')
  .given(test.message = '')
  .string(test.message)
  .is('Tip me over, and pour me out.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Tip me over, and pour me out.');
```

should accept a string.

```js
const test = new IMATeapot();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'I\'m a teapot')
  .string(test.message)
  .is('I\'m a teapot');
```

should accept stringifiable arrays.

```js
const test = new IMATeapot();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new IMATeapot();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new IMATeapot();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="imateapot-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new IMATeapot();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new IMATeapot({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="imateapot-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new IMATeapot();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new IMATeapot();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(IMATeapot)
  .hasProperty('message', 'Bad things.');
```

<a name="imateapot-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new IMATeapot();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new IMATeapot({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="imateapot-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new IMATeapot();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new IMATeapot();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(IMATeapot)
  .hasProperty('debug', 'Something happened.');
```

<a name="imateapot-getcause"></a>
## #getCause
should be a function.

```js
const test = new IMATeapot();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new IMATeapot({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="imateapot-setcause"></a>
## #setCause
should be a function.

```js
const test = new IMATeapot();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new IMATeapot();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(IMATeapot)
  .hasProperty('cause', cause);
```

<a name="imateapot-set"></a>
## #set
should be a function.

```js
const test = new IMATeapot();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new IMATeapot();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(IMATeapot)
  .isEnumerable('code', 418)
  .isEnumerable('status', 'I\'m a teapot')
  .isEnumerable('message', 'Tip me over, and pour me out.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(IMATeapot)
  .isEnumerable('code', 418)
  .isEnumerable('status', 'I\'m a teapot')
  .isEnumerable('message', 'Tip me over, and pour me out.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(IMATeapot)
  .isEnumerable('code', 418)
  .isEnumerable('status', 'I\'m a teapot')
  .isEnumerable('message', 'Tip me over, and pour me out.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(IMATeapot)
  .isEnumerable('code', 418)
  .isEnumerable('status', 'I\'m a teapot')
  .isEnumerable('message', 'Tip me over, and pour me out.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new IMATeapot();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new IMATeapot();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="imateapot-get"></a>
## #get
should be a function.

```js
const test = new IMATeapot();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new IMATeapot();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 418)
  .hasProperty('status', 'I\'m a teapot')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 418)
  .hasProperty('status', 'I\'m a teapot')
  .hasProperty('message', 'Tip me over, and pour me out.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new IMATeapot();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 418)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 418)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="imateapot-tojson"></a>
## #toJSON
should be a function.

```js
const test = new IMATeapot();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new IMATeapot();
unit
  .object(test.toJSON())
  .hasProperty('code', 418)
  .hasProperty('status', 'I\'m a teapot')
  .hasProperty('message', 'Tip me over, and pour me out.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 418)
  .hasProperty('status', 'I\'m a teapot')
  .hasProperty('message', 'Tip me over, and pour me out.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="imateapot-tostring"></a>
## #toString
should be a function.

```js
const test = new IMATeapot();
unit
  .function(test.toString);
```

should return IMATeapot: 418 I'm a teapot.

```js
const test = new IMATeapot();
unit
  .string(test.toString())
  .is('IMATeapot: 418 I\'m a teapot');
```

<a name="imateapot-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/imateapot".

```js
const test = new IMATeapot();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/imateapot');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new IMATeapot();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/imateapot]');
```

<a name="insufficientstorage"></a>
# InsufficientStorage
should be a function.

```js
unit
  .function(InsufficientStorage);
```

should return an instance of InsufficientStorage.

```js
unit
  .object(new InsufficientStorage())
  .isInstanceOf(InsufficientStorage)
  .isEnumerable('code', 507)
  .isEnumerable('status', 'Insufficient Storage')
  .isEnumerable('message', 'Sorry, it appears we have no more room for storage.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof InsufficientStorage without the new operator.

```js
unit
  .object(InsufficientStorage())
  .isInstanceOf(InsufficientStorage)
  .isEnumerable('code', 507)
  .isEnumerable('status', 'Insufficient Storage')
  .isEnumerable('message', 'Sorry, it appears we have no more room for storage.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="insufficientstorage-version"></a>
## #VERSION
should be a constant property.

```js
const test = new InsufficientStorage();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="insufficientstorage-code"></a>
## #code
should be a constant property.

```js
const test = new InsufficientStorage();
unit
  .number(test.code)
  .is(507);
```

<a name="insufficientstorage-status"></a>
## #status
should be a constant property.

```js
const test = new InsufficientStorage();
unit
  .string(test.status)
  .is('Insufficient Storage');
```

<a name="insufficientstorage-message"></a>
## #message
should have a default message.

```js
const test = new InsufficientStorage();
unit
  .string(test.message)
  .is('Sorry, it appears we have no more room for storage.');
```

should accept falsy as the default message.

```js
const test = new InsufficientStorage();
unit
  .string(test.message)
  .is('Sorry, it appears we have no more room for storage.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Sorry, it appears we have no more room for storage.')
  .given(test.message = null)
  .string(test.message)
  .is('Sorry, it appears we have no more room for storage.')
  .given(test.message = false)
  .string(test.message)
  .is('Sorry, it appears we have no more room for storage.')
  .given(test.message = 0)
  .string(test.message)
  .is('Sorry, it appears we have no more room for storage.')
  .given(test.message = '')
  .string(test.message)
  .is('Sorry, it appears we have no more room for storage.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Sorry, it appears we have no more room for storage.');
```

should accept a string.

```js
const test = new InsufficientStorage();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Insufficient Storage')
  .string(test.message)
  .is('Insufficient Storage');
```

should accept stringifiable arrays.

```js
const test = new InsufficientStorage();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new InsufficientStorage();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new InsufficientStorage();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="insufficientstorage-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new InsufficientStorage();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new InsufficientStorage({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="insufficientstorage-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new InsufficientStorage();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new InsufficientStorage();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(InsufficientStorage)
  .hasProperty('message', 'Bad things.');
```

<a name="insufficientstorage-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new InsufficientStorage();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new InsufficientStorage({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="insufficientstorage-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new InsufficientStorage();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new InsufficientStorage();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(InsufficientStorage)
  .hasProperty('debug', 'Something happened.');
```

<a name="insufficientstorage-getcause"></a>
## #getCause
should be a function.

```js
const test = new InsufficientStorage();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new InsufficientStorage({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="insufficientstorage-setcause"></a>
## #setCause
should be a function.

```js
const test = new InsufficientStorage();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new InsufficientStorage();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(InsufficientStorage)
  .hasProperty('cause', cause);
```

<a name="insufficientstorage-set"></a>
## #set
should be a function.

```js
const test = new InsufficientStorage();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new InsufficientStorage();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(InsufficientStorage)
  .isEnumerable('code', 507)
  .isEnumerable('status', 'Insufficient Storage')
  .isEnumerable('message', 'Sorry, it appears we have no more room for storage.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(InsufficientStorage)
  .isEnumerable('code', 507)
  .isEnumerable('status', 'Insufficient Storage')
  .isEnumerable('message', 'Sorry, it appears we have no more room for storage.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(InsufficientStorage)
  .isEnumerable('code', 507)
  .isEnumerable('status', 'Insufficient Storage')
  .isEnumerable('message', 'Sorry, it appears we have no more room for storage.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(InsufficientStorage)
  .isEnumerable('code', 507)
  .isEnumerable('status', 'Insufficient Storage')
  .isEnumerable('message', 'Sorry, it appears we have no more room for storage.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new InsufficientStorage();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new InsufficientStorage();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="insufficientstorage-get"></a>
## #get
should be a function.

```js
const test = new InsufficientStorage();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new InsufficientStorage();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 507)
  .hasProperty('status', 'Insufficient Storage')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 507)
  .hasProperty('status', 'Insufficient Storage')
  .hasProperty('message', 'Sorry, it appears we have no more room for storage.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new InsufficientStorage();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 507)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 507)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="insufficientstorage-tojson"></a>
## #toJSON
should be a function.

```js
const test = new InsufficientStorage();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new InsufficientStorage();
unit
  .object(test.toJSON())
  .hasProperty('code', 507)
  .hasProperty('status', 'Insufficient Storage')
  .hasProperty('message', 'Sorry, it appears we have no more room for storage.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 507)
  .hasProperty('status', 'Insufficient Storage')
  .hasProperty('message', 'Sorry, it appears we have no more room for storage.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="insufficientstorage-tostring"></a>
## #toString
should be a function.

```js
const test = new InsufficientStorage();
unit
  .function(test.toString);
```

should return InsufficientStorage: 507 Insufficient Storage.

```js
const test = new InsufficientStorage();
unit
  .string(test.toString())
  .is('InsufficientStorage: 507 Insufficient Storage');
```

<a name="insufficientstorage-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/insufficientstorage".

```js
const test = new InsufficientStorage();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/insufficientstorage');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new InsufficientStorage();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/insufficientstorage]');
```

<a name="internalservererror"></a>
# InternalServerError
should be a function.

```js
unit
  .function(InternalServerError);
```

should return an instance of InternalServerError.

```js
unit
  .object(new InternalServerError())
  .isInstanceOf(InternalServerError)
  .isEnumerable('code', 500)
  .isEnumerable('status', 'Internal Server Error')
  .isEnumerable('message', 'Sorry, it appears we had an unexpected error, please try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof InternalServerError without the new operator.

```js
unit
  .object(InternalServerError())
  .isInstanceOf(InternalServerError)
  .isEnumerable('code', 500)
  .isEnumerable('status', 'Internal Server Error')
  .isEnumerable('message', 'Sorry, it appears we had an unexpected error, please try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="internalservererror-version"></a>
## #VERSION
should be a constant property.

```js
const test = new InternalServerError();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="internalservererror-code"></a>
## #code
should be a constant property.

```js
const test = new InternalServerError();
unit
  .number(test.code)
  .is(500);
```

<a name="internalservererror-status"></a>
## #status
should be a constant property.

```js
const test = new InternalServerError();
unit
  .string(test.status)
  .is('Internal Server Error');
```

<a name="internalservererror-message"></a>
## #message
should have a default message.

```js
const test = new InternalServerError();
unit
  .string(test.message)
  .is('Sorry, it appears we had an unexpected error, please try again.');
```

should accept falsy as the default message.

```js
const test = new InternalServerError();
unit
  .string(test.message)
  .is('Sorry, it appears we had an unexpected error, please try again.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Sorry, it appears we had an unexpected error, please try again.')
  .given(test.message = null)
  .string(test.message)
  .is('Sorry, it appears we had an unexpected error, please try again.')
  .given(test.message = false)
  .string(test.message)
  .is('Sorry, it appears we had an unexpected error, please try again.')
  .given(test.message = 0)
  .string(test.message)
  .is('Sorry, it appears we had an unexpected error, please try again.')
  .given(test.message = '')
  .string(test.message)
  .is('Sorry, it appears we had an unexpected error, please try again.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Sorry, it appears we had an unexpected error, please try again.');
```

should accept a string.

```js
const test = new InternalServerError();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Internal Server Error')
  .string(test.message)
  .is('Internal Server Error');
```

should accept stringifiable arrays.

```js
const test = new InternalServerError();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new InternalServerError();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new InternalServerError();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="internalservererror-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new InternalServerError();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new InternalServerError({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="internalservererror-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new InternalServerError();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new InternalServerError();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(InternalServerError)
  .hasProperty('message', 'Bad things.');
```

<a name="internalservererror-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new InternalServerError();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new InternalServerError({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="internalservererror-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new InternalServerError();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new InternalServerError();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(InternalServerError)
  .hasProperty('debug', 'Something happened.');
```

<a name="internalservererror-getcause"></a>
## #getCause
should be a function.

```js
const test = new InternalServerError();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new InternalServerError({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="internalservererror-setcause"></a>
## #setCause
should be a function.

```js
const test = new InternalServerError();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new InternalServerError();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(InternalServerError)
  .hasProperty('cause', cause);
```

<a name="internalservererror-set"></a>
## #set
should be a function.

```js
const test = new InternalServerError();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new InternalServerError();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(InternalServerError)
  .isEnumerable('code', 500)
  .isEnumerable('status', 'Internal Server Error')
  .isEnumerable('message', 'Sorry, it appears we had an unexpected error, please try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(InternalServerError)
  .isEnumerable('code', 500)
  .isEnumerable('status', 'Internal Server Error')
  .isEnumerable('message', 'Sorry, it appears we had an unexpected error, please try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(InternalServerError)
  .isEnumerable('code', 500)
  .isEnumerable('status', 'Internal Server Error')
  .isEnumerable('message', 'Sorry, it appears we had an unexpected error, please try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(InternalServerError)
  .isEnumerable('code', 500)
  .isEnumerable('status', 'Internal Server Error')
  .isEnumerable('message', 'Sorry, it appears we had an unexpected error, please try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new InternalServerError();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new InternalServerError();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="internalservererror-get"></a>
## #get
should be a function.

```js
const test = new InternalServerError();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new InternalServerError();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 500)
  .hasProperty('status', 'Internal Server Error')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 500)
  .hasProperty('status', 'Internal Server Error')
  .hasProperty('message', 'Sorry, it appears we had an unexpected error, please try again.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new InternalServerError();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 500)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 500)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="internalservererror-tojson"></a>
## #toJSON
should be a function.

```js
const test = new InternalServerError();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new InternalServerError();
unit
  .object(test.toJSON())
  .hasProperty('code', 500)
  .hasProperty('status', 'Internal Server Error')
  .hasProperty('message', 'Sorry, it appears we had an unexpected error, please try again.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 500)
  .hasProperty('status', 'Internal Server Error')
  .hasProperty('message', 'Sorry, it appears we had an unexpected error, please try again.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="internalservererror-tostring"></a>
## #toString
should be a function.

```js
const test = new InternalServerError();
unit
  .function(test.toString);
```

should return InternalServerError: 500 Internal Server Error.

```js
const test = new InternalServerError();
unit
  .string(test.toString())
  .is('InternalServerError: 500 Internal Server Error');
```

<a name="internalservererror-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/internalservererror".

```js
const test = new InternalServerError();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/internalservererror');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new InternalServerError();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/internalservererror]');
```

<a name="lengthrequired"></a>
# LengthRequired
should be a function.

```js
unit
  .function(LengthRequired);
```

should return an instance of LengthRequired.

```js
unit
  .object(new LengthRequired())
  .isInstanceOf(LengthRequired)
  .isEnumerable('code', 411)
  .isEnumerable('status', 'Length Required')
  .isEnumerable('message', 'Please, correct the Length header and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof LengthRequired without the new operator.

```js
unit
  .object(LengthRequired())
  .isInstanceOf(LengthRequired)
  .isEnumerable('code', 411)
  .isEnumerable('status', 'Length Required')
  .isEnumerable('message', 'Please, correct the Length header and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="lengthrequired-version"></a>
## #VERSION
should be a constant property.

```js
const test = new LengthRequired();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="lengthrequired-code"></a>
## #code
should be a constant property.

```js
const test = new LengthRequired();
unit
  .number(test.code)
  .is(411);
```

<a name="lengthrequired-status"></a>
## #status
should be a constant property.

```js
const test = new LengthRequired();
unit
  .string(test.status)
  .is('Length Required');
```

<a name="lengthrequired-message"></a>
## #message
should have a default message.

```js
const test = new LengthRequired();
unit
  .string(test.message)
  .is('Please, correct the Length header and try again.');
```

should accept falsy as the default message.

```js
const test = new LengthRequired();
unit
  .string(test.message)
  .is('Please, correct the Length header and try again.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Please, correct the Length header and try again.')
  .given(test.message = null)
  .string(test.message)
  .is('Please, correct the Length header and try again.')
  .given(test.message = false)
  .string(test.message)
  .is('Please, correct the Length header and try again.')
  .given(test.message = 0)
  .string(test.message)
  .is('Please, correct the Length header and try again.')
  .given(test.message = '')
  .string(test.message)
  .is('Please, correct the Length header and try again.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Please, correct the Length header and try again.');
```

should accept a string.

```js
const test = new LengthRequired();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Length Required')
  .string(test.message)
  .is('Length Required');
```

should accept stringifiable arrays.

```js
const test = new LengthRequired();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new LengthRequired();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new LengthRequired();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="lengthrequired-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new LengthRequired();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new LengthRequired({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="lengthrequired-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new LengthRequired();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new LengthRequired();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(LengthRequired)
  .hasProperty('message', 'Bad things.');
```

<a name="lengthrequired-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new LengthRequired();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new LengthRequired({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="lengthrequired-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new LengthRequired();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new LengthRequired();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(LengthRequired)
  .hasProperty('debug', 'Something happened.');
```

<a name="lengthrequired-getcause"></a>
## #getCause
should be a function.

```js
const test = new LengthRequired();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new LengthRequired({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="lengthrequired-setcause"></a>
## #setCause
should be a function.

```js
const test = new LengthRequired();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new LengthRequired();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(LengthRequired)
  .hasProperty('cause', cause);
```

<a name="lengthrequired-set"></a>
## #set
should be a function.

```js
const test = new LengthRequired();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new LengthRequired();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(LengthRequired)
  .isEnumerable('code', 411)
  .isEnumerable('status', 'Length Required')
  .isEnumerable('message', 'Please, correct the Length header and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(LengthRequired)
  .isEnumerable('code', 411)
  .isEnumerable('status', 'Length Required')
  .isEnumerable('message', 'Please, correct the Length header and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(LengthRequired)
  .isEnumerable('code', 411)
  .isEnumerable('status', 'Length Required')
  .isEnumerable('message', 'Please, correct the Length header and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(LengthRequired)
  .isEnumerable('code', 411)
  .isEnumerable('status', 'Length Required')
  .isEnumerable('message', 'Please, correct the Length header and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new LengthRequired();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new LengthRequired();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="lengthrequired-get"></a>
## #get
should be a function.

```js
const test = new LengthRequired();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new LengthRequired();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 411)
  .hasProperty('status', 'Length Required')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 411)
  .hasProperty('status', 'Length Required')
  .hasProperty('message', 'Please, correct the Length header and try again.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new LengthRequired();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 411)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 411)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="lengthrequired-tojson"></a>
## #toJSON
should be a function.

```js
const test = new LengthRequired();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new LengthRequired();
unit
  .object(test.toJSON())
  .hasProperty('code', 411)
  .hasProperty('status', 'Length Required')
  .hasProperty('message', 'Please, correct the Length header and try again.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 411)
  .hasProperty('status', 'Length Required')
  .hasProperty('message', 'Please, correct the Length header and try again.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="lengthrequired-tostring"></a>
## #toString
should be a function.

```js
const test = new LengthRequired();
unit
  .function(test.toString);
```

should return LengthRequired: 411 Length Required.

```js
const test = new LengthRequired();
unit
  .string(test.toString())
  .is('LengthRequired: 411 Length Required');
```

<a name="lengthrequired-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/lengthrequired".

```js
const test = new LengthRequired();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/lengthrequired');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new LengthRequired();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/lengthrequired]');
```

<a name="locked"></a>
# Locked
should be a function.

```js
unit
  .function(Locked);
```

should return an instance of Locked.

```js
unit
  .object(new Locked())
  .isInstanceOf(Locked)
  .isEnumerable('code', 423)
  .isEnumerable('status', 'Locked')
  .isEnumerable('message', 'Document is currently locked, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof Locked without the new operator.

```js
unit
  .object(Locked())
  .isInstanceOf(Locked)
  .isEnumerable('code', 423)
  .isEnumerable('status', 'Locked')
  .isEnumerable('message', 'Document is currently locked, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="locked-version"></a>
## #VERSION
should be a constant property.

```js
const test = new Locked();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="locked-code"></a>
## #code
should be a constant property.

```js
const test = new Locked();
unit
  .number(test.code)
  .is(423);
```

<a name="locked-status"></a>
## #status
should be a constant property.

```js
const test = new Locked();
unit
  .string(test.status)
  .is('Locked');
```

<a name="locked-message"></a>
## #message
should have a default message.

```js
const test = new Locked();
unit
  .string(test.message)
  .is('Document is currently locked, please try again later.');
```

should accept falsy as the default message.

```js
const test = new Locked();
unit
  .string(test.message)
  .is('Document is currently locked, please try again later.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Document is currently locked, please try again later.')
  .given(test.message = null)
  .string(test.message)
  .is('Document is currently locked, please try again later.')
  .given(test.message = false)
  .string(test.message)
  .is('Document is currently locked, please try again later.')
  .given(test.message = 0)
  .string(test.message)
  .is('Document is currently locked, please try again later.')
  .given(test.message = '')
  .string(test.message)
  .is('Document is currently locked, please try again later.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Document is currently locked, please try again later.');
```

should accept a string.

```js
const test = new Locked();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Locked')
  .string(test.message)
  .is('Locked');
```

should accept stringifiable arrays.

```js
const test = new Locked();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new Locked();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new Locked();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="locked-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new Locked();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new Locked({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="locked-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new Locked();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new Locked();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(Locked)
  .hasProperty('message', 'Bad things.');
```

<a name="locked-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new Locked();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new Locked({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="locked-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new Locked();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new Locked();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(Locked)
  .hasProperty('debug', 'Something happened.');
```

<a name="locked-getcause"></a>
## #getCause
should be a function.

```js
const test = new Locked();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new Locked({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="locked-setcause"></a>
## #setCause
should be a function.

```js
const test = new Locked();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new Locked();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(Locked)
  .hasProperty('cause', cause);
```

<a name="locked-set"></a>
## #set
should be a function.

```js
const test = new Locked();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new Locked();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(Locked)
  .isEnumerable('code', 423)
  .isEnumerable('status', 'Locked')
  .isEnumerable('message', 'Document is currently locked, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(Locked)
  .isEnumerable('code', 423)
  .isEnumerable('status', 'Locked')
  .isEnumerable('message', 'Document is currently locked, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(Locked)
  .isEnumerable('code', 423)
  .isEnumerable('status', 'Locked')
  .isEnumerable('message', 'Document is currently locked, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(Locked)
  .isEnumerable('code', 423)
  .isEnumerable('status', 'Locked')
  .isEnumerable('message', 'Document is currently locked, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new Locked();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new Locked();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="locked-get"></a>
## #get
should be a function.

```js
const test = new Locked();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new Locked();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 423)
  .hasProperty('status', 'Locked')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 423)
  .hasProperty('status', 'Locked')
  .hasProperty('message', 'Document is currently locked, please try again later.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new Locked();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 423)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 423)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="locked-tojson"></a>
## #toJSON
should be a function.

```js
const test = new Locked();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new Locked();
unit
  .object(test.toJSON())
  .hasProperty('code', 423)
  .hasProperty('status', 'Locked')
  .hasProperty('message', 'Document is currently locked, please try again later.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 423)
  .hasProperty('status', 'Locked')
  .hasProperty('message', 'Document is currently locked, please try again later.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="locked-tostring"></a>
## #toString
should be a function.

```js
const test = new Locked();
unit
  .function(test.toString);
```

should return Locked: 423 Locked.

```js
const test = new Locked();
unit
  .string(test.toString())
  .is('Locked: 423 Locked');
```

<a name="locked-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/locked".

```js
const test = new Locked();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/locked');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new Locked();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/locked]');
```

<a name="loopdetected"></a>
# LoopDetected
should be a function.

```js
unit
  .function(LoopDetected);
```

should return an instance of LoopDetected.

```js
unit
  .object(new LoopDetected())
  .isInstanceOf(LoopDetected)
  .isEnumerable('code', 508)
  .isEnumerable('status', 'Loop Detected')
  .isEnumerable('message', 'Sorry, We have detected an infintie loop and had to stop the request, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof LoopDetected without the new operator.

```js
unit
  .object(LoopDetected())
  .isInstanceOf(LoopDetected)
  .isEnumerable('code', 508)
  .isEnumerable('status', 'Loop Detected')
  .isEnumerable('message', 'Sorry, We have detected an infintie loop and had to stop the request, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="loopdetected-version"></a>
## #VERSION
should be a constant property.

```js
const test = new LoopDetected();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="loopdetected-code"></a>
## #code
should be a constant property.

```js
const test = new LoopDetected();
unit
  .number(test.code)
  .is(508);
```

<a name="loopdetected-status"></a>
## #status
should be a constant property.

```js
const test = new LoopDetected();
unit
  .string(test.status)
  .is('Loop Detected');
```

<a name="loopdetected-message"></a>
## #message
should have a default message.

```js
const test = new LoopDetected();
unit
  .string(test.message)
  .is('Sorry, We have detected an infintie loop and had to stop the request, please try again later.');
```

should accept falsy as the default message.

```js
const test = new LoopDetected();
unit
  .string(test.message)
  .is('Sorry, We have detected an infintie loop and had to stop the request, please try again later.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Sorry, We have detected an infintie loop and had to stop the request, please try again later.')
  .given(test.message = null)
  .string(test.message)
  .is('Sorry, We have detected an infintie loop and had to stop the request, please try again later.')
  .given(test.message = false)
  .string(test.message)
  .is('Sorry, We have detected an infintie loop and had to stop the request, please try again later.')
  .given(test.message = 0)
  .string(test.message)
  .is('Sorry, We have detected an infintie loop and had to stop the request, please try again later.')
  .given(test.message = '')
  .string(test.message)
  .is('Sorry, We have detected an infintie loop and had to stop the request, please try again later.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Sorry, We have detected an infintie loop and had to stop the request, please try again later.');
```

should accept a string.

```js
const test = new LoopDetected();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Loop Detected')
  .string(test.message)
  .is('Loop Detected');
```

should accept stringifiable arrays.

```js
const test = new LoopDetected();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new LoopDetected();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new LoopDetected();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="loopdetected-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new LoopDetected();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new LoopDetected({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="loopdetected-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new LoopDetected();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new LoopDetected();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(LoopDetected)
  .hasProperty('message', 'Bad things.');
```

<a name="loopdetected-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new LoopDetected();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new LoopDetected({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="loopdetected-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new LoopDetected();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new LoopDetected();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(LoopDetected)
  .hasProperty('debug', 'Something happened.');
```

<a name="loopdetected-getcause"></a>
## #getCause
should be a function.

```js
const test = new LoopDetected();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new LoopDetected({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="loopdetected-setcause"></a>
## #setCause
should be a function.

```js
const test = new LoopDetected();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new LoopDetected();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(LoopDetected)
  .hasProperty('cause', cause);
```

<a name="loopdetected-set"></a>
## #set
should be a function.

```js
const test = new LoopDetected();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new LoopDetected();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(LoopDetected)
  .isEnumerable('code', 508)
  .isEnumerable('status', 'Loop Detected')
  .isEnumerable('message', 'Sorry, We have detected an infintie loop and had to stop the request, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(LoopDetected)
  .isEnumerable('code', 508)
  .isEnumerable('status', 'Loop Detected')
  .isEnumerable('message', 'Sorry, We have detected an infintie loop and had to stop the request, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(LoopDetected)
  .isEnumerable('code', 508)
  .isEnumerable('status', 'Loop Detected')
  .isEnumerable('message', 'Sorry, We have detected an infintie loop and had to stop the request, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(LoopDetected)
  .isEnumerable('code', 508)
  .isEnumerable('status', 'Loop Detected')
  .isEnumerable('message', 'Sorry, We have detected an infintie loop and had to stop the request, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new LoopDetected();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new LoopDetected();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="loopdetected-get"></a>
## #get
should be a function.

```js
const test = new LoopDetected();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new LoopDetected();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 508)
  .hasProperty('status', 'Loop Detected')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 508)
  .hasProperty('status', 'Loop Detected')
  .hasProperty('message', 'Sorry, We have detected an infintie loop and had to stop the request, please try again later.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new LoopDetected();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 508)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 508)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="loopdetected-tojson"></a>
## #toJSON
should be a function.

```js
const test = new LoopDetected();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new LoopDetected();
unit
  .object(test.toJSON())
  .hasProperty('code', 508)
  .hasProperty('status', 'Loop Detected')
  .hasProperty('message', 'Sorry, We have detected an infintie loop and had to stop the request, please try again later.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 508)
  .hasProperty('status', 'Loop Detected')
  .hasProperty('message', 'Sorry, We have detected an infintie loop and had to stop the request, please try again later.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="loopdetected-tostring"></a>
## #toString
should be a function.

```js
const test = new LoopDetected();
unit
  .function(test.toString);
```

should return LoopDetected: 508 Loop Detected.

```js
const test = new LoopDetected();
unit
  .string(test.toString())
  .is('LoopDetected: 508 Loop Detected');
```

<a name="loopdetected-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/loopdetected".

```js
const test = new LoopDetected();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/loopdetected');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new LoopDetected();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/loopdetected]');
```

<a name="methodnotallowed"></a>
# MethodNotAllowed
should be a function.

```js
unit
  .function(MethodNotAllowed);
```

should return an instance of MethodNotAllowed.

```js
unit
  .object(new MethodNotAllowed())
  .isInstanceOf(MethodNotAllowed)
  .isEnumerable('code', 405)
  .isEnumerable('status', 'Method Not Allowed')
  .isEnumerable('message', 'Please, check your request method and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof MethodNotAllowed without the new operator.

```js
unit
  .object(MethodNotAllowed())
  .isInstanceOf(MethodNotAllowed)
  .isEnumerable('code', 405)
  .isEnumerable('status', 'Method Not Allowed')
  .isEnumerable('message', 'Please, check your request method and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="methodnotallowed-version"></a>
## #VERSION
should be a constant property.

```js
const test = new MethodNotAllowed();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="methodnotallowed-code"></a>
## #code
should be a constant property.

```js
const test = new MethodNotAllowed();
unit
  .number(test.code)
  .is(405);
```

<a name="methodnotallowed-status"></a>
## #status
should be a constant property.

```js
const test = new MethodNotAllowed();
unit
  .string(test.status)
  .is('Method Not Allowed');
```

<a name="methodnotallowed-message"></a>
## #message
should have a default message.

```js
const test = new MethodNotAllowed();
unit
  .string(test.message)
  .is('Please, check your request method and try again.');
```

should accept falsy as the default message.

```js
const test = new MethodNotAllowed();
unit
  .string(test.message)
  .is('Please, check your request method and try again.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Please, check your request method and try again.')
  .given(test.message = null)
  .string(test.message)
  .is('Please, check your request method and try again.')
  .given(test.message = false)
  .string(test.message)
  .is('Please, check your request method and try again.')
  .given(test.message = 0)
  .string(test.message)
  .is('Please, check your request method and try again.')
  .given(test.message = '')
  .string(test.message)
  .is('Please, check your request method and try again.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Please, check your request method and try again.');
```

should accept a string.

```js
const test = new MethodNotAllowed();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Method Not Allowed')
  .string(test.message)
  .is('Method Not Allowed');
```

should accept stringifiable arrays.

```js
const test = new MethodNotAllowed();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new MethodNotAllowed();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new MethodNotAllowed();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="methodnotallowed-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new MethodNotAllowed();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new MethodNotAllowed({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="methodnotallowed-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new MethodNotAllowed();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new MethodNotAllowed();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(MethodNotAllowed)
  .hasProperty('message', 'Bad things.');
```

<a name="methodnotallowed-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new MethodNotAllowed();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new MethodNotAllowed({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="methodnotallowed-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new MethodNotAllowed();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new MethodNotAllowed();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(MethodNotAllowed)
  .hasProperty('debug', 'Something happened.');
```

<a name="methodnotallowed-getcause"></a>
## #getCause
should be a function.

```js
const test = new MethodNotAllowed();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new MethodNotAllowed({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="methodnotallowed-setcause"></a>
## #setCause
should be a function.

```js
const test = new MethodNotAllowed();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new MethodNotAllowed();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(MethodNotAllowed)
  .hasProperty('cause', cause);
```

<a name="methodnotallowed-set"></a>
## #set
should be a function.

```js
const test = new MethodNotAllowed();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new MethodNotAllowed();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(MethodNotAllowed)
  .isEnumerable('code', 405)
  .isEnumerable('status', 'Method Not Allowed')
  .isEnumerable('message', 'Please, check your request method and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(MethodNotAllowed)
  .isEnumerable('code', 405)
  .isEnumerable('status', 'Method Not Allowed')
  .isEnumerable('message', 'Please, check your request method and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(MethodNotAllowed)
  .isEnumerable('code', 405)
  .isEnumerable('status', 'Method Not Allowed')
  .isEnumerable('message', 'Please, check your request method and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(MethodNotAllowed)
  .isEnumerable('code', 405)
  .isEnumerable('status', 'Method Not Allowed')
  .isEnumerable('message', 'Please, check your request method and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new MethodNotAllowed();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new MethodNotAllowed();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="methodnotallowed-get"></a>
## #get
should be a function.

```js
const test = new MethodNotAllowed();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new MethodNotAllowed();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 405)
  .hasProperty('status', 'Method Not Allowed')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 405)
  .hasProperty('status', 'Method Not Allowed')
  .hasProperty('message', 'Please, check your request method and try again.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new MethodNotAllowed();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 405)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 405)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="methodnotallowed-tojson"></a>
## #toJSON
should be a function.

```js
const test = new MethodNotAllowed();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new MethodNotAllowed();
unit
  .object(test.toJSON())
  .hasProperty('code', 405)
  .hasProperty('status', 'Method Not Allowed')
  .hasProperty('message', 'Please, check your request method and try again.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 405)
  .hasProperty('status', 'Method Not Allowed')
  .hasProperty('message', 'Please, check your request method and try again.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="methodnotallowed-tostring"></a>
## #toString
should be a function.

```js
const test = new MethodNotAllowed();
unit
  .function(test.toString);
```

should return MethodNotAllowed: 405 Method Not Allowed.

```js
const test = new MethodNotAllowed();
unit
  .string(test.toString())
  .is('MethodNotAllowed: 405 Method Not Allowed');
```

<a name="methodnotallowed-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/methodnotallowed".

```js
const test = new MethodNotAllowed();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/methodnotallowed');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new MethodNotAllowed();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/methodnotallowed]');
```

<a name="misdirectedrequest"></a>
# MisdirectedRequest
should be a function.

```js
unit
  .function(MisdirectedRequest);
```

should return an instance of MisdirectedRequest.

```js
unit
  .object(new MisdirectedRequest())
  .isInstanceOf(MisdirectedRequest)
  .isEnumerable('code', 421)
  .isEnumerable('status', 'Misdirected Request')
  .isEnumerable('message', 'Sorry, we got misdirected, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof MisdirectedRequest without the new operator.

```js
unit
  .object(MisdirectedRequest())
  .isInstanceOf(MisdirectedRequest)
  .isEnumerable('code', 421)
  .isEnumerable('status', 'Misdirected Request')
  .isEnumerable('message', 'Sorry, we got misdirected, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="misdirectedrequest-version"></a>
## #VERSION
should be a constant property.

```js
const test = new MisdirectedRequest();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="misdirectedrequest-code"></a>
## #code
should be a constant property.

```js
const test = new MisdirectedRequest();
unit
  .number(test.code)
  .is(421);
```

<a name="misdirectedrequest-status"></a>
## #status
should be a constant property.

```js
const test = new MisdirectedRequest();
unit
  .string(test.status)
  .is('Misdirected Request');
```

<a name="misdirectedrequest-message"></a>
## #message
should have a default message.

```js
const test = new MisdirectedRequest();
unit
  .string(test.message)
  .is('Sorry, we got misdirected, please try again later.');
```

should accept falsy as the default message.

```js
const test = new MisdirectedRequest();
unit
  .string(test.message)
  .is('Sorry, we got misdirected, please try again later.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Sorry, we got misdirected, please try again later.')
  .given(test.message = null)
  .string(test.message)
  .is('Sorry, we got misdirected, please try again later.')
  .given(test.message = false)
  .string(test.message)
  .is('Sorry, we got misdirected, please try again later.')
  .given(test.message = 0)
  .string(test.message)
  .is('Sorry, we got misdirected, please try again later.')
  .given(test.message = '')
  .string(test.message)
  .is('Sorry, we got misdirected, please try again later.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Sorry, we got misdirected, please try again later.');
```

should accept a string.

```js
const test = new MisdirectedRequest();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Misdirected Request')
  .string(test.message)
  .is('Misdirected Request');
```

should accept stringifiable arrays.

```js
const test = new MisdirectedRequest();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new MisdirectedRequest();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new MisdirectedRequest();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="misdirectedrequest-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new MisdirectedRequest();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new MisdirectedRequest({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="misdirectedrequest-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new MisdirectedRequest();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new MisdirectedRequest();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(MisdirectedRequest)
  .hasProperty('message', 'Bad things.');
```

<a name="misdirectedrequest-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new MisdirectedRequest();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new MisdirectedRequest({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="misdirectedrequest-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new MisdirectedRequest();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new MisdirectedRequest();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(MisdirectedRequest)
  .hasProperty('debug', 'Something happened.');
```

<a name="misdirectedrequest-getcause"></a>
## #getCause
should be a function.

```js
const test = new MisdirectedRequest();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new MisdirectedRequest({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="misdirectedrequest-setcause"></a>
## #setCause
should be a function.

```js
const test = new MisdirectedRequest();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new MisdirectedRequest();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(MisdirectedRequest)
  .hasProperty('cause', cause);
```

<a name="misdirectedrequest-set"></a>
## #set
should be a function.

```js
const test = new MisdirectedRequest();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new MisdirectedRequest();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(MisdirectedRequest)
  .isEnumerable('code', 421)
  .isEnumerable('status', 'Misdirected Request')
  .isEnumerable('message', 'Sorry, we got misdirected, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(MisdirectedRequest)
  .isEnumerable('code', 421)
  .isEnumerable('status', 'Misdirected Request')
  .isEnumerable('message', 'Sorry, we got misdirected, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(MisdirectedRequest)
  .isEnumerable('code', 421)
  .isEnumerable('status', 'Misdirected Request')
  .isEnumerable('message', 'Sorry, we got misdirected, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(MisdirectedRequest)
  .isEnumerable('code', 421)
  .isEnumerable('status', 'Misdirected Request')
  .isEnumerable('message', 'Sorry, we got misdirected, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new MisdirectedRequest();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new MisdirectedRequest();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="misdirectedrequest-get"></a>
## #get
should be a function.

```js
const test = new MisdirectedRequest();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new MisdirectedRequest();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 421)
  .hasProperty('status', 'Misdirected Request')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 421)
  .hasProperty('status', 'Misdirected Request')
  .hasProperty('message', 'Sorry, we got misdirected, please try again later.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new MisdirectedRequest();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 421)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 421)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="misdirectedrequest-tojson"></a>
## #toJSON
should be a function.

```js
const test = new MisdirectedRequest();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new MisdirectedRequest();
unit
  .object(test.toJSON())
  .hasProperty('code', 421)
  .hasProperty('status', 'Misdirected Request')
  .hasProperty('message', 'Sorry, we got misdirected, please try again later.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 421)
  .hasProperty('status', 'Misdirected Request')
  .hasProperty('message', 'Sorry, we got misdirected, please try again later.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="misdirectedrequest-tostring"></a>
## #toString
should be a function.

```js
const test = new MisdirectedRequest();
unit
  .function(test.toString);
```

should return MisdirectedRequest: 421 Misdirected Request.

```js
const test = new MisdirectedRequest();
unit
  .string(test.toString())
  .is('MisdirectedRequest: 421 Misdirected Request');
```

<a name="misdirectedrequest-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/misdirectedrequest".

```js
const test = new MisdirectedRequest();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/misdirectedrequest');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new MisdirectedRequest();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/misdirectedrequest]');
```

<a name="networkauthenticationrequired"></a>
# NetworkAuthenticationRequired
should be a function.

```js
unit
  .function(NetworkAuthenticationRequired);
```

should return an instance of NetworkAuthenticationRequired.

```js
unit
  .object(new NetworkAuthenticationRequired())
  .isInstanceOf(NetworkAuthenticationRequired)
  .isEnumerable('code', 511)
  .isEnumerable('status', 'Network Authentication Required')
  .isEnumerable('message', 'Please, authenticate with the network and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof NetworkAuthenticationRequired without the new operator.

```js
unit
  .object(NetworkAuthenticationRequired())
  .isInstanceOf(NetworkAuthenticationRequired)
  .isEnumerable('code', 511)
  .isEnumerable('status', 'Network Authentication Required')
  .isEnumerable('message', 'Please, authenticate with the network and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="networkauthenticationrequired-version"></a>
## #VERSION
should be a constant property.

```js
const test = new NetworkAuthenticationRequired();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="networkauthenticationrequired-code"></a>
## #code
should be a constant property.

```js
const test = new NetworkAuthenticationRequired();
unit
  .number(test.code)
  .is(511);
```

<a name="networkauthenticationrequired-status"></a>
## #status
should be a constant property.

```js
const test = new NetworkAuthenticationRequired();
unit
  .string(test.status)
  .is('Network Authentication Required');
```

<a name="networkauthenticationrequired-message"></a>
## #message
should have a default message.

```js
const test = new NetworkAuthenticationRequired();
unit
  .string(test.message)
  .is('Please, authenticate with the network and try again.');
```

should accept falsy as the default message.

```js
const test = new NetworkAuthenticationRequired();
unit
  .string(test.message)
  .is('Please, authenticate with the network and try again.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Please, authenticate with the network and try again.')
  .given(test.message = null)
  .string(test.message)
  .is('Please, authenticate with the network and try again.')
  .given(test.message = false)
  .string(test.message)
  .is('Please, authenticate with the network and try again.')
  .given(test.message = 0)
  .string(test.message)
  .is('Please, authenticate with the network and try again.')
  .given(test.message = '')
  .string(test.message)
  .is('Please, authenticate with the network and try again.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Please, authenticate with the network and try again.');
```

should accept a string.

```js
const test = new NetworkAuthenticationRequired();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Network Authentication Required')
  .string(test.message)
  .is('Network Authentication Required');
```

should accept stringifiable arrays.

```js
const test = new NetworkAuthenticationRequired();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new NetworkAuthenticationRequired();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new NetworkAuthenticationRequired();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="networkauthenticationrequired-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new NetworkAuthenticationRequired();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new NetworkAuthenticationRequired({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="networkauthenticationrequired-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new NetworkAuthenticationRequired();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new NetworkAuthenticationRequired();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(NetworkAuthenticationRequired)
  .hasProperty('message', 'Bad things.');
```

<a name="networkauthenticationrequired-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new NetworkAuthenticationRequired();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new NetworkAuthenticationRequired({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="networkauthenticationrequired-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new NetworkAuthenticationRequired();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new NetworkAuthenticationRequired();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(NetworkAuthenticationRequired)
  .hasProperty('debug', 'Something happened.');
```

<a name="networkauthenticationrequired-getcause"></a>
## #getCause
should be a function.

```js
const test = new NetworkAuthenticationRequired();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new NetworkAuthenticationRequired({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="networkauthenticationrequired-setcause"></a>
## #setCause
should be a function.

```js
const test = new NetworkAuthenticationRequired();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new NetworkAuthenticationRequired();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(NetworkAuthenticationRequired)
  .hasProperty('cause', cause);
```

<a name="networkauthenticationrequired-set"></a>
## #set
should be a function.

```js
const test = new NetworkAuthenticationRequired();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new NetworkAuthenticationRequired();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(NetworkAuthenticationRequired)
  .isEnumerable('code', 511)
  .isEnumerable('status', 'Network Authentication Required')
  .isEnumerable('message', 'Please, authenticate with the network and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(NetworkAuthenticationRequired)
  .isEnumerable('code', 511)
  .isEnumerable('status', 'Network Authentication Required')
  .isEnumerable('message', 'Please, authenticate with the network and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(NetworkAuthenticationRequired)
  .isEnumerable('code', 511)
  .isEnumerable('status', 'Network Authentication Required')
  .isEnumerable('message', 'Please, authenticate with the network and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(NetworkAuthenticationRequired)
  .isEnumerable('code', 511)
  .isEnumerable('status', 'Network Authentication Required')
  .isEnumerable('message', 'Please, authenticate with the network and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new NetworkAuthenticationRequired();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new NetworkAuthenticationRequired();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="networkauthenticationrequired-get"></a>
## #get
should be a function.

```js
const test = new NetworkAuthenticationRequired();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new NetworkAuthenticationRequired();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 511)
  .hasProperty('status', 'Network Authentication Required')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 511)
  .hasProperty('status', 'Network Authentication Required')
  .hasProperty('message', 'Please, authenticate with the network and try again.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new NetworkAuthenticationRequired();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 511)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 511)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="networkauthenticationrequired-tojson"></a>
## #toJSON
should be a function.

```js
const test = new NetworkAuthenticationRequired();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new NetworkAuthenticationRequired();
unit
  .object(test.toJSON())
  .hasProperty('code', 511)
  .hasProperty('status', 'Network Authentication Required')
  .hasProperty('message', 'Please, authenticate with the network and try again.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 511)
  .hasProperty('status', 'Network Authentication Required')
  .hasProperty('message', 'Please, authenticate with the network and try again.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="networkauthenticationrequired-tostring"></a>
## #toString
should be a function.

```js
const test = new NetworkAuthenticationRequired();
unit
  .function(test.toString);
```

should return NetworkAuthenticationRequired: 511 Network Authentication Required.

```js
const test = new NetworkAuthenticationRequired();
unit
  .string(test.toString())
  .is('NetworkAuthenticationRequired: 511 Network Authentication Required');
```

<a name="networkauthenticationrequired-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/networkauthenticationrequired".

```js
const test = new NetworkAuthenticationRequired();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/networkauthenticationrequired');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new NetworkAuthenticationRequired();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/networkauthenticationrequired]');
```

<a name="notacceptable"></a>
# NotAcceptable
should be a function.

```js
unit
  .function(NotAcceptable);
```

should return an instance of NotAcceptable.

```js
unit
  .object(new NotAcceptable())
  .isInstanceOf(NotAcceptable)
  .isEnumerable('code', 406)
  .isEnumerable('status', 'Not Acceptable')
  .isEnumerable('message', 'The requested document format is not supported.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof NotAcceptable without the new operator.

```js
unit
  .object(NotAcceptable())
  .isInstanceOf(NotAcceptable)
  .isEnumerable('code', 406)
  .isEnumerable('status', 'Not Acceptable')
  .isEnumerable('message', 'The requested document format is not supported.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="notacceptable-version"></a>
## #VERSION
should be a constant property.

```js
const test = new NotAcceptable();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="notacceptable-code"></a>
## #code
should be a constant property.

```js
const test = new NotAcceptable();
unit
  .number(test.code)
  .is(406);
```

<a name="notacceptable-status"></a>
## #status
should be a constant property.

```js
const test = new NotAcceptable();
unit
  .string(test.status)
  .is('Not Acceptable');
```

<a name="notacceptable-message"></a>
## #message
should have a default message.

```js
const test = new NotAcceptable();
unit
  .string(test.message)
  .is('The requested document format is not supported.');
```

should accept falsy as the default message.

```js
const test = new NotAcceptable();
unit
  .string(test.message)
  .is('The requested document format is not supported.')
  .given(test.message = undefined)
  .string(test.message)
  .is('The requested document format is not supported.')
  .given(test.message = null)
  .string(test.message)
  .is('The requested document format is not supported.')
  .given(test.message = false)
  .string(test.message)
  .is('The requested document format is not supported.')
  .given(test.message = 0)
  .string(test.message)
  .is('The requested document format is not supported.')
  .given(test.message = '')
  .string(test.message)
  .is('The requested document format is not supported.')
  .given(test.message = '     ')
  .string(test.message)
  .is('The requested document format is not supported.');
```

should accept a string.

```js
const test = new NotAcceptable();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Not Acceptable')
  .string(test.message)
  .is('Not Acceptable');
```

should accept stringifiable arrays.

```js
const test = new NotAcceptable();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new NotAcceptable();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new NotAcceptable();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="notacceptable-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new NotAcceptable();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new NotAcceptable({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="notacceptable-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new NotAcceptable();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new NotAcceptable();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(NotAcceptable)
  .hasProperty('message', 'Bad things.');
```

<a name="notacceptable-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new NotAcceptable();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new NotAcceptable({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="notacceptable-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new NotAcceptable();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new NotAcceptable();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(NotAcceptable)
  .hasProperty('debug', 'Something happened.');
```

<a name="notacceptable-getcause"></a>
## #getCause
should be a function.

```js
const test = new NotAcceptable();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new NotAcceptable({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="notacceptable-setcause"></a>
## #setCause
should be a function.

```js
const test = new NotAcceptable();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new NotAcceptable();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(NotAcceptable)
  .hasProperty('cause', cause);
```

<a name="notacceptable-set"></a>
## #set
should be a function.

```js
const test = new NotAcceptable();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new NotAcceptable();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(NotAcceptable)
  .isEnumerable('code', 406)
  .isEnumerable('status', 'Not Acceptable')
  .isEnumerable('message', 'The requested document format is not supported.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(NotAcceptable)
  .isEnumerable('code', 406)
  .isEnumerable('status', 'Not Acceptable')
  .isEnumerable('message', 'The requested document format is not supported.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(NotAcceptable)
  .isEnumerable('code', 406)
  .isEnumerable('status', 'Not Acceptable')
  .isEnumerable('message', 'The requested document format is not supported.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(NotAcceptable)
  .isEnumerable('code', 406)
  .isEnumerable('status', 'Not Acceptable')
  .isEnumerable('message', 'The requested document format is not supported.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new NotAcceptable();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new NotAcceptable();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="notacceptable-get"></a>
## #get
should be a function.

```js
const test = new NotAcceptable();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new NotAcceptable();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 406)
  .hasProperty('status', 'Not Acceptable')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 406)
  .hasProperty('status', 'Not Acceptable')
  .hasProperty('message', 'The requested document format is not supported.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new NotAcceptable();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 406)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 406)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="notacceptable-tojson"></a>
## #toJSON
should be a function.

```js
const test = new NotAcceptable();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new NotAcceptable();
unit
  .object(test.toJSON())
  .hasProperty('code', 406)
  .hasProperty('status', 'Not Acceptable')
  .hasProperty('message', 'The requested document format is not supported.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 406)
  .hasProperty('status', 'Not Acceptable')
  .hasProperty('message', 'The requested document format is not supported.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="notacceptable-tostring"></a>
## #toString
should be a function.

```js
const test = new NotAcceptable();
unit
  .function(test.toString);
```

should return NotAcceptable: 406 Not Acceptable.

```js
const test = new NotAcceptable();
unit
  .string(test.toString())
  .is('NotAcceptable: 406 Not Acceptable');
```

<a name="notacceptable-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/notacceptable".

```js
const test = new NotAcceptable();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/notacceptable');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new NotAcceptable();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/notacceptable]');
```

<a name="notextended"></a>
# NotExtended
should be a function.

```js
unit
  .function(NotExtended);
```

should return an instance of NotExtended.

```js
unit
  .object(new NotExtended())
  .isInstanceOf(NotExtended)
  .isEnumerable('code', 510)
  .isEnumerable('status', 'Not Extended')
  .isEnumerable('message', 'The policy for accessing this resource has not been met by this request.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof NotExtended without the new operator.

```js
unit
  .object(NotExtended())
  .isInstanceOf(NotExtended)
  .isEnumerable('code', 510)
  .isEnumerable('status', 'Not Extended')
  .isEnumerable('message', 'The policy for accessing this resource has not been met by this request.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="notextended-version"></a>
## #VERSION
should be a constant property.

```js
const test = new NotExtended();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="notextended-code"></a>
## #code
should be a constant property.

```js
const test = new NotExtended();
unit
  .number(test.code)
  .is(510);
```

<a name="notextended-status"></a>
## #status
should be a constant property.

```js
const test = new NotExtended();
unit
  .string(test.status)
  .is('Not Extended');
```

<a name="notextended-message"></a>
## #message
should have a default message.

```js
const test = new NotExtended();
unit
  .string(test.message)
  .is('The policy for accessing this resource has not been met by this request.');
```

should accept falsy as the default message.

```js
const test = new NotExtended();
unit
  .string(test.message)
  .is('The policy for accessing this resource has not been met by this request.')
  .given(test.message = undefined)
  .string(test.message)
  .is('The policy for accessing this resource has not been met by this request.')
  .given(test.message = null)
  .string(test.message)
  .is('The policy for accessing this resource has not been met by this request.')
  .given(test.message = false)
  .string(test.message)
  .is('The policy for accessing this resource has not been met by this request.')
  .given(test.message = 0)
  .string(test.message)
  .is('The policy for accessing this resource has not been met by this request.')
  .given(test.message = '')
  .string(test.message)
  .is('The policy for accessing this resource has not been met by this request.')
  .given(test.message = '     ')
  .string(test.message)
  .is('The policy for accessing this resource has not been met by this request.');
```

should accept a string.

```js
const test = new NotExtended();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Not Extended')
  .string(test.message)
  .is('Not Extended');
```

should accept stringifiable arrays.

```js
const test = new NotExtended();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new NotExtended();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new NotExtended();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="notextended-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new NotExtended();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new NotExtended({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="notextended-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new NotExtended();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new NotExtended();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(NotExtended)
  .hasProperty('message', 'Bad things.');
```

<a name="notextended-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new NotExtended();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new NotExtended({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="notextended-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new NotExtended();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new NotExtended();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(NotExtended)
  .hasProperty('debug', 'Something happened.');
```

<a name="notextended-getcause"></a>
## #getCause
should be a function.

```js
const test = new NotExtended();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new NotExtended({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="notextended-setcause"></a>
## #setCause
should be a function.

```js
const test = new NotExtended();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new NotExtended();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(NotExtended)
  .hasProperty('cause', cause);
```

<a name="notextended-set"></a>
## #set
should be a function.

```js
const test = new NotExtended();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new NotExtended();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(NotExtended)
  .isEnumerable('code', 510)
  .isEnumerable('status', 'Not Extended')
  .isEnumerable('message', 'The policy for accessing this resource has not been met by this request.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(NotExtended)
  .isEnumerable('code', 510)
  .isEnumerable('status', 'Not Extended')
  .isEnumerable('message', 'The policy for accessing this resource has not been met by this request.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(NotExtended)
  .isEnumerable('code', 510)
  .isEnumerable('status', 'Not Extended')
  .isEnumerable('message', 'The policy for accessing this resource has not been met by this request.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(NotExtended)
  .isEnumerable('code', 510)
  .isEnumerable('status', 'Not Extended')
  .isEnumerable('message', 'The policy for accessing this resource has not been met by this request.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new NotExtended();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new NotExtended();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="notextended-get"></a>
## #get
should be a function.

```js
const test = new NotExtended();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new NotExtended();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 510)
  .hasProperty('status', 'Not Extended')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 510)
  .hasProperty('status', 'Not Extended')
  .hasProperty('message', 'The policy for accessing this resource has not been met by this request.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new NotExtended();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 510)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 510)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="notextended-tojson"></a>
## #toJSON
should be a function.

```js
const test = new NotExtended();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new NotExtended();
unit
  .object(test.toJSON())
  .hasProperty('code', 510)
  .hasProperty('status', 'Not Extended')
  .hasProperty('message', 'The policy for accessing this resource has not been met by this request.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 510)
  .hasProperty('status', 'Not Extended')
  .hasProperty('message', 'The policy for accessing this resource has not been met by this request.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="notextended-tostring"></a>
## #toString
should be a function.

```js
const test = new NotExtended();
unit
  .function(test.toString);
```

should return NotExtended: 510 Not Extended.

```js
const test = new NotExtended();
unit
  .string(test.toString())
  .is('NotExtended: 510 Not Extended');
```

<a name="notextended-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/notextended".

```js
const test = new NotExtended();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/notextended');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new NotExtended();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/notextended]');
```

<a name="notfound"></a>
# NotFound
should be a function.

```js
unit
  .function(NotFound);
```

should return an instance of NotFound.

```js
unit
  .object(new NotFound())
  .isInstanceOf(NotFound)
  .isEnumerable('code', 404)
  .isEnumerable('status', 'Not Found')
  .isEnumerable('message', 'The requested document was not found.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof NotFound without the new operator.

```js
unit
  .object(NotFound())
  .isInstanceOf(NotFound)
  .isEnumerable('code', 404)
  .isEnumerable('status', 'Not Found')
  .isEnumerable('message', 'The requested document was not found.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="notfound-version"></a>
## #VERSION
should be a constant property.

```js
const test = new NotFound();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="notfound-code"></a>
## #code
should be a constant property.

```js
const test = new NotFound();
unit
  .number(test.code)
  .is(404);
```

<a name="notfound-status"></a>
## #status
should be a constant property.

```js
const test = new NotFound();
unit
  .string(test.status)
  .is('Not Found');
```

<a name="notfound-message"></a>
## #message
should have a default message.

```js
const test = new NotFound();
unit
  .string(test.message)
  .is('The requested document was not found.');
```

should accept falsy as the default message.

```js
const test = new NotFound();
unit
  .string(test.message)
  .is('The requested document was not found.')
  .given(test.message = undefined)
  .string(test.message)
  .is('The requested document was not found.')
  .given(test.message = null)
  .string(test.message)
  .is('The requested document was not found.')
  .given(test.message = false)
  .string(test.message)
  .is('The requested document was not found.')
  .given(test.message = 0)
  .string(test.message)
  .is('The requested document was not found.')
  .given(test.message = '')
  .string(test.message)
  .is('The requested document was not found.')
  .given(test.message = '     ')
  .string(test.message)
  .is('The requested document was not found.');
```

should accept a string.

```js
const test = new NotFound();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Not Found')
  .string(test.message)
  .is('Not Found');
```

should accept stringifiable arrays.

```js
const test = new NotFound();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new NotFound();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new NotFound();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="notfound-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new NotFound();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new NotFound({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="notfound-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new NotFound();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new NotFound();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(NotFound)
  .hasProperty('message', 'Bad things.');
```

<a name="notfound-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new NotFound();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new NotFound({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="notfound-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new NotFound();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new NotFound();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(NotFound)
  .hasProperty('debug', 'Something happened.');
```

<a name="notfound-getcause"></a>
## #getCause
should be a function.

```js
const test = new NotFound();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new NotFound({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="notfound-setcause"></a>
## #setCause
should be a function.

```js
const test = new NotFound();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new NotFound();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(NotFound)
  .hasProperty('cause', cause);
```

<a name="notfound-set"></a>
## #set
should be a function.

```js
const test = new NotFound();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new NotFound();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(NotFound)
  .isEnumerable('code', 404)
  .isEnumerable('status', 'Not Found')
  .isEnumerable('message', 'The requested document was not found.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(NotFound)
  .isEnumerable('code', 404)
  .isEnumerable('status', 'Not Found')
  .isEnumerable('message', 'The requested document was not found.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(NotFound)
  .isEnumerable('code', 404)
  .isEnumerable('status', 'Not Found')
  .isEnumerable('message', 'The requested document was not found.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(NotFound)
  .isEnumerable('code', 404)
  .isEnumerable('status', 'Not Found')
  .isEnumerable('message', 'The requested document was not found.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new NotFound();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new NotFound();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="notfound-get"></a>
## #get
should be a function.

```js
const test = new NotFound();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new NotFound();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 404)
  .hasProperty('status', 'Not Found')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 404)
  .hasProperty('status', 'Not Found')
  .hasProperty('message', 'The requested document was not found.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new NotFound();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 404)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 404)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="notfound-tojson"></a>
## #toJSON
should be a function.

```js
const test = new NotFound();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new NotFound();
unit
  .object(test.toJSON())
  .hasProperty('code', 404)
  .hasProperty('status', 'Not Found')
  .hasProperty('message', 'The requested document was not found.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 404)
  .hasProperty('status', 'Not Found')
  .hasProperty('message', 'The requested document was not found.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="notfound-tostring"></a>
## #toString
should be a function.

```js
const test = new NotFound();
unit
  .function(test.toString);
```

should return NotFound: 404 Not Found.

```js
const test = new NotFound();
unit
  .string(test.toString())
  .is('NotFound: 404 Not Found');
```

<a name="notfound-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/notfound".

```js
const test = new NotFound();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/notfound');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new NotFound();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/notfound]');
```

<a name="notimplemented"></a>
# NotImplemented
should be a function.

```js
unit
  .function(NotImplemented);
```

should return an instance of NotImplemented.

```js
unit
  .object(new NotImplemented())
  .isInstanceOf(NotImplemented)
  .isEnumerable('code', 501)
  .isEnumerable('status', 'Not Implemented')
  .isEnumerable('message', 'Sorry, this is not fully implemented, please try later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof NotImplemented without the new operator.

```js
unit
  .object(NotImplemented())
  .isInstanceOf(NotImplemented)
  .isEnumerable('code', 501)
  .isEnumerable('status', 'Not Implemented')
  .isEnumerable('message', 'Sorry, this is not fully implemented, please try later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="notimplemented-version"></a>
## #VERSION
should be a constant property.

```js
const test = new NotImplemented();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="notimplemented-code"></a>
## #code
should be a constant property.

```js
const test = new NotImplemented();
unit
  .number(test.code)
  .is(501);
```

<a name="notimplemented-status"></a>
## #status
should be a constant property.

```js
const test = new NotImplemented();
unit
  .string(test.status)
  .is('Not Implemented');
```

<a name="notimplemented-message"></a>
## #message
should have a default message.

```js
const test = new NotImplemented();
unit
  .string(test.message)
  .is('Sorry, this is not fully implemented, please try later.');
```

should accept falsy as the default message.

```js
const test = new NotImplemented();
unit
  .string(test.message)
  .is('Sorry, this is not fully implemented, please try later.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Sorry, this is not fully implemented, please try later.')
  .given(test.message = null)
  .string(test.message)
  .is('Sorry, this is not fully implemented, please try later.')
  .given(test.message = false)
  .string(test.message)
  .is('Sorry, this is not fully implemented, please try later.')
  .given(test.message = 0)
  .string(test.message)
  .is('Sorry, this is not fully implemented, please try later.')
  .given(test.message = '')
  .string(test.message)
  .is('Sorry, this is not fully implemented, please try later.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Sorry, this is not fully implemented, please try later.');
```

should accept a string.

```js
const test = new NotImplemented();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Not Implemented')
  .string(test.message)
  .is('Not Implemented');
```

should accept stringifiable arrays.

```js
const test = new NotImplemented();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new NotImplemented();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new NotImplemented();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="notimplemented-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new NotImplemented();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new NotImplemented({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="notimplemented-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new NotImplemented();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new NotImplemented();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(NotImplemented)
  .hasProperty('message', 'Bad things.');
```

<a name="notimplemented-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new NotImplemented();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new NotImplemented({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="notimplemented-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new NotImplemented();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new NotImplemented();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(NotImplemented)
  .hasProperty('debug', 'Something happened.');
```

<a name="notimplemented-getcause"></a>
## #getCause
should be a function.

```js
const test = new NotImplemented();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new NotImplemented({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="notimplemented-setcause"></a>
## #setCause
should be a function.

```js
const test = new NotImplemented();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new NotImplemented();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(NotImplemented)
  .hasProperty('cause', cause);
```

<a name="notimplemented-set"></a>
## #set
should be a function.

```js
const test = new NotImplemented();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new NotImplemented();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(NotImplemented)
  .isEnumerable('code', 501)
  .isEnumerable('status', 'Not Implemented')
  .isEnumerable('message', 'Sorry, this is not fully implemented, please try later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(NotImplemented)
  .isEnumerable('code', 501)
  .isEnumerable('status', 'Not Implemented')
  .isEnumerable('message', 'Sorry, this is not fully implemented, please try later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(NotImplemented)
  .isEnumerable('code', 501)
  .isEnumerable('status', 'Not Implemented')
  .isEnumerable('message', 'Sorry, this is not fully implemented, please try later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(NotImplemented)
  .isEnumerable('code', 501)
  .isEnumerable('status', 'Not Implemented')
  .isEnumerable('message', 'Sorry, this is not fully implemented, please try later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new NotImplemented();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new NotImplemented();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="notimplemented-get"></a>
## #get
should be a function.

```js
const test = new NotImplemented();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new NotImplemented();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 501)
  .hasProperty('status', 'Not Implemented')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 501)
  .hasProperty('status', 'Not Implemented')
  .hasProperty('message', 'Sorry, this is not fully implemented, please try later.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new NotImplemented();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 501)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 501)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="notimplemented-tojson"></a>
## #toJSON
should be a function.

```js
const test = new NotImplemented();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new NotImplemented();
unit
  .object(test.toJSON())
  .hasProperty('code', 501)
  .hasProperty('status', 'Not Implemented')
  .hasProperty('message', 'Sorry, this is not fully implemented, please try later.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 501)
  .hasProperty('status', 'Not Implemented')
  .hasProperty('message', 'Sorry, this is not fully implemented, please try later.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="notimplemented-tostring"></a>
## #toString
should be a function.

```js
const test = new NotImplemented();
unit
  .function(test.toString);
```

should return NotImplemented: 501 Not Implemented.

```js
const test = new NotImplemented();
unit
  .string(test.toString())
  .is('NotImplemented: 501 Not Implemented');
```

<a name="notimplemented-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/notimplemented".

```js
const test = new NotImplemented();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/notimplemented');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new NotImplemented();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/notimplemented]');
```

<a name="payloadtoolarge"></a>
# PayloadTooLarge
should be a function.

```js
unit
  .function(PayloadTooLarge);
```

should return an instance of PayloadTooLarge.

```js
unit
  .object(new PayloadTooLarge())
  .isInstanceOf(PayloadTooLarge)
  .isEnumerable('code', 413)
  .isEnumerable('status', 'Payload Too Large')
  .isEnumerable('message', 'Request payload is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof PayloadTooLarge without the new operator.

```js
unit
  .object(PayloadTooLarge())
  .isInstanceOf(PayloadTooLarge)
  .isEnumerable('code', 413)
  .isEnumerable('status', 'Payload Too Large')
  .isEnumerable('message', 'Request payload is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="payloadtoolarge-version"></a>
## #VERSION
should be a constant property.

```js
const test = new PayloadTooLarge();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="payloadtoolarge-code"></a>
## #code
should be a constant property.

```js
const test = new PayloadTooLarge();
unit
  .number(test.code)
  .is(413);
```

<a name="payloadtoolarge-status"></a>
## #status
should be a constant property.

```js
const test = new PayloadTooLarge();
unit
  .string(test.status)
  .is('Payload Too Large');
```

<a name="payloadtoolarge-message"></a>
## #message
should have a default message.

```js
const test = new PayloadTooLarge();
unit
  .string(test.message)
  .is('Request payload is too large and can not be processed.');
```

should accept falsy as the default message.

```js
const test = new PayloadTooLarge();
unit
  .string(test.message)
  .is('Request payload is too large and can not be processed.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Request payload is too large and can not be processed.')
  .given(test.message = null)
  .string(test.message)
  .is('Request payload is too large and can not be processed.')
  .given(test.message = false)
  .string(test.message)
  .is('Request payload is too large and can not be processed.')
  .given(test.message = 0)
  .string(test.message)
  .is('Request payload is too large and can not be processed.')
  .given(test.message = '')
  .string(test.message)
  .is('Request payload is too large and can not be processed.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Request payload is too large and can not be processed.');
```

should accept a string.

```js
const test = new PayloadTooLarge();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Payload Too Large')
  .string(test.message)
  .is('Payload Too Large');
```

should accept stringifiable arrays.

```js
const test = new PayloadTooLarge();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new PayloadTooLarge();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new PayloadTooLarge();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="payloadtoolarge-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new PayloadTooLarge();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new PayloadTooLarge({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="payloadtoolarge-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new PayloadTooLarge();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new PayloadTooLarge();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(PayloadTooLarge)
  .hasProperty('message', 'Bad things.');
```

<a name="payloadtoolarge-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new PayloadTooLarge();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new PayloadTooLarge({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="payloadtoolarge-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new PayloadTooLarge();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new PayloadTooLarge();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(PayloadTooLarge)
  .hasProperty('debug', 'Something happened.');
```

<a name="payloadtoolarge-getcause"></a>
## #getCause
should be a function.

```js
const test = new PayloadTooLarge();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new PayloadTooLarge({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="payloadtoolarge-setcause"></a>
## #setCause
should be a function.

```js
const test = new PayloadTooLarge();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new PayloadTooLarge();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(PayloadTooLarge)
  .hasProperty('cause', cause);
```

<a name="payloadtoolarge-set"></a>
## #set
should be a function.

```js
const test = new PayloadTooLarge();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new PayloadTooLarge();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(PayloadTooLarge)
  .isEnumerable('code', 413)
  .isEnumerable('status', 'Payload Too Large')
  .isEnumerable('message', 'Request payload is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(PayloadTooLarge)
  .isEnumerable('code', 413)
  .isEnumerable('status', 'Payload Too Large')
  .isEnumerable('message', 'Request payload is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(PayloadTooLarge)
  .isEnumerable('code', 413)
  .isEnumerable('status', 'Payload Too Large')
  .isEnumerable('message', 'Request payload is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(PayloadTooLarge)
  .isEnumerable('code', 413)
  .isEnumerable('status', 'Payload Too Large')
  .isEnumerable('message', 'Request payload is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new PayloadTooLarge();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new PayloadTooLarge();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="payloadtoolarge-get"></a>
## #get
should be a function.

```js
const test = new PayloadTooLarge();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new PayloadTooLarge();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 413)
  .hasProperty('status', 'Payload Too Large')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 413)
  .hasProperty('status', 'Payload Too Large')
  .hasProperty('message', 'Request payload is too large and can not be processed.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new PayloadTooLarge();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 413)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 413)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="payloadtoolarge-tojson"></a>
## #toJSON
should be a function.

```js
const test = new PayloadTooLarge();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new PayloadTooLarge();
unit
  .object(test.toJSON())
  .hasProperty('code', 413)
  .hasProperty('status', 'Payload Too Large')
  .hasProperty('message', 'Request payload is too large and can not be processed.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 413)
  .hasProperty('status', 'Payload Too Large')
  .hasProperty('message', 'Request payload is too large and can not be processed.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="payloadtoolarge-tostring"></a>
## #toString
should be a function.

```js
const test = new PayloadTooLarge();
unit
  .function(test.toString);
```

should return PayloadTooLarge: 413 Payload Too Large.

```js
const test = new PayloadTooLarge();
unit
  .string(test.toString())
  .is('PayloadTooLarge: 413 Payload Too Large');
```

<a name="payloadtoolarge-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/payloadtoolarge".

```js
const test = new PayloadTooLarge();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/payloadtoolarge');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new PayloadTooLarge();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/payloadtoolarge]');
```

<a name="paymentrequired"></a>
# PaymentRequired
should be a function.

```js
unit
  .function(PaymentRequired);
```

should return an instance of PaymentRequired.

```js
unit
  .object(new PaymentRequired())
  .isInstanceOf(PaymentRequired)
  .isEnumerable('code', 402)
  .isEnumerable('status', 'Payment Required')
  .isEnumerable('message', 'Payment is required to use this service.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof PaymentRequired without the new operator.

```js
unit
  .object(PaymentRequired())
  .isInstanceOf(PaymentRequired)
  .isEnumerable('code', 402)
  .isEnumerable('status', 'Payment Required')
  .isEnumerable('message', 'Payment is required to use this service.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="paymentrequired-version"></a>
## #VERSION
should be a constant property.

```js
const test = new PaymentRequired();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="paymentrequired-code"></a>
## #code
should be a constant property.

```js
const test = new PaymentRequired();
unit
  .number(test.code)
  .is(402);
```

<a name="paymentrequired-status"></a>
## #status
should be a constant property.

```js
const test = new PaymentRequired();
unit
  .string(test.status)
  .is('Payment Required');
```

<a name="paymentrequired-message"></a>
## #message
should have a default message.

```js
const test = new PaymentRequired();
unit
  .string(test.message)
  .is('Payment is required to use this service.');
```

should accept falsy as the default message.

```js
const test = new PaymentRequired();
unit
  .string(test.message)
  .is('Payment is required to use this service.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Payment is required to use this service.')
  .given(test.message = null)
  .string(test.message)
  .is('Payment is required to use this service.')
  .given(test.message = false)
  .string(test.message)
  .is('Payment is required to use this service.')
  .given(test.message = 0)
  .string(test.message)
  .is('Payment is required to use this service.')
  .given(test.message = '')
  .string(test.message)
  .is('Payment is required to use this service.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Payment is required to use this service.');
```

should accept a string.

```js
const test = new PaymentRequired();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Payment Required')
  .string(test.message)
  .is('Payment Required');
```

should accept stringifiable arrays.

```js
const test = new PaymentRequired();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new PaymentRequired();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new PaymentRequired();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="paymentrequired-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new PaymentRequired();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new PaymentRequired({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="paymentrequired-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new PaymentRequired();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new PaymentRequired();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(PaymentRequired)
  .hasProperty('message', 'Bad things.');
```

<a name="paymentrequired-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new PaymentRequired();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new PaymentRequired({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="paymentrequired-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new PaymentRequired();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new PaymentRequired();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(PaymentRequired)
  .hasProperty('debug', 'Something happened.');
```

<a name="paymentrequired-getcause"></a>
## #getCause
should be a function.

```js
const test = new PaymentRequired();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new PaymentRequired({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="paymentrequired-setcause"></a>
## #setCause
should be a function.

```js
const test = new PaymentRequired();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new PaymentRequired();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(PaymentRequired)
  .hasProperty('cause', cause);
```

<a name="paymentrequired-set"></a>
## #set
should be a function.

```js
const test = new PaymentRequired();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new PaymentRequired();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(PaymentRequired)
  .isEnumerable('code', 402)
  .isEnumerable('status', 'Payment Required')
  .isEnumerable('message', 'Payment is required to use this service.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(PaymentRequired)
  .isEnumerable('code', 402)
  .isEnumerable('status', 'Payment Required')
  .isEnumerable('message', 'Payment is required to use this service.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(PaymentRequired)
  .isEnumerable('code', 402)
  .isEnumerable('status', 'Payment Required')
  .isEnumerable('message', 'Payment is required to use this service.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(PaymentRequired)
  .isEnumerable('code', 402)
  .isEnumerable('status', 'Payment Required')
  .isEnumerable('message', 'Payment is required to use this service.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new PaymentRequired();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new PaymentRequired();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="paymentrequired-get"></a>
## #get
should be a function.

```js
const test = new PaymentRequired();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new PaymentRequired();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 402)
  .hasProperty('status', 'Payment Required')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 402)
  .hasProperty('status', 'Payment Required')
  .hasProperty('message', 'Payment is required to use this service.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new PaymentRequired();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 402)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 402)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="paymentrequired-tojson"></a>
## #toJSON
should be a function.

```js
const test = new PaymentRequired();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new PaymentRequired();
unit
  .object(test.toJSON())
  .hasProperty('code', 402)
  .hasProperty('status', 'Payment Required')
  .hasProperty('message', 'Payment is required to use this service.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 402)
  .hasProperty('status', 'Payment Required')
  .hasProperty('message', 'Payment is required to use this service.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="paymentrequired-tostring"></a>
## #toString
should be a function.

```js
const test = new PaymentRequired();
unit
  .function(test.toString);
```

should return PaymentRequired: 402 Payment Required.

```js
const test = new PaymentRequired();
unit
  .string(test.toString())
  .is('PaymentRequired: 402 Payment Required');
```

<a name="paymentrequired-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/paymentrequired".

```js
const test = new PaymentRequired();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/paymentrequired');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new PaymentRequired();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/paymentrequired]');
```

<a name="preconditionfailed"></a>
# PreconditionFailed
should be a function.

```js
unit
  .function(PreconditionFailed);
```

should return an instance of PreconditionFailed.

```js
unit
  .object(new PreconditionFailed())
  .isInstanceOf(PreconditionFailed)
  .isEnumerable('code', 412)
  .isEnumerable('status', 'Precondition Failed')
  .isEnumerable('message', 'Sorry, it appears 1 or more preconditions on the request have changed, please correct and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof PreconditionFailed without the new operator.

```js
unit
  .object(PreconditionFailed())
  .isInstanceOf(PreconditionFailed)
  .isEnumerable('code', 412)
  .isEnumerable('status', 'Precondition Failed')
  .isEnumerable('message', 'Sorry, it appears 1 or more preconditions on the request have changed, please correct and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="preconditionfailed-version"></a>
## #VERSION
should be a constant property.

```js
const test = new PreconditionFailed();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="preconditionfailed-code"></a>
## #code
should be a constant property.

```js
const test = new PreconditionFailed();
unit
  .number(test.code)
  .is(412);
```

<a name="preconditionfailed-status"></a>
## #status
should be a constant property.

```js
const test = new PreconditionFailed();
unit
  .string(test.status)
  .is('Precondition Failed');
```

<a name="preconditionfailed-message"></a>
## #message
should have a default message.

```js
const test = new PreconditionFailed();
unit
  .string(test.message)
  .is('Sorry, it appears 1 or more preconditions on the request have changed, please correct and try again.');
```

should accept falsy as the default message.

```js
const test = new PreconditionFailed();
unit
  .string(test.message)
  .is('Sorry, it appears 1 or more preconditions on the request have changed, please correct and try again.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Sorry, it appears 1 or more preconditions on the request have changed, please correct and try again.')
  .given(test.message = null)
  .string(test.message)
  .is('Sorry, it appears 1 or more preconditions on the request have changed, please correct and try again.')
  .given(test.message = false)
  .string(test.message)
  .is('Sorry, it appears 1 or more preconditions on the request have changed, please correct and try again.')
  .given(test.message = 0)
  .string(test.message)
  .is('Sorry, it appears 1 or more preconditions on the request have changed, please correct and try again.')
  .given(test.message = '')
  .string(test.message)
  .is('Sorry, it appears 1 or more preconditions on the request have changed, please correct and try again.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Sorry, it appears 1 or more preconditions on the request have changed, please correct and try again.');
```

should accept a string.

```js
const test = new PreconditionFailed();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Precondition Failed')
  .string(test.message)
  .is('Precondition Failed');
```

should accept stringifiable arrays.

```js
const test = new PreconditionFailed();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new PreconditionFailed();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new PreconditionFailed();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="preconditionfailed-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new PreconditionFailed();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new PreconditionFailed({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="preconditionfailed-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new PreconditionFailed();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new PreconditionFailed();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(PreconditionFailed)
  .hasProperty('message', 'Bad things.');
```

<a name="preconditionfailed-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new PreconditionFailed();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new PreconditionFailed({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="preconditionfailed-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new PreconditionFailed();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new PreconditionFailed();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(PreconditionFailed)
  .hasProperty('debug', 'Something happened.');
```

<a name="preconditionfailed-getcause"></a>
## #getCause
should be a function.

```js
const test = new PreconditionFailed();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new PreconditionFailed({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="preconditionfailed-setcause"></a>
## #setCause
should be a function.

```js
const test = new PreconditionFailed();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new PreconditionFailed();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(PreconditionFailed)
  .hasProperty('cause', cause);
```

<a name="preconditionfailed-set"></a>
## #set
should be a function.

```js
const test = new PreconditionFailed();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new PreconditionFailed();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(PreconditionFailed)
  .isEnumerable('code', 412)
  .isEnumerable('status', 'Precondition Failed')
  .isEnumerable('message', 'Sorry, it appears 1 or more preconditions on the request have changed, please correct and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(PreconditionFailed)
  .isEnumerable('code', 412)
  .isEnumerable('status', 'Precondition Failed')
  .isEnumerable('message', 'Sorry, it appears 1 or more preconditions on the request have changed, please correct and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(PreconditionFailed)
  .isEnumerable('code', 412)
  .isEnumerable('status', 'Precondition Failed')
  .isEnumerable('message', 'Sorry, it appears 1 or more preconditions on the request have changed, please correct and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(PreconditionFailed)
  .isEnumerable('code', 412)
  .isEnumerable('status', 'Precondition Failed')
  .isEnumerable('message', 'Sorry, it appears 1 or more preconditions on the request have changed, please correct and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new PreconditionFailed();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new PreconditionFailed();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="preconditionfailed-get"></a>
## #get
should be a function.

```js
const test = new PreconditionFailed();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new PreconditionFailed();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 412)
  .hasProperty('status', 'Precondition Failed')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 412)
  .hasProperty('status', 'Precondition Failed')
  .hasProperty('message', 'Sorry, it appears 1 or more preconditions on the request have changed, please correct and try again.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new PreconditionFailed();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 412)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 412)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="preconditionfailed-tojson"></a>
## #toJSON
should be a function.

```js
const test = new PreconditionFailed();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new PreconditionFailed();
unit
  .object(test.toJSON())
  .hasProperty('code', 412)
  .hasProperty('status', 'Precondition Failed')
  .hasProperty('message', 'Sorry, it appears 1 or more preconditions on the request have changed, please correct and try again.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 412)
  .hasProperty('status', 'Precondition Failed')
  .hasProperty('message', 'Sorry, it appears 1 or more preconditions on the request have changed, please correct and try again.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="preconditionfailed-tostring"></a>
## #toString
should be a function.

```js
const test = new PreconditionFailed();
unit
  .function(test.toString);
```

should return PreconditionFailed: 412 Precondition Failed.

```js
const test = new PreconditionFailed();
unit
  .string(test.toString())
  .is('PreconditionFailed: 412 Precondition Failed');
```

<a name="preconditionfailed-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/preconditionfailed".

```js
const test = new PreconditionFailed();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/preconditionfailed');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new PreconditionFailed();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/preconditionfailed]');
```

<a name="preconditionrequired"></a>
# PreconditionRequired
should be a function.

```js
unit
  .function(PreconditionRequired);
```

should return an instance of PreconditionRequired.

```js
unit
  .object(new PreconditionRequired())
  .isInstanceOf(PreconditionRequired)
  .isEnumerable('code', 428)
  .isEnumerable('status', 'Precondition Required')
  .isEnumerable('message', 'Please, add preconditions to your request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof PreconditionRequired without the new operator.

```js
unit
  .object(PreconditionRequired())
  .isInstanceOf(PreconditionRequired)
  .isEnumerable('code', 428)
  .isEnumerable('status', 'Precondition Required')
  .isEnumerable('message', 'Please, add preconditions to your request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="preconditionrequired-version"></a>
## #VERSION
should be a constant property.

```js
const test = new PreconditionRequired();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="preconditionrequired-code"></a>
## #code
should be a constant property.

```js
const test = new PreconditionRequired();
unit
  .number(test.code)
  .is(428);
```

<a name="preconditionrequired-status"></a>
## #status
should be a constant property.

```js
const test = new PreconditionRequired();
unit
  .string(test.status)
  .is('Precondition Required');
```

<a name="preconditionrequired-message"></a>
## #message
should have a default message.

```js
const test = new PreconditionRequired();
unit
  .string(test.message)
  .is('Please, add preconditions to your request and try again.');
```

should accept falsy as the default message.

```js
const test = new PreconditionRequired();
unit
  .string(test.message)
  .is('Please, add preconditions to your request and try again.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Please, add preconditions to your request and try again.')
  .given(test.message = null)
  .string(test.message)
  .is('Please, add preconditions to your request and try again.')
  .given(test.message = false)
  .string(test.message)
  .is('Please, add preconditions to your request and try again.')
  .given(test.message = 0)
  .string(test.message)
  .is('Please, add preconditions to your request and try again.')
  .given(test.message = '')
  .string(test.message)
  .is('Please, add preconditions to your request and try again.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Please, add preconditions to your request and try again.');
```

should accept a string.

```js
const test = new PreconditionRequired();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Precondition Required')
  .string(test.message)
  .is('Precondition Required');
```

should accept stringifiable arrays.

```js
const test = new PreconditionRequired();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new PreconditionRequired();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new PreconditionRequired();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="preconditionrequired-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new PreconditionRequired();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new PreconditionRequired({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="preconditionrequired-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new PreconditionRequired();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new PreconditionRequired();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(PreconditionRequired)
  .hasProperty('message', 'Bad things.');
```

<a name="preconditionrequired-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new PreconditionRequired();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new PreconditionRequired({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="preconditionrequired-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new PreconditionRequired();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new PreconditionRequired();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(PreconditionRequired)
  .hasProperty('debug', 'Something happened.');
```

<a name="preconditionrequired-getcause"></a>
## #getCause
should be a function.

```js
const test = new PreconditionRequired();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new PreconditionRequired({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="preconditionrequired-setcause"></a>
## #setCause
should be a function.

```js
const test = new PreconditionRequired();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new PreconditionRequired();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(PreconditionRequired)
  .hasProperty('cause', cause);
```

<a name="preconditionrequired-set"></a>
## #set
should be a function.

```js
const test = new PreconditionRequired();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new PreconditionRequired();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(PreconditionRequired)
  .isEnumerable('code', 428)
  .isEnumerable('status', 'Precondition Required')
  .isEnumerable('message', 'Please, add preconditions to your request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(PreconditionRequired)
  .isEnumerable('code', 428)
  .isEnumerable('status', 'Precondition Required')
  .isEnumerable('message', 'Please, add preconditions to your request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(PreconditionRequired)
  .isEnumerable('code', 428)
  .isEnumerable('status', 'Precondition Required')
  .isEnumerable('message', 'Please, add preconditions to your request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(PreconditionRequired)
  .isEnumerable('code', 428)
  .isEnumerable('status', 'Precondition Required')
  .isEnumerable('message', 'Please, add preconditions to your request and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new PreconditionRequired();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new PreconditionRequired();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="preconditionrequired-get"></a>
## #get
should be a function.

```js
const test = new PreconditionRequired();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new PreconditionRequired();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 428)
  .hasProperty('status', 'Precondition Required')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 428)
  .hasProperty('status', 'Precondition Required')
  .hasProperty('message', 'Please, add preconditions to your request and try again.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new PreconditionRequired();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 428)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 428)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="preconditionrequired-tojson"></a>
## #toJSON
should be a function.

```js
const test = new PreconditionRequired();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new PreconditionRequired();
unit
  .object(test.toJSON())
  .hasProperty('code', 428)
  .hasProperty('status', 'Precondition Required')
  .hasProperty('message', 'Please, add preconditions to your request and try again.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 428)
  .hasProperty('status', 'Precondition Required')
  .hasProperty('message', 'Please, add preconditions to your request and try again.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="preconditionrequired-tostring"></a>
## #toString
should be a function.

```js
const test = new PreconditionRequired();
unit
  .function(test.toString);
```

should return PreconditionRequired: 428 Precondition Required.

```js
const test = new PreconditionRequired();
unit
  .string(test.toString())
  .is('PreconditionRequired: 428 Precondition Required');
```

<a name="preconditionrequired-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/preconditionrequired".

```js
const test = new PreconditionRequired();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/preconditionrequired');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new PreconditionRequired();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/preconditionrequired]');
```

<a name="proxyauthenticationrequired"></a>
# ProxyAuthenticationRequired
should be a function.

```js
unit
  .function(ProxyAuthenticationRequired);
```

should return an instance of ProxyAuthenticationRequired.

```js
unit
  .object(new ProxyAuthenticationRequired())
  .isInstanceOf(ProxyAuthenticationRequired)
  .isEnumerable('code', 407)
  .isEnumerable('status', 'Proxy Authentication Required')
  .isEnumerable('message', 'Please, authenticate with the proxy server and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof ProxyAuthenticationRequired without the new operator.

```js
unit
  .object(ProxyAuthenticationRequired())
  .isInstanceOf(ProxyAuthenticationRequired)
  .isEnumerable('code', 407)
  .isEnumerable('status', 'Proxy Authentication Required')
  .isEnumerable('message', 'Please, authenticate with the proxy server and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="proxyauthenticationrequired-version"></a>
## #VERSION
should be a constant property.

```js
const test = new ProxyAuthenticationRequired();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="proxyauthenticationrequired-code"></a>
## #code
should be a constant property.

```js
const test = new ProxyAuthenticationRequired();
unit
  .number(test.code)
  .is(407);
```

<a name="proxyauthenticationrequired-status"></a>
## #status
should be a constant property.

```js
const test = new ProxyAuthenticationRequired();
unit
  .string(test.status)
  .is('Proxy Authentication Required');
```

<a name="proxyauthenticationrequired-message"></a>
## #message
should have a default message.

```js
const test = new ProxyAuthenticationRequired();
unit
  .string(test.message)
  .is('Please, authenticate with the proxy server and try again.');
```

should accept falsy as the default message.

```js
const test = new ProxyAuthenticationRequired();
unit
  .string(test.message)
  .is('Please, authenticate with the proxy server and try again.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Please, authenticate with the proxy server and try again.')
  .given(test.message = null)
  .string(test.message)
  .is('Please, authenticate with the proxy server and try again.')
  .given(test.message = false)
  .string(test.message)
  .is('Please, authenticate with the proxy server and try again.')
  .given(test.message = 0)
  .string(test.message)
  .is('Please, authenticate with the proxy server and try again.')
  .given(test.message = '')
  .string(test.message)
  .is('Please, authenticate with the proxy server and try again.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Please, authenticate with the proxy server and try again.');
```

should accept a string.

```js
const test = new ProxyAuthenticationRequired();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Proxy Authentication Required')
  .string(test.message)
  .is('Proxy Authentication Required');
```

should accept stringifiable arrays.

```js
const test = new ProxyAuthenticationRequired();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new ProxyAuthenticationRequired();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new ProxyAuthenticationRequired();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="proxyauthenticationrequired-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new ProxyAuthenticationRequired();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new ProxyAuthenticationRequired({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="proxyauthenticationrequired-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new ProxyAuthenticationRequired();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new ProxyAuthenticationRequired();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(ProxyAuthenticationRequired)
  .hasProperty('message', 'Bad things.');
```

<a name="proxyauthenticationrequired-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new ProxyAuthenticationRequired();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new ProxyAuthenticationRequired({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="proxyauthenticationrequired-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new ProxyAuthenticationRequired();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new ProxyAuthenticationRequired();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(ProxyAuthenticationRequired)
  .hasProperty('debug', 'Something happened.');
```

<a name="proxyauthenticationrequired-getcause"></a>
## #getCause
should be a function.

```js
const test = new ProxyAuthenticationRequired();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new ProxyAuthenticationRequired({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="proxyauthenticationrequired-setcause"></a>
## #setCause
should be a function.

```js
const test = new ProxyAuthenticationRequired();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new ProxyAuthenticationRequired();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(ProxyAuthenticationRequired)
  .hasProperty('cause', cause);
```

<a name="proxyauthenticationrequired-set"></a>
## #set
should be a function.

```js
const test = new ProxyAuthenticationRequired();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new ProxyAuthenticationRequired();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(ProxyAuthenticationRequired)
  .isEnumerable('code', 407)
  .isEnumerable('status', 'Proxy Authentication Required')
  .isEnumerable('message', 'Please, authenticate with the proxy server and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(ProxyAuthenticationRequired)
  .isEnumerable('code', 407)
  .isEnumerable('status', 'Proxy Authentication Required')
  .isEnumerable('message', 'Please, authenticate with the proxy server and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(ProxyAuthenticationRequired)
  .isEnumerable('code', 407)
  .isEnumerable('status', 'Proxy Authentication Required')
  .isEnumerable('message', 'Please, authenticate with the proxy server and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(ProxyAuthenticationRequired)
  .isEnumerable('code', 407)
  .isEnumerable('status', 'Proxy Authentication Required')
  .isEnumerable('message', 'Please, authenticate with the proxy server and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new ProxyAuthenticationRequired();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new ProxyAuthenticationRequired();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="proxyauthenticationrequired-get"></a>
## #get
should be a function.

```js
const test = new ProxyAuthenticationRequired();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new ProxyAuthenticationRequired();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 407)
  .hasProperty('status', 'Proxy Authentication Required')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 407)
  .hasProperty('status', 'Proxy Authentication Required')
  .hasProperty('message', 'Please, authenticate with the proxy server and try again.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new ProxyAuthenticationRequired();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 407)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 407)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="proxyauthenticationrequired-tojson"></a>
## #toJSON
should be a function.

```js
const test = new ProxyAuthenticationRequired();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new ProxyAuthenticationRequired();
unit
  .object(test.toJSON())
  .hasProperty('code', 407)
  .hasProperty('status', 'Proxy Authentication Required')
  .hasProperty('message', 'Please, authenticate with the proxy server and try again.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 407)
  .hasProperty('status', 'Proxy Authentication Required')
  .hasProperty('message', 'Please, authenticate with the proxy server and try again.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="proxyauthenticationrequired-tostring"></a>
## #toString
should be a function.

```js
const test = new ProxyAuthenticationRequired();
unit
  .function(test.toString);
```

should return ProxyAuthenticationRequired: 407 Proxy Authentication Required.

```js
const test = new ProxyAuthenticationRequired();
unit
  .string(test.toString())
  .is('ProxyAuthenticationRequired: 407 Proxy Authentication Required');
```

<a name="proxyauthenticationrequired-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/proxyauthenticationrequired".

```js
const test = new ProxyAuthenticationRequired();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/proxyauthenticationrequired');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new ProxyAuthenticationRequired();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/proxyauthenticationrequired]');
```

<a name="rangenotsatisfiable"></a>
# RangeNotSatisfiable
should be a function.

```js
unit
  .function(RangeNotSatisfiable);
```

should return an instance of RangeNotSatisfiable.

```js
unit
  .object(new RangeNotSatisfiable())
  .isInstanceOf(RangeNotSatisfiable)
  .isEnumerable('code', 416)
  .isEnumerable('status', 'Range Not Satisfiable')
  .isEnumerable('message', 'Requested range is not satisfiable, please check Range and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof RangeNotSatisfiable without the new operator.

```js
unit
  .object(RangeNotSatisfiable())
  .isInstanceOf(RangeNotSatisfiable)
  .isEnumerable('code', 416)
  .isEnumerable('status', 'Range Not Satisfiable')
  .isEnumerable('message', 'Requested range is not satisfiable, please check Range and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="rangenotsatisfiable-version"></a>
## #VERSION
should be a constant property.

```js
const test = new RangeNotSatisfiable();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="rangenotsatisfiable-code"></a>
## #code
should be a constant property.

```js
const test = new RangeNotSatisfiable();
unit
  .number(test.code)
  .is(416);
```

<a name="rangenotsatisfiable-status"></a>
## #status
should be a constant property.

```js
const test = new RangeNotSatisfiable();
unit
  .string(test.status)
  .is('Range Not Satisfiable');
```

<a name="rangenotsatisfiable-message"></a>
## #message
should have a default message.

```js
const test = new RangeNotSatisfiable();
unit
  .string(test.message)
  .is('Requested range is not satisfiable, please check Range and try again.');
```

should accept falsy as the default message.

```js
const test = new RangeNotSatisfiable();
unit
  .string(test.message)
  .is('Requested range is not satisfiable, please check Range and try again.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Requested range is not satisfiable, please check Range and try again.')
  .given(test.message = null)
  .string(test.message)
  .is('Requested range is not satisfiable, please check Range and try again.')
  .given(test.message = false)
  .string(test.message)
  .is('Requested range is not satisfiable, please check Range and try again.')
  .given(test.message = 0)
  .string(test.message)
  .is('Requested range is not satisfiable, please check Range and try again.')
  .given(test.message = '')
  .string(test.message)
  .is('Requested range is not satisfiable, please check Range and try again.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Requested range is not satisfiable, please check Range and try again.');
```

should accept a string.

```js
const test = new RangeNotSatisfiable();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Range Not Satisfiable')
  .string(test.message)
  .is('Range Not Satisfiable');
```

should accept stringifiable arrays.

```js
const test = new RangeNotSatisfiable();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new RangeNotSatisfiable();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new RangeNotSatisfiable();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="rangenotsatisfiable-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new RangeNotSatisfiable();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new RangeNotSatisfiable({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="rangenotsatisfiable-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new RangeNotSatisfiable();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new RangeNotSatisfiable();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(RangeNotSatisfiable)
  .hasProperty('message', 'Bad things.');
```

<a name="rangenotsatisfiable-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new RangeNotSatisfiable();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new RangeNotSatisfiable({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="rangenotsatisfiable-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new RangeNotSatisfiable();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new RangeNotSatisfiable();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(RangeNotSatisfiable)
  .hasProperty('debug', 'Something happened.');
```

<a name="rangenotsatisfiable-getcause"></a>
## #getCause
should be a function.

```js
const test = new RangeNotSatisfiable();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new RangeNotSatisfiable({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="rangenotsatisfiable-setcause"></a>
## #setCause
should be a function.

```js
const test = new RangeNotSatisfiable();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new RangeNotSatisfiable();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(RangeNotSatisfiable)
  .hasProperty('cause', cause);
```

<a name="rangenotsatisfiable-set"></a>
## #set
should be a function.

```js
const test = new RangeNotSatisfiable();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new RangeNotSatisfiable();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(RangeNotSatisfiable)
  .isEnumerable('code', 416)
  .isEnumerable('status', 'Range Not Satisfiable')
  .isEnumerable('message', 'Requested range is not satisfiable, please check Range and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(RangeNotSatisfiable)
  .isEnumerable('code', 416)
  .isEnumerable('status', 'Range Not Satisfiable')
  .isEnumerable('message', 'Requested range is not satisfiable, please check Range and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(RangeNotSatisfiable)
  .isEnumerable('code', 416)
  .isEnumerable('status', 'Range Not Satisfiable')
  .isEnumerable('message', 'Requested range is not satisfiable, please check Range and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(RangeNotSatisfiable)
  .isEnumerable('code', 416)
  .isEnumerable('status', 'Range Not Satisfiable')
  .isEnumerable('message', 'Requested range is not satisfiable, please check Range and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new RangeNotSatisfiable();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new RangeNotSatisfiable();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="rangenotsatisfiable-get"></a>
## #get
should be a function.

```js
const test = new RangeNotSatisfiable();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new RangeNotSatisfiable();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 416)
  .hasProperty('status', 'Range Not Satisfiable')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 416)
  .hasProperty('status', 'Range Not Satisfiable')
  .hasProperty('message', 'Requested range is not satisfiable, please check Range and try again.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new RangeNotSatisfiable();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 416)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 416)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="rangenotsatisfiable-tojson"></a>
## #toJSON
should be a function.

```js
const test = new RangeNotSatisfiable();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new RangeNotSatisfiable();
unit
  .object(test.toJSON())
  .hasProperty('code', 416)
  .hasProperty('status', 'Range Not Satisfiable')
  .hasProperty('message', 'Requested range is not satisfiable, please check Range and try again.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 416)
  .hasProperty('status', 'Range Not Satisfiable')
  .hasProperty('message', 'Requested range is not satisfiable, please check Range and try again.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="rangenotsatisfiable-tostring"></a>
## #toString
should be a function.

```js
const test = new RangeNotSatisfiable();
unit
  .function(test.toString);
```

should return RangeNotSatisfiable: 416 Range Not Satisfiable.

```js
const test = new RangeNotSatisfiable();
unit
  .string(test.toString())
  .is('RangeNotSatisfiable: 416 Range Not Satisfiable');
```

<a name="rangenotsatisfiable-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/rangenotsatisfiable".

```js
const test = new RangeNotSatisfiable();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/rangenotsatisfiable');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new RangeNotSatisfiable();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/rangenotsatisfiable]');
```

<a name="requestheaderfieldstoolarge"></a>
# RequestHeaderFieldsTooLarge
should be a function.

```js
unit
  .function(RequestHeaderFieldsTooLarge);
```

should return an instance of RequestHeaderFieldsTooLarge.

```js
unit
  .object(new RequestHeaderFieldsTooLarge())
  .isInstanceOf(RequestHeaderFieldsTooLarge)
  .isEnumerable('code', 431)
  .isEnumerable('status', 'Request Header Fields Too Large')
  .isEnumerable('message', 'Request header is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof RequestHeaderFieldsTooLarge without the new operator.

```js
unit
  .object(RequestHeaderFieldsTooLarge())
  .isInstanceOf(RequestHeaderFieldsTooLarge)
  .isEnumerable('code', 431)
  .isEnumerable('status', 'Request Header Fields Too Large')
  .isEnumerable('message', 'Request header is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="requestheaderfieldstoolarge-version"></a>
## #VERSION
should be a constant property.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="requestheaderfieldstoolarge-code"></a>
## #code
should be a constant property.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .number(test.code)
  .is(431);
```

<a name="requestheaderfieldstoolarge-status"></a>
## #status
should be a constant property.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .string(test.status)
  .is('Request Header Fields Too Large');
```

<a name="requestheaderfieldstoolarge-message"></a>
## #message
should have a default message.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .string(test.message)
  .is('Request header is too large and can not be processed.');
```

should accept falsy as the default message.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .string(test.message)
  .is('Request header is too large and can not be processed.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Request header is too large and can not be processed.')
  .given(test.message = null)
  .string(test.message)
  .is('Request header is too large and can not be processed.')
  .given(test.message = false)
  .string(test.message)
  .is('Request header is too large and can not be processed.')
  .given(test.message = 0)
  .string(test.message)
  .is('Request header is too large and can not be processed.')
  .given(test.message = '')
  .string(test.message)
  .is('Request header is too large and can not be processed.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Request header is too large and can not be processed.');
```

should accept a string.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Request Header Fields Too Large')
  .string(test.message)
  .is('Request Header Fields Too Large');
```

should accept stringifiable arrays.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="requestheaderfieldstoolarge-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new RequestHeaderFieldsTooLarge({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="requestheaderfieldstoolarge-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(RequestHeaderFieldsTooLarge)
  .hasProperty('message', 'Bad things.');
```

<a name="requestheaderfieldstoolarge-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new RequestHeaderFieldsTooLarge({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="requestheaderfieldstoolarge-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(RequestHeaderFieldsTooLarge)
  .hasProperty('debug', 'Something happened.');
```

<a name="requestheaderfieldstoolarge-getcause"></a>
## #getCause
should be a function.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new RequestHeaderFieldsTooLarge({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="requestheaderfieldstoolarge-setcause"></a>
## #setCause
should be a function.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new RequestHeaderFieldsTooLarge();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(RequestHeaderFieldsTooLarge)
  .hasProperty('cause', cause);
```

<a name="requestheaderfieldstoolarge-set"></a>
## #set
should be a function.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(RequestHeaderFieldsTooLarge)
  .isEnumerable('code', 431)
  .isEnumerable('status', 'Request Header Fields Too Large')
  .isEnumerable('message', 'Request header is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(RequestHeaderFieldsTooLarge)
  .isEnumerable('code', 431)
  .isEnumerable('status', 'Request Header Fields Too Large')
  .isEnumerable('message', 'Request header is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(RequestHeaderFieldsTooLarge)
  .isEnumerable('code', 431)
  .isEnumerable('status', 'Request Header Fields Too Large')
  .isEnumerable('message', 'Request header is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(RequestHeaderFieldsTooLarge)
  .isEnumerable('code', 431)
  .isEnumerable('status', 'Request Header Fields Too Large')
  .isEnumerable('message', 'Request header is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new RequestHeaderFieldsTooLarge();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="requestheaderfieldstoolarge-get"></a>
## #get
should be a function.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 431)
  .hasProperty('status', 'Request Header Fields Too Large')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 431)
  .hasProperty('status', 'Request Header Fields Too Large')
  .hasProperty('message', 'Request header is too large and can not be processed.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 431)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 431)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="requestheaderfieldstoolarge-tojson"></a>
## #toJSON
should be a function.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .object(test.toJSON())
  .hasProperty('code', 431)
  .hasProperty('status', 'Request Header Fields Too Large')
  .hasProperty('message', 'Request header is too large and can not be processed.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 431)
  .hasProperty('status', 'Request Header Fields Too Large')
  .hasProperty('message', 'Request header is too large and can not be processed.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="requestheaderfieldstoolarge-tostring"></a>
## #toString
should be a function.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .function(test.toString);
```

should return RequestHeaderFieldsTooLarge: 431 Request Header Fields Too Large.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .string(test.toString())
  .is('RequestHeaderFieldsTooLarge: 431 Request Header Fields Too Large');
```

<a name="requestheaderfieldstoolarge-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/requestheaderfieldstoolarge".

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/requestheaderfieldstoolarge');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new RequestHeaderFieldsTooLarge();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/requestheaderfieldstoolarge]');
```

<a name="requesttimeout"></a>
# RequestTimeout
should be a function.

```js
unit
  .function(RequestTimeout);
```

should return an instance of RequestTimeout.

```js
unit
  .object(new RequestTimeout())
  .isInstanceOf(RequestTimeout)
  .isEnumerable('code', 408)
  .isEnumerable('status', 'Request Timeout')
  .isEnumerable('message', 'Sorry, it appears we are on break, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof RequestTimeout without the new operator.

```js
unit
  .object(RequestTimeout())
  .isInstanceOf(RequestTimeout)
  .isEnumerable('code', 408)
  .isEnumerable('status', 'Request Timeout')
  .isEnumerable('message', 'Sorry, it appears we are on break, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="requesttimeout-version"></a>
## #VERSION
should be a constant property.

```js
const test = new RequestTimeout();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="requesttimeout-code"></a>
## #code
should be a constant property.

```js
const test = new RequestTimeout();
unit
  .number(test.code)
  .is(408);
```

<a name="requesttimeout-status"></a>
## #status
should be a constant property.

```js
const test = new RequestTimeout();
unit
  .string(test.status)
  .is('Request Timeout');
```

<a name="requesttimeout-message"></a>
## #message
should have a default message.

```js
const test = new RequestTimeout();
unit
  .string(test.message)
  .is('Sorry, it appears we are on break, please try again later.');
```

should accept falsy as the default message.

```js
const test = new RequestTimeout();
unit
  .string(test.message)
  .is('Sorry, it appears we are on break, please try again later.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Sorry, it appears we are on break, please try again later.')
  .given(test.message = null)
  .string(test.message)
  .is('Sorry, it appears we are on break, please try again later.')
  .given(test.message = false)
  .string(test.message)
  .is('Sorry, it appears we are on break, please try again later.')
  .given(test.message = 0)
  .string(test.message)
  .is('Sorry, it appears we are on break, please try again later.')
  .given(test.message = '')
  .string(test.message)
  .is('Sorry, it appears we are on break, please try again later.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Sorry, it appears we are on break, please try again later.');
```

should accept a string.

```js
const test = new RequestTimeout();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Request Timeout')
  .string(test.message)
  .is('Request Timeout');
```

should accept stringifiable arrays.

```js
const test = new RequestTimeout();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new RequestTimeout();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new RequestTimeout();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="requesttimeout-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new RequestTimeout();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new RequestTimeout({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="requesttimeout-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new RequestTimeout();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new RequestTimeout();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(RequestTimeout)
  .hasProperty('message', 'Bad things.');
```

<a name="requesttimeout-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new RequestTimeout();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new RequestTimeout({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="requesttimeout-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new RequestTimeout();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new RequestTimeout();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(RequestTimeout)
  .hasProperty('debug', 'Something happened.');
```

<a name="requesttimeout-getcause"></a>
## #getCause
should be a function.

```js
const test = new RequestTimeout();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new RequestTimeout({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="requesttimeout-setcause"></a>
## #setCause
should be a function.

```js
const test = new RequestTimeout();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new RequestTimeout();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(RequestTimeout)
  .hasProperty('cause', cause);
```

<a name="requesttimeout-set"></a>
## #set
should be a function.

```js
const test = new RequestTimeout();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new RequestTimeout();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(RequestTimeout)
  .isEnumerable('code', 408)
  .isEnumerable('status', 'Request Timeout')
  .isEnumerable('message', 'Sorry, it appears we are on break, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(RequestTimeout)
  .isEnumerable('code', 408)
  .isEnumerable('status', 'Request Timeout')
  .isEnumerable('message', 'Sorry, it appears we are on break, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(RequestTimeout)
  .isEnumerable('code', 408)
  .isEnumerable('status', 'Request Timeout')
  .isEnumerable('message', 'Sorry, it appears we are on break, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(RequestTimeout)
  .isEnumerable('code', 408)
  .isEnumerable('status', 'Request Timeout')
  .isEnumerable('message', 'Sorry, it appears we are on break, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new RequestTimeout();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new RequestTimeout();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="requesttimeout-get"></a>
## #get
should be a function.

```js
const test = new RequestTimeout();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new RequestTimeout();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 408)
  .hasProperty('status', 'Request Timeout')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 408)
  .hasProperty('status', 'Request Timeout')
  .hasProperty('message', 'Sorry, it appears we are on break, please try again later.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new RequestTimeout();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 408)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 408)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="requesttimeout-tojson"></a>
## #toJSON
should be a function.

```js
const test = new RequestTimeout();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new RequestTimeout();
unit
  .object(test.toJSON())
  .hasProperty('code', 408)
  .hasProperty('status', 'Request Timeout')
  .hasProperty('message', 'Sorry, it appears we are on break, please try again later.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 408)
  .hasProperty('status', 'Request Timeout')
  .hasProperty('message', 'Sorry, it appears we are on break, please try again later.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="requesttimeout-tostring"></a>
## #toString
should be a function.

```js
const test = new RequestTimeout();
unit
  .function(test.toString);
```

should return RequestTimeout: 408 Request Timeout.

```js
const test = new RequestTimeout();
unit
  .string(test.toString())
  .is('RequestTimeout: 408 Request Timeout');
```

<a name="requesttimeout-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/requesttimeout".

```js
const test = new RequestTimeout();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/requesttimeout');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new RequestTimeout();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/requesttimeout]');
```

<a name="servererror"></a>
# ServerError
should be a function.

```js
unit
  .function(ServerError);
```

should return a new InternalServerError when given 500.

```js
unit
  .object(ServerError(500))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(InternalServerError)
  .isEnumerable('code', 500)
  .isEnumerable('status', 'Internal Server Error')
  .isEnumerable('message', 'Sorry, it appears we had an unexpected error, please try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new InternalServerError when given "Internal Server Error".

```js
unit
  .object(ServerError('Internal Server Error'))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(InternalServerError)
  .isEnumerable('code', 500)
  .isEnumerable('status', 'Internal Server Error')
  .isEnumerable('message', 'Sorry, it appears we had an unexpected error, please try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new InternalServerError when given "InternalServerError".

```js
unit
  .object(ServerError('InternalServerError'))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(InternalServerError)
  .isEnumerable('code', 500)
  .isEnumerable('status', 'Internal Server Error')
  .isEnumerable('message', 'Sorry, it appears we had an unexpected error, please try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NotImplemented when given 501.

```js
unit
  .object(ServerError(501))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(NotImplemented)
  .isEnumerable('code', 501)
  .isEnumerable('status', 'Not Implemented')
  .isEnumerable('message', 'Sorry, this is not fully implemented, please try later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NotImplemented when given "Not Implemented".

```js
unit
  .object(ServerError('Not Implemented'))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(NotImplemented)
  .isEnumerable('code', 501)
  .isEnumerable('status', 'Not Implemented')
  .isEnumerable('message', 'Sorry, this is not fully implemented, please try later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NotImplemented when given "NotImplemented".

```js
unit
  .object(ServerError('NotImplemented'))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(NotImplemented)
  .isEnumerable('code', 501)
  .isEnumerable('status', 'Not Implemented')
  .isEnumerable('message', 'Sorry, this is not fully implemented, please try later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new BadGateway when given 502.

```js
unit
  .object(ServerError(502))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(BadGateway)
  .isEnumerable('code', 502)
  .isEnumerable('status', 'Bad Gateway')
  .isEnumerable('message', 'Sorry, It appears we received an error from another service that is needed to fulfill your request, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new BadGateway when given "Bad Gateway".

```js
unit
  .object(ServerError('Bad Gateway'))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(BadGateway)
  .isEnumerable('code', 502)
  .isEnumerable('status', 'Bad Gateway')
  .isEnumerable('message', 'Sorry, It appears we received an error from another service that is needed to fulfill your request, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new BadGateway when given "BadGateway".

```js
unit
  .object(ServerError('BadGateway'))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(BadGateway)
  .isEnumerable('code', 502)
  .isEnumerable('status', 'Bad Gateway')
  .isEnumerable('message', 'Sorry, It appears we received an error from another service that is needed to fulfill your request, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new ServiceUnavailable when given 503.

```js
unit
  .object(ServerError(503))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(ServiceUnavailable)
  .isEnumerable('code', 503)
  .isEnumerable('status', 'Service Unavailable')
  .isEnumerable('message', 'Sorry, this service is currently unavailable, please try later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new ServiceUnavailable when given "Service Unavailable".

```js
unit
  .object(ServerError('Service Unavailable'))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(ServiceUnavailable)
  .isEnumerable('code', 503)
  .isEnumerable('status', 'Service Unavailable')
  .isEnumerable('message', 'Sorry, this service is currently unavailable, please try later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new ServiceUnavailable when given "ServiceUnavailable".

```js
unit
  .object(ServerError('ServiceUnavailable'))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(ServiceUnavailable)
  .isEnumerable('code', 503)
  .isEnumerable('status', 'Service Unavailable')
  .isEnumerable('message', 'Sorry, this service is currently unavailable, please try later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new GatewayTimeout when given 504.

```js
unit
  .object(ServerError(504))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(GatewayTimeout)
  .isEnumerable('code', 504)
  .isEnumerable('status', 'Gateway Timeout')
  .isEnumerable('message', 'Sorry, it appears another service is taking to long and we cannot wait any longer.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new GatewayTimeout when given "Gateway Timeout".

```js
unit
  .object(ServerError('Gateway Timeout'))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(GatewayTimeout)
  .isEnumerable('code', 504)
  .isEnumerable('status', 'Gateway Timeout')
  .isEnumerable('message', 'Sorry, it appears another service is taking to long and we cannot wait any longer.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new GatewayTimeout when given "GatewayTimeout".

```js
unit
  .object(ServerError('GatewayTimeout'))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(GatewayTimeout)
  .isEnumerable('code', 504)
  .isEnumerable('status', 'Gateway Timeout')
  .isEnumerable('message', 'Sorry, it appears another service is taking to long and we cannot wait any longer.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new HTTPVersionNotSupported when given 505.

```js
unit
  .object(ServerError(505))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(HTTPVersionNotSupported)
  .isEnumerable('code', 505)
  .isEnumerable('status', 'HTTP Version Not Supported')
  .isEnumerable('message', 'Please, try a diffrent protocol version and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new HTTPVersionNotSupported when given "HTTP Version Not Supported".

```js
unit
  .object(ServerError('HTTP Version Not Supported'))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(HTTPVersionNotSupported)
  .isEnumerable('code', 505)
  .isEnumerable('status', 'HTTP Version Not Supported')
  .isEnumerable('message', 'Please, try a diffrent protocol version and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new HTTPVersionNotSupported when given "HTTPVersionNotSupported".

```js
unit
  .object(ServerError('HTTPVersionNotSupported'))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(HTTPVersionNotSupported)
  .isEnumerable('code', 505)
  .isEnumerable('status', 'HTTP Version Not Supported')
  .isEnumerable('message', 'Please, try a diffrent protocol version and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new VariantAlsoNegotiates when given 506.

```js
unit
  .object(ServerError(506))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(VariantAlsoNegotiates)
  .isEnumerable('code', 506)
  .isEnumerable('status', 'Variant Also Negotiates')
  .isEnumerable('message', 'Sorry, it appears there is a misconfiguration on our end.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new VariantAlsoNegotiates when given "Variant Also Negotiates".

```js
unit
  .object(ServerError('Variant Also Negotiates'))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(VariantAlsoNegotiates)
  .isEnumerable('code', 506)
  .isEnumerable('status', 'Variant Also Negotiates')
  .isEnumerable('message', 'Sorry, it appears there is a misconfiguration on our end.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new VariantAlsoNegotiates when given "VariantAlsoNegotiates".

```js
unit
  .object(ServerError('VariantAlsoNegotiates'))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(VariantAlsoNegotiates)
  .isEnumerable('code', 506)
  .isEnumerable('status', 'Variant Also Negotiates')
  .isEnumerable('message', 'Sorry, it appears there is a misconfiguration on our end.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new InsufficientStorage when given 507.

```js
unit
  .object(ServerError(507))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(InsufficientStorage)
  .isEnumerable('code', 507)
  .isEnumerable('status', 'Insufficient Storage')
  .isEnumerable('message', 'Sorry, it appears we have no more room for storage.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new InsufficientStorage when given "Insufficient Storage".

```js
unit
  .object(ServerError('Insufficient Storage'))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(InsufficientStorage)
  .isEnumerable('code', 507)
  .isEnumerable('status', 'Insufficient Storage')
  .isEnumerable('message', 'Sorry, it appears we have no more room for storage.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new InsufficientStorage when given "InsufficientStorage".

```js
unit
  .object(ServerError('InsufficientStorage'))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(InsufficientStorage)
  .isEnumerable('code', 507)
  .isEnumerable('status', 'Insufficient Storage')
  .isEnumerable('message', 'Sorry, it appears we have no more room for storage.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new LoopDetected when given 508.

```js
unit
  .object(ServerError(508))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(LoopDetected)
  .isEnumerable('code', 508)
  .isEnumerable('status', 'Loop Detected')
  .isEnumerable('message', 'Sorry, We have detected an infintie loop and had to stop the request, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new LoopDetected when given "Loop Detected".

```js
unit
  .object(ServerError('Loop Detected'))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(LoopDetected)
  .isEnumerable('code', 508)
  .isEnumerable('status', 'Loop Detected')
  .isEnumerable('message', 'Sorry, We have detected an infintie loop and had to stop the request, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new LoopDetected when given "LoopDetected".

```js
unit
  .object(ServerError('LoopDetected'))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(LoopDetected)
  .isEnumerable('code', 508)
  .isEnumerable('status', 'Loop Detected')
  .isEnumerable('message', 'Sorry, We have detected an infintie loop and had to stop the request, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NotExtended when given 510.

```js
unit
  .object(ServerError(510))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(NotExtended)
  .isEnumerable('code', 510)
  .isEnumerable('status', 'Not Extended')
  .isEnumerable('message', 'The policy for accessing this resource has not been met by this request.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NotExtended when given "Not Extended".

```js
unit
  .object(ServerError('Not Extended'))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(NotExtended)
  .isEnumerable('code', 510)
  .isEnumerable('status', 'Not Extended')
  .isEnumerable('message', 'The policy for accessing this resource has not been met by this request.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NotExtended when given "NotExtended".

```js
unit
  .object(ServerError('NotExtended'))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(NotExtended)
  .isEnumerable('code', 510)
  .isEnumerable('status', 'Not Extended')
  .isEnumerable('message', 'The policy for accessing this resource has not been met by this request.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NetworkAuthenticationRequired when given 511.

```js
unit
  .object(ServerError(511))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(NetworkAuthenticationRequired)
  .isEnumerable('code', 511)
  .isEnumerable('status', 'Network Authentication Required')
  .isEnumerable('message', 'Please, authenticate with the network and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NetworkAuthenticationRequired when given "Network Authentication Required".

```js
unit
  .object(ServerError('Network Authentication Required'))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(NetworkAuthenticationRequired)
  .isEnumerable('code', 511)
  .isEnumerable('status', 'Network Authentication Required')
  .isEnumerable('message', 'Please, authenticate with the network and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new NetworkAuthenticationRequired when given "NetworkAuthenticationRequired".

```js
unit
  .object(ServerError('NetworkAuthenticationRequired'))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(NetworkAuthenticationRequired)
  .isEnumerable('code', 511)
  .isEnumerable('status', 'Network Authentication Required')
  .isEnumerable('message', 'Please, authenticate with the network and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UnknownError when given 520.

```js
unit
  .object(ServerError(520))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(UnknownError)
  .isEnumerable('code', 520)
  .isEnumerable('status', 'Unknown Error')
  .isEnumerable('message', 'Sorry, an unexpected error has occured, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UnknownError when given "Unknown Error".

```js
unit
  .object(ServerError('Unknown Error'))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(UnknownError)
  .isEnumerable('code', 520)
  .isEnumerable('status', 'Unknown Error')
  .isEnumerable('message', 'Sorry, an unexpected error has occured, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

should return a new UnknownError when given "UnknownError".

```js
unit
  .object(ServerError('UnknownError'))
  .isInstanceOf(Error)
  .isInstanceOf(ServerError)
  .isInstanceOf(UnknownError)
  .isEnumerable('code', 520)
  .isEnumerable('status', 'Unknown Error')
  .isEnumerable('message', 'Sorry, an unexpected error has occured, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause');
```

<a name="serviceunavailable"></a>
# ServiceUnavailable
should be a function.

```js
unit
  .function(ServiceUnavailable);
```

should return an instance of ServiceUnavailable.

```js
unit
  .object(new ServiceUnavailable())
  .isInstanceOf(ServiceUnavailable)
  .isEnumerable('code', 503)
  .isEnumerable('status', 'Service Unavailable')
  .isEnumerable('message', 'Sorry, this service is currently unavailable, please try later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof ServiceUnavailable without the new operator.

```js
unit
  .object(ServiceUnavailable())
  .isInstanceOf(ServiceUnavailable)
  .isEnumerable('code', 503)
  .isEnumerable('status', 'Service Unavailable')
  .isEnumerable('message', 'Sorry, this service is currently unavailable, please try later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="serviceunavailable-version"></a>
## #VERSION
should be a constant property.

```js
const test = new ServiceUnavailable();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="serviceunavailable-code"></a>
## #code
should be a constant property.

```js
const test = new ServiceUnavailable();
unit
  .number(test.code)
  .is(503);
```

<a name="serviceunavailable-status"></a>
## #status
should be a constant property.

```js
const test = new ServiceUnavailable();
unit
  .string(test.status)
  .is('Service Unavailable');
```

<a name="serviceunavailable-message"></a>
## #message
should have a default message.

```js
const test = new ServiceUnavailable();
unit
  .string(test.message)
  .is('Sorry, this service is currently unavailable, please try later.');
```

should accept falsy as the default message.

```js
const test = new ServiceUnavailable();
unit
  .string(test.message)
  .is('Sorry, this service is currently unavailable, please try later.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Sorry, this service is currently unavailable, please try later.')
  .given(test.message = null)
  .string(test.message)
  .is('Sorry, this service is currently unavailable, please try later.')
  .given(test.message = false)
  .string(test.message)
  .is('Sorry, this service is currently unavailable, please try later.')
  .given(test.message = 0)
  .string(test.message)
  .is('Sorry, this service is currently unavailable, please try later.')
  .given(test.message = '')
  .string(test.message)
  .is('Sorry, this service is currently unavailable, please try later.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Sorry, this service is currently unavailable, please try later.');
```

should accept a string.

```js
const test = new ServiceUnavailable();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Service Unavailable')
  .string(test.message)
  .is('Service Unavailable');
```

should accept stringifiable arrays.

```js
const test = new ServiceUnavailable();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new ServiceUnavailable();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new ServiceUnavailable();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="serviceunavailable-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new ServiceUnavailable();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new ServiceUnavailable({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="serviceunavailable-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new ServiceUnavailable();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new ServiceUnavailable();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(ServiceUnavailable)
  .hasProperty('message', 'Bad things.');
```

<a name="serviceunavailable-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new ServiceUnavailable();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new ServiceUnavailable({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="serviceunavailable-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new ServiceUnavailable();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new ServiceUnavailable();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(ServiceUnavailable)
  .hasProperty('debug', 'Something happened.');
```

<a name="serviceunavailable-getcause"></a>
## #getCause
should be a function.

```js
const test = new ServiceUnavailable();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new ServiceUnavailable({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="serviceunavailable-setcause"></a>
## #setCause
should be a function.

```js
const test = new ServiceUnavailable();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new ServiceUnavailable();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(ServiceUnavailable)
  .hasProperty('cause', cause);
```

<a name="serviceunavailable-set"></a>
## #set
should be a function.

```js
const test = new ServiceUnavailable();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new ServiceUnavailable();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(ServiceUnavailable)
  .isEnumerable('code', 503)
  .isEnumerable('status', 'Service Unavailable')
  .isEnumerable('message', 'Sorry, this service is currently unavailable, please try later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(ServiceUnavailable)
  .isEnumerable('code', 503)
  .isEnumerable('status', 'Service Unavailable')
  .isEnumerable('message', 'Sorry, this service is currently unavailable, please try later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(ServiceUnavailable)
  .isEnumerable('code', 503)
  .isEnumerable('status', 'Service Unavailable')
  .isEnumerable('message', 'Sorry, this service is currently unavailable, please try later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(ServiceUnavailable)
  .isEnumerable('code', 503)
  .isEnumerable('status', 'Service Unavailable')
  .isEnumerable('message', 'Sorry, this service is currently unavailable, please try later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new ServiceUnavailable();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new ServiceUnavailable();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="serviceunavailable-get"></a>
## #get
should be a function.

```js
const test = new ServiceUnavailable();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new ServiceUnavailable();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 503)
  .hasProperty('status', 'Service Unavailable')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 503)
  .hasProperty('status', 'Service Unavailable')
  .hasProperty('message', 'Sorry, this service is currently unavailable, please try later.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new ServiceUnavailable();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 503)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 503)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="serviceunavailable-tojson"></a>
## #toJSON
should be a function.

```js
const test = new ServiceUnavailable();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new ServiceUnavailable();
unit
  .object(test.toJSON())
  .hasProperty('code', 503)
  .hasProperty('status', 'Service Unavailable')
  .hasProperty('message', 'Sorry, this service is currently unavailable, please try later.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 503)
  .hasProperty('status', 'Service Unavailable')
  .hasProperty('message', 'Sorry, this service is currently unavailable, please try later.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="serviceunavailable-tostring"></a>
## #toString
should be a function.

```js
const test = new ServiceUnavailable();
unit
  .function(test.toString);
```

should return ServiceUnavailable: 503 Service Unavailable.

```js
const test = new ServiceUnavailable();
unit
  .string(test.toString())
  .is('ServiceUnavailable: 503 Service Unavailable');
```

<a name="serviceunavailable-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/serviceunavailable".

```js
const test = new ServiceUnavailable();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/serviceunavailable');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new ServiceUnavailable();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/serviceunavailable]');
```

<a name="toomanyrequests"></a>
# TooManyRequests
should be a function.

```js
unit
  .function(TooManyRequests);
```

should return an instance of TooManyRequests.

```js
unit
  .object(new TooManyRequests())
  .isInstanceOf(TooManyRequests)
  .isEnumerable('code', 429)
  .isEnumerable('status', 'Too Many Requests')
  .isEnumerable('message', 'Sorry, you have exceeded your rate limit, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof TooManyRequests without the new operator.

```js
unit
  .object(TooManyRequests())
  .isInstanceOf(TooManyRequests)
  .isEnumerable('code', 429)
  .isEnumerable('status', 'Too Many Requests')
  .isEnumerable('message', 'Sorry, you have exceeded your rate limit, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="toomanyrequests-version"></a>
## #VERSION
should be a constant property.

```js
const test = new TooManyRequests();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="toomanyrequests-code"></a>
## #code
should be a constant property.

```js
const test = new TooManyRequests();
unit
  .number(test.code)
  .is(429);
```

<a name="toomanyrequests-status"></a>
## #status
should be a constant property.

```js
const test = new TooManyRequests();
unit
  .string(test.status)
  .is('Too Many Requests');
```

<a name="toomanyrequests-message"></a>
## #message
should have a default message.

```js
const test = new TooManyRequests();
unit
  .string(test.message)
  .is('Sorry, you have exceeded your rate limit, please try again later.');
```

should accept falsy as the default message.

```js
const test = new TooManyRequests();
unit
  .string(test.message)
  .is('Sorry, you have exceeded your rate limit, please try again later.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Sorry, you have exceeded your rate limit, please try again later.')
  .given(test.message = null)
  .string(test.message)
  .is('Sorry, you have exceeded your rate limit, please try again later.')
  .given(test.message = false)
  .string(test.message)
  .is('Sorry, you have exceeded your rate limit, please try again later.')
  .given(test.message = 0)
  .string(test.message)
  .is('Sorry, you have exceeded your rate limit, please try again later.')
  .given(test.message = '')
  .string(test.message)
  .is('Sorry, you have exceeded your rate limit, please try again later.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Sorry, you have exceeded your rate limit, please try again later.');
```

should accept a string.

```js
const test = new TooManyRequests();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Too Many Requests')
  .string(test.message)
  .is('Too Many Requests');
```

should accept stringifiable arrays.

```js
const test = new TooManyRequests();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new TooManyRequests();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new TooManyRequests();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="toomanyrequests-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new TooManyRequests();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new TooManyRequests({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="toomanyrequests-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new TooManyRequests();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new TooManyRequests();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(TooManyRequests)
  .hasProperty('message', 'Bad things.');
```

<a name="toomanyrequests-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new TooManyRequests();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new TooManyRequests({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="toomanyrequests-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new TooManyRequests();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new TooManyRequests();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(TooManyRequests)
  .hasProperty('debug', 'Something happened.');
```

<a name="toomanyrequests-getcause"></a>
## #getCause
should be a function.

```js
const test = new TooManyRequests();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new TooManyRequests({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="toomanyrequests-setcause"></a>
## #setCause
should be a function.

```js
const test = new TooManyRequests();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new TooManyRequests();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(TooManyRequests)
  .hasProperty('cause', cause);
```

<a name="toomanyrequests-set"></a>
## #set
should be a function.

```js
const test = new TooManyRequests();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new TooManyRequests();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(TooManyRequests)
  .isEnumerable('code', 429)
  .isEnumerable('status', 'Too Many Requests')
  .isEnumerable('message', 'Sorry, you have exceeded your rate limit, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(TooManyRequests)
  .isEnumerable('code', 429)
  .isEnumerable('status', 'Too Many Requests')
  .isEnumerable('message', 'Sorry, you have exceeded your rate limit, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(TooManyRequests)
  .isEnumerable('code', 429)
  .isEnumerable('status', 'Too Many Requests')
  .isEnumerable('message', 'Sorry, you have exceeded your rate limit, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(TooManyRequests)
  .isEnumerable('code', 429)
  .isEnumerable('status', 'Too Many Requests')
  .isEnumerable('message', 'Sorry, you have exceeded your rate limit, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new TooManyRequests();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new TooManyRequests();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="toomanyrequests-get"></a>
## #get
should be a function.

```js
const test = new TooManyRequests();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new TooManyRequests();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 429)
  .hasProperty('status', 'Too Many Requests')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 429)
  .hasProperty('status', 'Too Many Requests')
  .hasProperty('message', 'Sorry, you have exceeded your rate limit, please try again later.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new TooManyRequests();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 429)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 429)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="toomanyrequests-tojson"></a>
## #toJSON
should be a function.

```js
const test = new TooManyRequests();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new TooManyRequests();
unit
  .object(test.toJSON())
  .hasProperty('code', 429)
  .hasProperty('status', 'Too Many Requests')
  .hasProperty('message', 'Sorry, you have exceeded your rate limit, please try again later.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 429)
  .hasProperty('status', 'Too Many Requests')
  .hasProperty('message', 'Sorry, you have exceeded your rate limit, please try again later.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="toomanyrequests-tostring"></a>
## #toString
should be a function.

```js
const test = new TooManyRequests();
unit
  .function(test.toString);
```

should return TooManyRequests: 429 Too Many Requests.

```js
const test = new TooManyRequests();
unit
  .string(test.toString())
  .is('TooManyRequests: 429 Too Many Requests');
```

<a name="toomanyrequests-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/toomanyrequests".

```js
const test = new TooManyRequests();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/toomanyrequests');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new TooManyRequests();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/toomanyrequests]');
```

<a name="uritoolong"></a>
# URITooLong
should be a function.

```js
unit
  .function(URITooLong);
```

should return an instance of URITooLong.

```js
unit
  .object(new URITooLong())
  .isInstanceOf(URITooLong)
  .isEnumerable('code', 414)
  .isEnumerable('status', 'URI Too Long')
  .isEnumerable('message', 'Request uri is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof URITooLong without the new operator.

```js
unit
  .object(URITooLong())
  .isInstanceOf(URITooLong)
  .isEnumerable('code', 414)
  .isEnumerable('status', 'URI Too Long')
  .isEnumerable('message', 'Request uri is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="uritoolong-version"></a>
## #VERSION
should be a constant property.

```js
const test = new URITooLong();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="uritoolong-code"></a>
## #code
should be a constant property.

```js
const test = new URITooLong();
unit
  .number(test.code)
  .is(414);
```

<a name="uritoolong-status"></a>
## #status
should be a constant property.

```js
const test = new URITooLong();
unit
  .string(test.status)
  .is('URI Too Long');
```

<a name="uritoolong-message"></a>
## #message
should have a default message.

```js
const test = new URITooLong();
unit
  .string(test.message)
  .is('Request uri is too large and can not be processed.');
```

should accept falsy as the default message.

```js
const test = new URITooLong();
unit
  .string(test.message)
  .is('Request uri is too large and can not be processed.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Request uri is too large and can not be processed.')
  .given(test.message = null)
  .string(test.message)
  .is('Request uri is too large and can not be processed.')
  .given(test.message = false)
  .string(test.message)
  .is('Request uri is too large and can not be processed.')
  .given(test.message = 0)
  .string(test.message)
  .is('Request uri is too large and can not be processed.')
  .given(test.message = '')
  .string(test.message)
  .is('Request uri is too large and can not be processed.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Request uri is too large and can not be processed.');
```

should accept a string.

```js
const test = new URITooLong();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'URI Too Long')
  .string(test.message)
  .is('URI Too Long');
```

should accept stringifiable arrays.

```js
const test = new URITooLong();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new URITooLong();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new URITooLong();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="uritoolong-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new URITooLong();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new URITooLong({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="uritoolong-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new URITooLong();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new URITooLong();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(URITooLong)
  .hasProperty('message', 'Bad things.');
```

<a name="uritoolong-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new URITooLong();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new URITooLong({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="uritoolong-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new URITooLong();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new URITooLong();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(URITooLong)
  .hasProperty('debug', 'Something happened.');
```

<a name="uritoolong-getcause"></a>
## #getCause
should be a function.

```js
const test = new URITooLong();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new URITooLong({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="uritoolong-setcause"></a>
## #setCause
should be a function.

```js
const test = new URITooLong();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new URITooLong();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(URITooLong)
  .hasProperty('cause', cause);
```

<a name="uritoolong-set"></a>
## #set
should be a function.

```js
const test = new URITooLong();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new URITooLong();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(URITooLong)
  .isEnumerable('code', 414)
  .isEnumerable('status', 'URI Too Long')
  .isEnumerable('message', 'Request uri is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(URITooLong)
  .isEnumerable('code', 414)
  .isEnumerable('status', 'URI Too Long')
  .isEnumerable('message', 'Request uri is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(URITooLong)
  .isEnumerable('code', 414)
  .isEnumerable('status', 'URI Too Long')
  .isEnumerable('message', 'Request uri is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(URITooLong)
  .isEnumerable('code', 414)
  .isEnumerable('status', 'URI Too Long')
  .isEnumerable('message', 'Request uri is too large and can not be processed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new URITooLong();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new URITooLong();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="uritoolong-get"></a>
## #get
should be a function.

```js
const test = new URITooLong();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new URITooLong();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 414)
  .hasProperty('status', 'URI Too Long')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 414)
  .hasProperty('status', 'URI Too Long')
  .hasProperty('message', 'Request uri is too large and can not be processed.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new URITooLong();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 414)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 414)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="uritoolong-tojson"></a>
## #toJSON
should be a function.

```js
const test = new URITooLong();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new URITooLong();
unit
  .object(test.toJSON())
  .hasProperty('code', 414)
  .hasProperty('status', 'URI Too Long')
  .hasProperty('message', 'Request uri is too large and can not be processed.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 414)
  .hasProperty('status', 'URI Too Long')
  .hasProperty('message', 'Request uri is too large and can not be processed.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="uritoolong-tostring"></a>
## #toString
should be a function.

```js
const test = new URITooLong();
unit
  .function(test.toString);
```

should return URITooLong: 414 URI Too Long.

```js
const test = new URITooLong();
unit
  .string(test.toString())
  .is('URITooLong: 414 URI Too Long');
```

<a name="uritoolong-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/uritoolong".

```js
const test = new URITooLong();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/uritoolong');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new URITooLong();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/uritoolong]');
```

<a name="unauthorized"></a>
# Unauthorized
should be a function.

```js
unit
  .function(Unauthorized);
```

should return an instance of Unauthorized.

```js
unit
  .object(new Unauthorized())
  .isInstanceOf(Unauthorized)
  .isEnumerable('code', 401)
  .isEnumerable('status', 'Unauthorized')
  .isEnumerable('message', 'Please, authenticate and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof Unauthorized without the new operator.

```js
unit
  .object(Unauthorized())
  .isInstanceOf(Unauthorized)
  .isEnumerable('code', 401)
  .isEnumerable('status', 'Unauthorized')
  .isEnumerable('message', 'Please, authenticate and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="unauthorized-version"></a>
## #VERSION
should be a constant property.

```js
const test = new Unauthorized();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="unauthorized-code"></a>
## #code
should be a constant property.

```js
const test = new Unauthorized();
unit
  .number(test.code)
  .is(401);
```

<a name="unauthorized-status"></a>
## #status
should be a constant property.

```js
const test = new Unauthorized();
unit
  .string(test.status)
  .is('Unauthorized');
```

<a name="unauthorized-message"></a>
## #message
should have a default message.

```js
const test = new Unauthorized();
unit
  .string(test.message)
  .is('Please, authenticate and try again.');
```

should accept falsy as the default message.

```js
const test = new Unauthorized();
unit
  .string(test.message)
  .is('Please, authenticate and try again.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Please, authenticate and try again.')
  .given(test.message = null)
  .string(test.message)
  .is('Please, authenticate and try again.')
  .given(test.message = false)
  .string(test.message)
  .is('Please, authenticate and try again.')
  .given(test.message = 0)
  .string(test.message)
  .is('Please, authenticate and try again.')
  .given(test.message = '')
  .string(test.message)
  .is('Please, authenticate and try again.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Please, authenticate and try again.');
```

should accept a string.

```js
const test = new Unauthorized();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Unauthorized')
  .string(test.message)
  .is('Unauthorized');
```

should accept stringifiable arrays.

```js
const test = new Unauthorized();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new Unauthorized();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new Unauthorized();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="unauthorized-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new Unauthorized();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new Unauthorized({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="unauthorized-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new Unauthorized();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new Unauthorized();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(Unauthorized)
  .hasProperty('message', 'Bad things.');
```

<a name="unauthorized-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new Unauthorized();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new Unauthorized({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="unauthorized-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new Unauthorized();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new Unauthorized();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(Unauthorized)
  .hasProperty('debug', 'Something happened.');
```

<a name="unauthorized-getcause"></a>
## #getCause
should be a function.

```js
const test = new Unauthorized();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new Unauthorized({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="unauthorized-setcause"></a>
## #setCause
should be a function.

```js
const test = new Unauthorized();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new Unauthorized();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(Unauthorized)
  .hasProperty('cause', cause);
```

<a name="unauthorized-set"></a>
## #set
should be a function.

```js
const test = new Unauthorized();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new Unauthorized();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(Unauthorized)
  .isEnumerable('code', 401)
  .isEnumerable('status', 'Unauthorized')
  .isEnumerable('message', 'Please, authenticate and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(Unauthorized)
  .isEnumerable('code', 401)
  .isEnumerable('status', 'Unauthorized')
  .isEnumerable('message', 'Please, authenticate and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(Unauthorized)
  .isEnumerable('code', 401)
  .isEnumerable('status', 'Unauthorized')
  .isEnumerable('message', 'Please, authenticate and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(Unauthorized)
  .isEnumerable('code', 401)
  .isEnumerable('status', 'Unauthorized')
  .isEnumerable('message', 'Please, authenticate and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new Unauthorized();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new Unauthorized();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="unauthorized-get"></a>
## #get
should be a function.

```js
const test = new Unauthorized();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new Unauthorized();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 401)
  .hasProperty('status', 'Unauthorized')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 401)
  .hasProperty('status', 'Unauthorized')
  .hasProperty('message', 'Please, authenticate and try again.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new Unauthorized();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 401)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 401)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="unauthorized-tojson"></a>
## #toJSON
should be a function.

```js
const test = new Unauthorized();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new Unauthorized();
unit
  .object(test.toJSON())
  .hasProperty('code', 401)
  .hasProperty('status', 'Unauthorized')
  .hasProperty('message', 'Please, authenticate and try again.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 401)
  .hasProperty('status', 'Unauthorized')
  .hasProperty('message', 'Please, authenticate and try again.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="unauthorized-tostring"></a>
## #toString
should be a function.

```js
const test = new Unauthorized();
unit
  .function(test.toString);
```

should return Unauthorized: 401 Unauthorized.

```js
const test = new Unauthorized();
unit
  .string(test.toString())
  .is('Unauthorized: 401 Unauthorized');
```

<a name="unauthorized-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/unauthorized".

```js
const test = new Unauthorized();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/unauthorized');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new Unauthorized();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/unauthorized]');
```

<a name="unavailableforlegalreasons"></a>
# UnavailableForLegalReasons
should be a function.

```js
unit
  .function(UnavailableForLegalReasons);
```

should return an instance of UnavailableForLegalReasons.

```js
unit
  .object(new UnavailableForLegalReasons())
  .isInstanceOf(UnavailableForLegalReasons)
  .isEnumerable('code', 451)
  .isEnumerable('status', 'Unavailable For Legal Reasons')
  .isEnumerable('message', 'Due to legal reasons this resource has been removed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof UnavailableForLegalReasons without the new operator.

```js
unit
  .object(UnavailableForLegalReasons())
  .isInstanceOf(UnavailableForLegalReasons)
  .isEnumerable('code', 451)
  .isEnumerable('status', 'Unavailable For Legal Reasons')
  .isEnumerable('message', 'Due to legal reasons this resource has been removed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="unavailableforlegalreasons-version"></a>
## #VERSION
should be a constant property.

```js
const test = new UnavailableForLegalReasons();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="unavailableforlegalreasons-code"></a>
## #code
should be a constant property.

```js
const test = new UnavailableForLegalReasons();
unit
  .number(test.code)
  .is(451);
```

<a name="unavailableforlegalreasons-status"></a>
## #status
should be a constant property.

```js
const test = new UnavailableForLegalReasons();
unit
  .string(test.status)
  .is('Unavailable For Legal Reasons');
```

<a name="unavailableforlegalreasons-message"></a>
## #message
should have a default message.

```js
const test = new UnavailableForLegalReasons();
unit
  .string(test.message)
  .is('Due to legal reasons this resource has been removed.');
```

should accept falsy as the default message.

```js
const test = new UnavailableForLegalReasons();
unit
  .string(test.message)
  .is('Due to legal reasons this resource has been removed.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Due to legal reasons this resource has been removed.')
  .given(test.message = null)
  .string(test.message)
  .is('Due to legal reasons this resource has been removed.')
  .given(test.message = false)
  .string(test.message)
  .is('Due to legal reasons this resource has been removed.')
  .given(test.message = 0)
  .string(test.message)
  .is('Due to legal reasons this resource has been removed.')
  .given(test.message = '')
  .string(test.message)
  .is('Due to legal reasons this resource has been removed.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Due to legal reasons this resource has been removed.');
```

should accept a string.

```js
const test = new UnavailableForLegalReasons();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Unavailable For Legal Reasons')
  .string(test.message)
  .is('Unavailable For Legal Reasons');
```

should accept stringifiable arrays.

```js
const test = new UnavailableForLegalReasons();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new UnavailableForLegalReasons();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new UnavailableForLegalReasons();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="unavailableforlegalreasons-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new UnavailableForLegalReasons();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new UnavailableForLegalReasons({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="unavailableforlegalreasons-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new UnavailableForLegalReasons();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new UnavailableForLegalReasons();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(UnavailableForLegalReasons)
  .hasProperty('message', 'Bad things.');
```

<a name="unavailableforlegalreasons-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new UnavailableForLegalReasons();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new UnavailableForLegalReasons({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="unavailableforlegalreasons-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new UnavailableForLegalReasons();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new UnavailableForLegalReasons();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(UnavailableForLegalReasons)
  .hasProperty('debug', 'Something happened.');
```

<a name="unavailableforlegalreasons-getcause"></a>
## #getCause
should be a function.

```js
const test = new UnavailableForLegalReasons();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new UnavailableForLegalReasons({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="unavailableforlegalreasons-setcause"></a>
## #setCause
should be a function.

```js
const test = new UnavailableForLegalReasons();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new UnavailableForLegalReasons();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(UnavailableForLegalReasons)
  .hasProperty('cause', cause);
```

<a name="unavailableforlegalreasons-set"></a>
## #set
should be a function.

```js
const test = new UnavailableForLegalReasons();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new UnavailableForLegalReasons();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(UnavailableForLegalReasons)
  .isEnumerable('code', 451)
  .isEnumerable('status', 'Unavailable For Legal Reasons')
  .isEnumerable('message', 'Due to legal reasons this resource has been removed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(UnavailableForLegalReasons)
  .isEnumerable('code', 451)
  .isEnumerable('status', 'Unavailable For Legal Reasons')
  .isEnumerable('message', 'Due to legal reasons this resource has been removed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(UnavailableForLegalReasons)
  .isEnumerable('code', 451)
  .isEnumerable('status', 'Unavailable For Legal Reasons')
  .isEnumerable('message', 'Due to legal reasons this resource has been removed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(UnavailableForLegalReasons)
  .isEnumerable('code', 451)
  .isEnumerable('status', 'Unavailable For Legal Reasons')
  .isEnumerable('message', 'Due to legal reasons this resource has been removed.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new UnavailableForLegalReasons();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new UnavailableForLegalReasons();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="unavailableforlegalreasons-get"></a>
## #get
should be a function.

```js
const test = new UnavailableForLegalReasons();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new UnavailableForLegalReasons();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 451)
  .hasProperty('status', 'Unavailable For Legal Reasons')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 451)
  .hasProperty('status', 'Unavailable For Legal Reasons')
  .hasProperty('message', 'Due to legal reasons this resource has been removed.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new UnavailableForLegalReasons();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 451)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 451)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="unavailableforlegalreasons-tojson"></a>
## #toJSON
should be a function.

```js
const test = new UnavailableForLegalReasons();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new UnavailableForLegalReasons();
unit
  .object(test.toJSON())
  .hasProperty('code', 451)
  .hasProperty('status', 'Unavailable For Legal Reasons')
  .hasProperty('message', 'Due to legal reasons this resource has been removed.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 451)
  .hasProperty('status', 'Unavailable For Legal Reasons')
  .hasProperty('message', 'Due to legal reasons this resource has been removed.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="unavailableforlegalreasons-tostring"></a>
## #toString
should be a function.

```js
const test = new UnavailableForLegalReasons();
unit
  .function(test.toString);
```

should return UnavailableForLegalReasons: 451 Unavailable For Legal Reasons.

```js
const test = new UnavailableForLegalReasons();
unit
  .string(test.toString())
  .is('UnavailableForLegalReasons: 451 Unavailable For Legal Reasons');
```

<a name="unavailableforlegalreasons-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/unavailableforlegalreasons".

```js
const test = new UnavailableForLegalReasons();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/unavailableforlegalreasons');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new UnavailableForLegalReasons();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/unavailableforlegalreasons]');
```

<a name="unknownerror"></a>
# UnknownError
should be a function.

```js
unit
  .function(UnknownError);
```

should return an instance of UnknownError.

```js
unit
  .object(new UnknownError())
  .isInstanceOf(UnknownError)
  .isEnumerable('code', 520)
  .isEnumerable('status', 'Unknown Error')
  .isEnumerable('message', 'Sorry, an unexpected error has occured, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof UnknownError without the new operator.

```js
unit
  .object(UnknownError())
  .isInstanceOf(UnknownError)
  .isEnumerable('code', 520)
  .isEnumerable('status', 'Unknown Error')
  .isEnumerable('message', 'Sorry, an unexpected error has occured, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="unknownerror-version"></a>
## #VERSION
should be a constant property.

```js
const test = new UnknownError();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="unknownerror-code"></a>
## #code
should be a constant property.

```js
const test = new UnknownError();
unit
  .number(test.code)
  .is(520);
```

<a name="unknownerror-status"></a>
## #status
should be a constant property.

```js
const test = new UnknownError();
unit
  .string(test.status)
  .is('Unknown Error');
```

<a name="unknownerror-message"></a>
## #message
should have a default message.

```js
const test = new UnknownError();
unit
  .string(test.message)
  .is('Sorry, an unexpected error has occured, please try again later.');
```

should accept falsy as the default message.

```js
const test = new UnknownError();
unit
  .string(test.message)
  .is('Sorry, an unexpected error has occured, please try again later.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Sorry, an unexpected error has occured, please try again later.')
  .given(test.message = null)
  .string(test.message)
  .is('Sorry, an unexpected error has occured, please try again later.')
  .given(test.message = false)
  .string(test.message)
  .is('Sorry, an unexpected error has occured, please try again later.')
  .given(test.message = 0)
  .string(test.message)
  .is('Sorry, an unexpected error has occured, please try again later.')
  .given(test.message = '')
  .string(test.message)
  .is('Sorry, an unexpected error has occured, please try again later.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Sorry, an unexpected error has occured, please try again later.');
```

should accept a string.

```js
const test = new UnknownError();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Unknown Error')
  .string(test.message)
  .is('Unknown Error');
```

should accept stringifiable arrays.

```js
const test = new UnknownError();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new UnknownError();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new UnknownError();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="unknownerror-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new UnknownError();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new UnknownError({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="unknownerror-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new UnknownError();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new UnknownError();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(UnknownError)
  .hasProperty('message', 'Bad things.');
```

<a name="unknownerror-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new UnknownError();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new UnknownError({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="unknownerror-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new UnknownError();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new UnknownError();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(UnknownError)
  .hasProperty('debug', 'Something happened.');
```

<a name="unknownerror-getcause"></a>
## #getCause
should be a function.

```js
const test = new UnknownError();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new UnknownError({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="unknownerror-setcause"></a>
## #setCause
should be a function.

```js
const test = new UnknownError();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new UnknownError();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(UnknownError)
  .hasProperty('cause', cause);
```

<a name="unknownerror-set"></a>
## #set
should be a function.

```js
const test = new UnknownError();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new UnknownError();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(UnknownError)
  .isEnumerable('code', 520)
  .isEnumerable('status', 'Unknown Error')
  .isEnumerable('message', 'Sorry, an unexpected error has occured, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(UnknownError)
  .isEnumerable('code', 520)
  .isEnumerable('status', 'Unknown Error')
  .isEnumerable('message', 'Sorry, an unexpected error has occured, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(UnknownError)
  .isEnumerable('code', 520)
  .isEnumerable('status', 'Unknown Error')
  .isEnumerable('message', 'Sorry, an unexpected error has occured, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(UnknownError)
  .isEnumerable('code', 520)
  .isEnumerable('status', 'Unknown Error')
  .isEnumerable('message', 'Sorry, an unexpected error has occured, please try again later.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new UnknownError();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new UnknownError();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="unknownerror-get"></a>
## #get
should be a function.

```js
const test = new UnknownError();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new UnknownError();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 520)
  .hasProperty('status', 'Unknown Error')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 520)
  .hasProperty('status', 'Unknown Error')
  .hasProperty('message', 'Sorry, an unexpected error has occured, please try again later.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new UnknownError();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 520)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 520)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="unknownerror-tojson"></a>
## #toJSON
should be a function.

```js
const test = new UnknownError();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new UnknownError();
unit
  .object(test.toJSON())
  .hasProperty('code', 520)
  .hasProperty('status', 'Unknown Error')
  .hasProperty('message', 'Sorry, an unexpected error has occured, please try again later.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 520)
  .hasProperty('status', 'Unknown Error')
  .hasProperty('message', 'Sorry, an unexpected error has occured, please try again later.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="unknownerror-tostring"></a>
## #toString
should be a function.

```js
const test = new UnknownError();
unit
  .function(test.toString);
```

should return UnknownError: 520 Unknown Error.

```js
const test = new UnknownError();
unit
  .string(test.toString())
  .is('UnknownError: 520 Unknown Error');
```

<a name="unknownerror-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/unknownerror".

```js
const test = new UnknownError();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/unknownerror');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new UnknownError();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/unknownerror]');
```

<a name="unprocessableentity"></a>
# UnprocessableEntity
should be a function.

```js
unit
  .function(UnprocessableEntity);
```

should return an instance of UnprocessableEntity.

```js
unit
  .object(new UnprocessableEntity())
  .isInstanceOf(UnprocessableEntity)
  .isEnumerable('code', 422)
  .isEnumerable('status', 'Unprocessable Entity')
  .isEnumerable('message', 'Sorry, it appears your document instructions are semantically erroneous.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof UnprocessableEntity without the new operator.

```js
unit
  .object(UnprocessableEntity())
  .isInstanceOf(UnprocessableEntity)
  .isEnumerable('code', 422)
  .isEnumerable('status', 'Unprocessable Entity')
  .isEnumerable('message', 'Sorry, it appears your document instructions are semantically erroneous.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="unprocessableentity-version"></a>
## #VERSION
should be a constant property.

```js
const test = new UnprocessableEntity();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="unprocessableentity-code"></a>
## #code
should be a constant property.

```js
const test = new UnprocessableEntity();
unit
  .number(test.code)
  .is(422);
```

<a name="unprocessableentity-status"></a>
## #status
should be a constant property.

```js
const test = new UnprocessableEntity();
unit
  .string(test.status)
  .is('Unprocessable Entity');
```

<a name="unprocessableentity-message"></a>
## #message
should have a default message.

```js
const test = new UnprocessableEntity();
unit
  .string(test.message)
  .is('Sorry, it appears your document instructions are semantically erroneous.');
```

should accept falsy as the default message.

```js
const test = new UnprocessableEntity();
unit
  .string(test.message)
  .is('Sorry, it appears your document instructions are semantically erroneous.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Sorry, it appears your document instructions are semantically erroneous.')
  .given(test.message = null)
  .string(test.message)
  .is('Sorry, it appears your document instructions are semantically erroneous.')
  .given(test.message = false)
  .string(test.message)
  .is('Sorry, it appears your document instructions are semantically erroneous.')
  .given(test.message = 0)
  .string(test.message)
  .is('Sorry, it appears your document instructions are semantically erroneous.')
  .given(test.message = '')
  .string(test.message)
  .is('Sorry, it appears your document instructions are semantically erroneous.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Sorry, it appears your document instructions are semantically erroneous.');
```

should accept a string.

```js
const test = new UnprocessableEntity();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Unprocessable Entity')
  .string(test.message)
  .is('Unprocessable Entity');
```

should accept stringifiable arrays.

```js
const test = new UnprocessableEntity();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new UnprocessableEntity();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new UnprocessableEntity();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="unprocessableentity-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new UnprocessableEntity();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new UnprocessableEntity({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="unprocessableentity-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new UnprocessableEntity();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new UnprocessableEntity();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(UnprocessableEntity)
  .hasProperty('message', 'Bad things.');
```

<a name="unprocessableentity-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new UnprocessableEntity();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new UnprocessableEntity({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="unprocessableentity-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new UnprocessableEntity();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new UnprocessableEntity();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(UnprocessableEntity)
  .hasProperty('debug', 'Something happened.');
```

<a name="unprocessableentity-getcause"></a>
## #getCause
should be a function.

```js
const test = new UnprocessableEntity();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new UnprocessableEntity({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="unprocessableentity-setcause"></a>
## #setCause
should be a function.

```js
const test = new UnprocessableEntity();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new UnprocessableEntity();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(UnprocessableEntity)
  .hasProperty('cause', cause);
```

<a name="unprocessableentity-set"></a>
## #set
should be a function.

```js
const test = new UnprocessableEntity();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new UnprocessableEntity();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(UnprocessableEntity)
  .isEnumerable('code', 422)
  .isEnumerable('status', 'Unprocessable Entity')
  .isEnumerable('message', 'Sorry, it appears your document instructions are semantically erroneous.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(UnprocessableEntity)
  .isEnumerable('code', 422)
  .isEnumerable('status', 'Unprocessable Entity')
  .isEnumerable('message', 'Sorry, it appears your document instructions are semantically erroneous.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(UnprocessableEntity)
  .isEnumerable('code', 422)
  .isEnumerable('status', 'Unprocessable Entity')
  .isEnumerable('message', 'Sorry, it appears your document instructions are semantically erroneous.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(UnprocessableEntity)
  .isEnumerable('code', 422)
  .isEnumerable('status', 'Unprocessable Entity')
  .isEnumerable('message', 'Sorry, it appears your document instructions are semantically erroneous.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new UnprocessableEntity();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new UnprocessableEntity();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="unprocessableentity-get"></a>
## #get
should be a function.

```js
const test = new UnprocessableEntity();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new UnprocessableEntity();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 422)
  .hasProperty('status', 'Unprocessable Entity')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 422)
  .hasProperty('status', 'Unprocessable Entity')
  .hasProperty('message', 'Sorry, it appears your document instructions are semantically erroneous.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new UnprocessableEntity();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 422)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 422)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="unprocessableentity-tojson"></a>
## #toJSON
should be a function.

```js
const test = new UnprocessableEntity();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new UnprocessableEntity();
unit
  .object(test.toJSON())
  .hasProperty('code', 422)
  .hasProperty('status', 'Unprocessable Entity')
  .hasProperty('message', 'Sorry, it appears your document instructions are semantically erroneous.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 422)
  .hasProperty('status', 'Unprocessable Entity')
  .hasProperty('message', 'Sorry, it appears your document instructions are semantically erroneous.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="unprocessableentity-tostring"></a>
## #toString
should be a function.

```js
const test = new UnprocessableEntity();
unit
  .function(test.toString);
```

should return UnprocessableEntity: 422 Unprocessable Entity.

```js
const test = new UnprocessableEntity();
unit
  .string(test.toString())
  .is('UnprocessableEntity: 422 Unprocessable Entity');
```

<a name="unprocessableentity-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/unprocessableentity".

```js
const test = new UnprocessableEntity();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/unprocessableentity');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new UnprocessableEntity();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/unprocessableentity]');
```

<a name="unsupportedmediatype"></a>
# UnsupportedMediaType
should be a function.

```js
unit
  .function(UnsupportedMediaType);
```

should return an instance of UnsupportedMediaType.

```js
unit
  .object(new UnsupportedMediaType())
  .isInstanceOf(UnsupportedMediaType)
  .isEnumerable('code', 415)
  .isEnumerable('status', 'Unsupported Media Type')
  .isEnumerable('message', 'Please, try again with a different media format.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof UnsupportedMediaType without the new operator.

```js
unit
  .object(UnsupportedMediaType())
  .isInstanceOf(UnsupportedMediaType)
  .isEnumerable('code', 415)
  .isEnumerable('status', 'Unsupported Media Type')
  .isEnumerable('message', 'Please, try again with a different media format.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="unsupportedmediatype-version"></a>
## #VERSION
should be a constant property.

```js
const test = new UnsupportedMediaType();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="unsupportedmediatype-code"></a>
## #code
should be a constant property.

```js
const test = new UnsupportedMediaType();
unit
  .number(test.code)
  .is(415);
```

<a name="unsupportedmediatype-status"></a>
## #status
should be a constant property.

```js
const test = new UnsupportedMediaType();
unit
  .string(test.status)
  .is('Unsupported Media Type');
```

<a name="unsupportedmediatype-message"></a>
## #message
should have a default message.

```js
const test = new UnsupportedMediaType();
unit
  .string(test.message)
  .is('Please, try again with a different media format.');
```

should accept falsy as the default message.

```js
const test = new UnsupportedMediaType();
unit
  .string(test.message)
  .is('Please, try again with a different media format.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Please, try again with a different media format.')
  .given(test.message = null)
  .string(test.message)
  .is('Please, try again with a different media format.')
  .given(test.message = false)
  .string(test.message)
  .is('Please, try again with a different media format.')
  .given(test.message = 0)
  .string(test.message)
  .is('Please, try again with a different media format.')
  .given(test.message = '')
  .string(test.message)
  .is('Please, try again with a different media format.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Please, try again with a different media format.');
```

should accept a string.

```js
const test = new UnsupportedMediaType();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Unsupported Media Type')
  .string(test.message)
  .is('Unsupported Media Type');
```

should accept stringifiable arrays.

```js
const test = new UnsupportedMediaType();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new UnsupportedMediaType();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new UnsupportedMediaType();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="unsupportedmediatype-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new UnsupportedMediaType();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new UnsupportedMediaType({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="unsupportedmediatype-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new UnsupportedMediaType();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new UnsupportedMediaType();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(UnsupportedMediaType)
  .hasProperty('message', 'Bad things.');
```

<a name="unsupportedmediatype-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new UnsupportedMediaType();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new UnsupportedMediaType({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="unsupportedmediatype-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new UnsupportedMediaType();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new UnsupportedMediaType();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(UnsupportedMediaType)
  .hasProperty('debug', 'Something happened.');
```

<a name="unsupportedmediatype-getcause"></a>
## #getCause
should be a function.

```js
const test = new UnsupportedMediaType();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new UnsupportedMediaType({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="unsupportedmediatype-setcause"></a>
## #setCause
should be a function.

```js
const test = new UnsupportedMediaType();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new UnsupportedMediaType();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(UnsupportedMediaType)
  .hasProperty('cause', cause);
```

<a name="unsupportedmediatype-set"></a>
## #set
should be a function.

```js
const test = new UnsupportedMediaType();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new UnsupportedMediaType();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(UnsupportedMediaType)
  .isEnumerable('code', 415)
  .isEnumerable('status', 'Unsupported Media Type')
  .isEnumerable('message', 'Please, try again with a different media format.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(UnsupportedMediaType)
  .isEnumerable('code', 415)
  .isEnumerable('status', 'Unsupported Media Type')
  .isEnumerable('message', 'Please, try again with a different media format.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(UnsupportedMediaType)
  .isEnumerable('code', 415)
  .isEnumerable('status', 'Unsupported Media Type')
  .isEnumerable('message', 'Please, try again with a different media format.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(UnsupportedMediaType)
  .isEnumerable('code', 415)
  .isEnumerable('status', 'Unsupported Media Type')
  .isEnumerable('message', 'Please, try again with a different media format.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new UnsupportedMediaType();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new UnsupportedMediaType();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="unsupportedmediatype-get"></a>
## #get
should be a function.

```js
const test = new UnsupportedMediaType();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new UnsupportedMediaType();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 415)
  .hasProperty('status', 'Unsupported Media Type')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 415)
  .hasProperty('status', 'Unsupported Media Type')
  .hasProperty('message', 'Please, try again with a different media format.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new UnsupportedMediaType();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 415)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 415)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="unsupportedmediatype-tojson"></a>
## #toJSON
should be a function.

```js
const test = new UnsupportedMediaType();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new UnsupportedMediaType();
unit
  .object(test.toJSON())
  .hasProperty('code', 415)
  .hasProperty('status', 'Unsupported Media Type')
  .hasProperty('message', 'Please, try again with a different media format.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 415)
  .hasProperty('status', 'Unsupported Media Type')
  .hasProperty('message', 'Please, try again with a different media format.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="unsupportedmediatype-tostring"></a>
## #toString
should be a function.

```js
const test = new UnsupportedMediaType();
unit
  .function(test.toString);
```

should return UnsupportedMediaType: 415 Unsupported Media Type.

```js
const test = new UnsupportedMediaType();
unit
  .string(test.toString())
  .is('UnsupportedMediaType: 415 Unsupported Media Type');
```

<a name="unsupportedmediatype-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/unsupportedmediatype".

```js
const test = new UnsupportedMediaType();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/unsupportedmediatype');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new UnsupportedMediaType();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/unsupportedmediatype]');
```

<a name="upgraderequired"></a>
# UpgradeRequired
should be a function.

```js
unit
  .function(UpgradeRequired);
```

should return an instance of UpgradeRequired.

```js
unit
  .object(new UpgradeRequired())
  .isInstanceOf(UpgradeRequired)
  .isEnumerable('code', 426)
  .isEnumerable('status', 'Upgrade Required')
  .isEnumerable('message', 'Please, upgrade and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof UpgradeRequired without the new operator.

```js
unit
  .object(UpgradeRequired())
  .isInstanceOf(UpgradeRequired)
  .isEnumerable('code', 426)
  .isEnumerable('status', 'Upgrade Required')
  .isEnumerable('message', 'Please, upgrade and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="upgraderequired-version"></a>
## #VERSION
should be a constant property.

```js
const test = new UpgradeRequired();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="upgraderequired-code"></a>
## #code
should be a constant property.

```js
const test = new UpgradeRequired();
unit
  .number(test.code)
  .is(426);
```

<a name="upgraderequired-status"></a>
## #status
should be a constant property.

```js
const test = new UpgradeRequired();
unit
  .string(test.status)
  .is('Upgrade Required');
```

<a name="upgraderequired-message"></a>
## #message
should have a default message.

```js
const test = new UpgradeRequired();
unit
  .string(test.message)
  .is('Please, upgrade and try again.');
```

should accept falsy as the default message.

```js
const test = new UpgradeRequired();
unit
  .string(test.message)
  .is('Please, upgrade and try again.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Please, upgrade and try again.')
  .given(test.message = null)
  .string(test.message)
  .is('Please, upgrade and try again.')
  .given(test.message = false)
  .string(test.message)
  .is('Please, upgrade and try again.')
  .given(test.message = 0)
  .string(test.message)
  .is('Please, upgrade and try again.')
  .given(test.message = '')
  .string(test.message)
  .is('Please, upgrade and try again.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Please, upgrade and try again.');
```

should accept a string.

```js
const test = new UpgradeRequired();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Upgrade Required')
  .string(test.message)
  .is('Upgrade Required');
```

should accept stringifiable arrays.

```js
const test = new UpgradeRequired();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new UpgradeRequired();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new UpgradeRequired();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="upgraderequired-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new UpgradeRequired();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new UpgradeRequired({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="upgraderequired-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new UpgradeRequired();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new UpgradeRequired();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(UpgradeRequired)
  .hasProperty('message', 'Bad things.');
```

<a name="upgraderequired-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new UpgradeRequired();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new UpgradeRequired({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="upgraderequired-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new UpgradeRequired();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new UpgradeRequired();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(UpgradeRequired)
  .hasProperty('debug', 'Something happened.');
```

<a name="upgraderequired-getcause"></a>
## #getCause
should be a function.

```js
const test = new UpgradeRequired();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new UpgradeRequired({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="upgraderequired-setcause"></a>
## #setCause
should be a function.

```js
const test = new UpgradeRequired();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new UpgradeRequired();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(UpgradeRequired)
  .hasProperty('cause', cause);
```

<a name="upgraderequired-set"></a>
## #set
should be a function.

```js
const test = new UpgradeRequired();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new UpgradeRequired();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(UpgradeRequired)
  .isEnumerable('code', 426)
  .isEnumerable('status', 'Upgrade Required')
  .isEnumerable('message', 'Please, upgrade and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(UpgradeRequired)
  .isEnumerable('code', 426)
  .isEnumerable('status', 'Upgrade Required')
  .isEnumerable('message', 'Please, upgrade and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(UpgradeRequired)
  .isEnumerable('code', 426)
  .isEnumerable('status', 'Upgrade Required')
  .isEnumerable('message', 'Please, upgrade and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(UpgradeRequired)
  .isEnumerable('code', 426)
  .isEnumerable('status', 'Upgrade Required')
  .isEnumerable('message', 'Please, upgrade and try again.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new UpgradeRequired();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new UpgradeRequired();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="upgraderequired-get"></a>
## #get
should be a function.

```js
const test = new UpgradeRequired();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new UpgradeRequired();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 426)
  .hasProperty('status', 'Upgrade Required')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 426)
  .hasProperty('status', 'Upgrade Required')
  .hasProperty('message', 'Please, upgrade and try again.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new UpgradeRequired();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 426)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 426)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="upgraderequired-tojson"></a>
## #toJSON
should be a function.

```js
const test = new UpgradeRequired();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new UpgradeRequired();
unit
  .object(test.toJSON())
  .hasProperty('code', 426)
  .hasProperty('status', 'Upgrade Required')
  .hasProperty('message', 'Please, upgrade and try again.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 426)
  .hasProperty('status', 'Upgrade Required')
  .hasProperty('message', 'Please, upgrade and try again.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="upgraderequired-tostring"></a>
## #toString
should be a function.

```js
const test = new UpgradeRequired();
unit
  .function(test.toString);
```

should return UpgradeRequired: 426 Upgrade Required.

```js
const test = new UpgradeRequired();
unit
  .string(test.toString())
  .is('UpgradeRequired: 426 Upgrade Required');
```

<a name="upgraderequired-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/upgraderequired".

```js
const test = new UpgradeRequired();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/upgraderequired');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new UpgradeRequired();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/upgraderequired]');
```

<a name="variantalsonegotiates"></a>
# VariantAlsoNegotiates
should be a function.

```js
unit
  .function(VariantAlsoNegotiates);
```

should return an instance of VariantAlsoNegotiates.

```js
unit
  .object(new VariantAlsoNegotiates())
  .isInstanceOf(VariantAlsoNegotiates)
  .isEnumerable('code', 506)
  .isEnumerable('status', 'Variant Also Negotiates')
  .isEnumerable('message', 'Sorry, it appears there is a misconfiguration on our end.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should return an instaceof VariantAlsoNegotiates without the new operator.

```js
unit
  .object(VariantAlsoNegotiates())
  .isInstanceOf(VariantAlsoNegotiates)
  .isEnumerable('code', 506)
  .isEnumerable('status', 'Variant Also Negotiates')
  .isEnumerable('message', 'Sorry, it appears there is a misconfiguration on our end.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

<a name="variantalsonegotiates-version"></a>
## #VERSION
should be a constant property.

```js
const test = new VariantAlsoNegotiates();
unit
  .string(test.VERSION)
  .is(version);
```

<a name="variantalsonegotiates-code"></a>
## #code
should be a constant property.

```js
const test = new VariantAlsoNegotiates();
unit
  .number(test.code)
  .is(506);
```

<a name="variantalsonegotiates-status"></a>
## #status
should be a constant property.

```js
const test = new VariantAlsoNegotiates();
unit
  .string(test.status)
  .is('Variant Also Negotiates');
```

<a name="variantalsonegotiates-message"></a>
## #message
should have a default message.

```js
const test = new VariantAlsoNegotiates();
unit
  .string(test.message)
  .is('Sorry, it appears there is a misconfiguration on our end.');
```

should accept falsy as the default message.

```js
const test = new VariantAlsoNegotiates();
unit
  .string(test.message)
  .is('Sorry, it appears there is a misconfiguration on our end.')
  .given(test.message = undefined)
  .string(test.message)
  .is('Sorry, it appears there is a misconfiguration on our end.')
  .given(test.message = null)
  .string(test.message)
  .is('Sorry, it appears there is a misconfiguration on our end.')
  .given(test.message = false)
  .string(test.message)
  .is('Sorry, it appears there is a misconfiguration on our end.')
  .given(test.message = 0)
  .string(test.message)
  .is('Sorry, it appears there is a misconfiguration on our end.')
  .given(test.message = '')
  .string(test.message)
  .is('Sorry, it appears there is a misconfiguration on our end.')
  .given(test.message = '     ')
  .string(test.message)
  .is('Sorry, it appears there is a misconfiguration on our end.');
```

should accept a string.

```js
const test = new VariantAlsoNegotiates();
unit
  .given(test.message = 'Error')
  .string(test.message)
  .is('Error')
  .given(test.message = 'Invalid')
  .string(test.message)
  .is('Invalid')
  .given(test.message = 'Variant Also Negotiates')
  .string(test.message)
  .is('Variant Also Negotiates');
```

should accept stringifiable arrays.

```js
const test = new VariantAlsoNegotiates();
unit
  .given(test.message = ['Bad', 'Request'])
  .string(test.message)
  .is('Bad,Request')
  .given(test.message = ['Not', 'Good'])
  .string(test.message)
  .is('Not,Good')
  .given(test.message = ['Invalid'])
  .string(test.message)
  .is('Invalid');
```

should accept numbers.

```js
const test = new VariantAlsoNegotiates();
unit
  .given(test.message = 5)
  .string(test.message)
  .is('5')
  .given(test.message = -10)
  .string(test.message)
  .is('-10')
  .given(test.message = 0.4)
  .string(test.message)
  .is('0.4')
  .given(test.message = -4.2)
  .string(test.message)
  .is('-4.2');
```

should accept stringifiable objects.

```js
const test = new VariantAlsoNegotiates();
unit
  .given(test.message = /asd/u)
  .string(test.message)
  .is('/asd/u')
  .given(test.message = [1, 2, 3])
  .string(test.message)
  .is('1,2,3')
  .given(test.message = {a: 5})
  .string(test.message)
  .is('[object Object]')
  .given(test.message = {
    toString: () => {
      return 'Hello';
    },
  })
  .string(test.message)
  .is('Hello');
```

<a name="variantalsonegotiates-getmessage"></a>
## #getMessage
should be a function.

```js
const test = new VariantAlsoNegotiates();
unit
  .function(test.getMessage);
```

should return message.

```js
const test = new VariantAlsoNegotiates({
  message: 'Something happened.',
});
unit
  .string(test.getMessage())
  .is('Something happened.');
```

<a name="variantalsonegotiates-setmessage"></a>
## #setMessage
should be a function.

```js
const test = new VariantAlsoNegotiates();
unit
  .function(test.setMessage);
```

should set message and return this for chaining.

```js
const test = new VariantAlsoNegotiates();
unit
  .object(test.setMessage('Bad things.'))
  .isInstanceOf(VariantAlsoNegotiates)
  .hasProperty('message', 'Bad things.');
```

<a name="variantalsonegotiates-getdebug"></a>
## #getDebug
should be a function.

```js
const test = new VariantAlsoNegotiates();
unit
  .function(test.getDebug);
```

should return debug.

```js
const test = new VariantAlsoNegotiates({
  debug: 'Missing required parameters.',
});
unit
  .string(test.getDebug())
  .is('Missing required parameters.');
```

<a name="variantalsonegotiates-setdebug"></a>
## #setDebug
should be a function.

```js
const test = new VariantAlsoNegotiates();
unit
  .function(test.setDebug);
```

should set debug and return this for chaining.

```js
const test = new VariantAlsoNegotiates();
unit
  .object(test.setDebug('Something happened.'))
  .isInstanceOf(VariantAlsoNegotiates)
  .hasProperty('debug', 'Something happened.');
```

<a name="variantalsonegotiates-getcause"></a>
## #getCause
should be a function.

```js
const test = new VariantAlsoNegotiates();
unit
  .function(test.getCause);
```

should return cause.

```js
const test = new VariantAlsoNegotiates({
  cause: new Error('boom!'),
});
unit
  .object(test.getCause())
  .is(test.cause);
```

<a name="variantalsonegotiates-setcause"></a>
## #setCause
should be a function.

```js
const test = new VariantAlsoNegotiates();
unit
  .function(test.setCause);
```

should set cause and return this for chaining.

```js
const test = new VariantAlsoNegotiates();
const cause = new Error('boom!');
unit
  .object(test.setCause(cause))
  .isInstanceOf(VariantAlsoNegotiates)
  .hasProperty('cause', cause);
```

<a name="variantalsonegotiates-set"></a>
## #set
should be a function.

```js
const test = new VariantAlsoNegotiates();
unit
  .function(test.set);
```

should do nothing when not given an iterable.

```js
const test = new VariantAlsoNegotiates();
unit
  .given(test.set())
  .object(test)
  .isInstanceOf(VariantAlsoNegotiates)
  .isEnumerable('code', 506)
  .isEnumerable('status', 'Variant Also Negotiates')
  .isEnumerable('message', 'Sorry, it appears there is a misconfiguration on our end.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(null))
  .object(test)
  .isInstanceOf(VariantAlsoNegotiates)
  .isEnumerable('code', 506)
  .isEnumerable('status', 'Variant Also Negotiates')
  .isEnumerable('message', 'Sorry, it appears there is a misconfiguration on our end.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(5))
  .object(test)
  .isInstanceOf(VariantAlsoNegotiates)
  .isEnumerable('code', 506)
  .isEnumerable('status', 'Variant Also Negotiates')
  .isEnumerable('message', 'Sorry, it appears there is a misconfiguration on our end.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version)
  .given(test.set(true))
  .object(test)
  .isInstanceOf(VariantAlsoNegotiates)
  .isEnumerable('code', 506)
  .isEnumerable('status', 'Variant Also Negotiates')
  .isEnumerable('message', 'Sorry, it appears there is a misconfiguration on our end.')
  .isEnumerable('debug')
  .isEnumerable('cause')
  .hasProperty('VERSION', version);
```

should accept an object hash.

```js
const test = new VariantAlsoNegotiates();
const opt = {
  message: 'Something meaningful for the user',
  debug: 'Something meaningful for the developer',
  cause: new Error('boom!'),
};
unit
  .object(test.set(opt))
  .hasProperty('message', opt.message)
  .hasProperty('debug', opt.debug)
  .hasProperty('cause', opt.cause);
```

should throw an error when given unacceptable keys iterable.

```js
const test = new VariantAlsoNegotiates();
unit
  .error(() => {
    test.set({a: 5});
  })
  .error(() => {
    test.set('asd');
  })
  .error(() => {
    test.set([1, 2, 3]);
  });
```

<a name="variantalsonegotiates-get"></a>
## #get
should be a function.

```js
const test = new VariantAlsoNegotiates();
unit
  .function(test.get);
```

should accept a list of argument names to return an object hash.

```js
const test = new VariantAlsoNegotiates();
unit
  .object(test.get('code', 'status'))
  .hasProperty('code', 506)
  .hasProperty('status', 'Variant Also Negotiates')
  .object(test.get(['code', 'status'], 'message', ['cause', ['debug']]))
  .hasProperty('code', 506)
  .hasProperty('status', 'Variant Also Negotiates')
  .hasProperty('message', 'Sorry, it appears there is a misconfiguration on our end.')
  .hasProperty('cause', undefined)
  .hasProperty('debug', undefined);
```

should not return argument names that do not exist.

```js
const test = new VariantAlsoNegotiates();
unit
  .object(test.get('a', 'b', 'code'))
  .hasProperty('code', 506)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .object(test.get('code', ['a', ['b'], 'c'], 'd'))
  .hasProperty('code', 506)
  .hasNotProperty('a')
  .hasNotProperty('b')
  .hasNotProperty('c')
  .hasNotProperty('d');
```

<a name="variantalsonegotiates-tojson"></a>
## #toJSON
should be a function.

```js
const test = new VariantAlsoNegotiates();
unit
  .function(test.toJSON);
```

should return a object for serialization.

```js
const test = new VariantAlsoNegotiates();
unit
  .object(test.toJSON())
  .hasProperty('code', 506)
  .hasProperty('status', 'Variant Also Negotiates')
  .hasProperty('message', 'Sorry, it appears there is a misconfiguration on our end.')
  .hasProperty('debug', undefined)
  .hasProperty('cause', undefined)
  .given(test.debug = 'Missing required parameters.')
  .object(test.toJSON())
  .hasProperty('code', 506)
  .hasProperty('status', 'Variant Also Negotiates')
  .hasProperty('message', 'Sorry, it appears there is a misconfiguration on our end.')
  .hasProperty('debug', 'Missing required parameters.')
  .hasProperty('cause', undefined);
```

<a name="variantalsonegotiates-tostring"></a>
## #toString
should be a function.

```js
const test = new VariantAlsoNegotiates();
unit
  .function(test.toString);
```

should return VariantAlsoNegotiates: 506 Variant Also Negotiates.

```js
const test = new VariantAlsoNegotiates();
unit
  .string(test.toString())
  .is('VariantAlsoNegotiates: 506 Variant Also Negotiates');
```

<a name="variantalsonegotiates-symboltostringtag"></a>
## #[Symbol.toStringTag]
should return "@scuba-squad/variantalsonegotiates".

```js
const test = new VariantAlsoNegotiates();
unit
  .string(test[Symbol.toStringTag])
  .is('@scuba-squad/variantalsonegotiates');
```

should return "[object @scuba-squad/httperror]" for Object.prototype.toString.call.

```js
const test = new VariantAlsoNegotiates();
unit
  .string(Object.prototype.toString.call(test))
  .is('[object @scuba-squad/variantalsonegotiates]');
```

<a name="client"></a>
# client
should expose default classes.

```js
unit
  .object(client)
  .hasProperties([
    'BadRequest',
    'Unauthorized',
    'PaymentRequired',
    'Forbidden',
    'NotFound',
    'MethodNotAllowed',
    'NotAcceptable',
    'ProxyAuthenticationRequired',
    'RequestTimeout',
    'Conflict',
    'Gone',
    'LengthRequired',
    'PreconditionFailed',
    'PayloadTooLarge',
    'URITooLong',
    'UnsupportedMediaType',
    'RangeNotSatisfiable',
    'ExpectationFailed',
    'IMATeapot',
    'MisdirectedRequest',
    'UnprocessableEntity',
    'Locked',
    'FailedDependency',
    'UpgradeRequired',
    'PreconditionRequired',
    'TooManyRequests',
    'RequestHeaderFieldsTooLarge',
    'UnavailableForLegalReasons',
  ]);
```

<a name="index"></a>
# index
should expose default classes.

```js
unit
  .object(index)
  .hasProperties([
    'BadRequest',
    'Unauthorized',
    'PaymentRequired',
    'Forbidden',
    'NotFound',
    'MethodNotAllowed',
    'NotAcceptable',
    'ProxyAuthenticationRequired',
    'RequestTimeout',
    'Conflict',
    'Gone',
    'LengthRequired',
    'PreconditionFailed',
    'PayloadTooLarge',
    'URITooLong',
    'UnsupportedMediaType',
    'RangeNotSatisfiable',
    'ExpectationFailed',
    'IMATeapot',
    'MisdirectedRequest',
    'UnprocessableEntity',
    'Locked',
    'FailedDependency',
    'UpgradeRequired',
    'PreconditionRequired',
    'TooManyRequests',
    'RequestHeaderFieldsTooLarge',
    'UnavailableForLegalReasons',
    'InternalServerError',
    'NotImplemented',
    'BadGateway',
    'ServiceUnavailable',
    'GatewayTimeout',
    'HTTPVersionNotSupported',
    'VariantAlsoNegotiates',
    'InsufficientStorage',
    'LoopDetected',
    'NotExtended',
    'NetworkAuthenticationRequired',
    'UnknownError',
    'HttpError',
    'ClientError',
    'ServerError',
  ]);
```

<a name="server"></a>
# server
should expose default classes.

```js
unit
  .object(server)
  .hasProperties([
    'InternalServerError',
    'NotImplemented',
    'BadGateway',
    'ServiceUnavailable',
    'GatewayTimeout',
    'HTTPVersionNotSupported',
    'VariantAlsoNegotiates',
    'InsufficientStorage',
    'LoopDetected',
    'NotExtended',
    'NetworkAuthenticationRequired',
    'UnknownError',
  ]);
```

